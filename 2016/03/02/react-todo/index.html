<!DOCTYPE html><html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0,  user-scalable=0" name="viewport"><title>KIT</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/index.min.css"></head><body><nav class="nav-button-list"><div class="btn menu show-canvas"><span class="icon-bar"></span></div><div class="btn top btn-go-top"><i class="ion-arrow-up-c"></i><span class="scroll-percentage">0%</span></div></nav><div class="main-wrap"><div class="container"><div class="row"><div class="col-lg-3 side-bar-left"><div class="sidebar-content"><div class="main-side-bar"><div class="header"><p>爱好上班，特长加班</p><p>求职中</p><p>catslove28@163.com</p></div><nav class="side-bar-nav"><a href="/" class="item"><span>首页</span></a><a href="/archives" class="item m"><span>归档</span></a><a href="/tags" class="item last unopen"><span>标签</span></a></nav></div><div class="card directory-card"><div class="header">文章目录</div><div class="directory"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#小科普"><span class="nav-number">1.</span> <span class="nav-text">小科普</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Demo功能需求"><span class="nav-number">2.</span> <span class="nav-text">Demo功能需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始"><span class="nav-number">3.</span> <span class="nav-text">开始</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#配置webpack"><span class="nav-number">3.1.</span> <span class="nav-text">配置webpack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#上代码"><span class="nav-number">3.2.</span> <span class="nav-text">上代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#App生命-state"><span class="nav-number">3.3.</span> <span class="nav-text">App生命 - state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他组件"><span class="nav-number">3.4.</span> <span class="nav-text">其他组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div></div></div></div><div class="col-lg-9 main-content"><div class="post-detail-wrap content-wrap"><main class="post post-detail"><div class="post-header"><div class="header">React-todo demo</div><section class="info"><div class="item"><i class="ion-android-calendar"></i><span>发表于 2016年3月2日</span></div><div class="item"><i class="ion-android-folder-open"></i><span>分类于 <a href="/categories/前端/">前端</a></span></div></section></div><article data-spy="scroll" data-target="panel1" class="content"><p>好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。</p>
<a id="more"></a>
<h3 id="小科普"><a href="#小科普" class="headerlink" title="小科普"></a>小科普</h3><p>什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。<br>至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！</p>
<h3 id="Demo功能需求"><a href="#Demo功能需求" class="headerlink" title="Demo功能需求"></a>Demo功能需求</h3><ul>
<li>input输入内容，回车键或按钮增加一条todo</li>
<li>checkbox添加完成状态</li>
<li>移动到列表时显示删除</li>
<li>显示todo总数和已经完成数</li>
<li>list全选</li>
<li>清除已完成</li>
<li>添加动画效果</li>
</ul>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>开始需要npm安装一下等下要用的packages，如果是checkout我的demo，就动动手指头，install一下，我的demo地址是<a href="https://github.com/kitwon/react-todo" target="_blank" rel="external">https://github.com/kitwon/react-todo</a></p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">$npm install
</code></pre>
<h4 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h4><p>所有东西安装完成之后首先就是配置<a href="http://webpack.github.io/docs/" target="_blank" rel="external">webpack</a></p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">var path = require(&#39;path&#39;);

module.exports = {
    entry : &quot;./src/entry.js&quot;,
    output : {
        path : path.join(__dirname, &quot;out&quot;),
        publicPath : &quot;./out/&quot;,
        filename : &quot;bundle.js&quot;
    },
    externals : {
        react : &quot;React&quot;
    },
    module : {
        loaders : [
            { test : /\.js$/, loader : &quot;jsx&quot;,include: /src/ },
            { test : /\.css$/, loader : &quot;style!css&quot; },
            { test : /\.less$/, loader : &quot;style!css!less&quot; },
            { test : /\.(jpg|png)$/, loader : &quot;url?limit=8192&quot; }
        ]
    }
}
</code></pre>
<p>从上面可以看到，webpack的入口文件是entry.js，打包输出的文件是bundle.js，external属性是告诉webpack，当API已经存在的时候，使用全局变量，并不作任何操作。</p>
<p>loader的话没啥，看文档就知道，各种编译打包。具体使用方法可以看官方文档。</p>
<h4 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h4><p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">var React = require(&#39;React&#39;),
    ReactDOM = require(&#39;react-dom&#39;);

require(&#39;../less/app.less&#39;);

var AppFooter = require(&#39;./AppFooter&#39;),
    AppHeader = require(&#39;./AppHeader&#39;),
    ItemMain = require(&#39;./ItemMain&#39;);


var App = React.createClass ({
    getInitialState : function() {
        return {
            todoItem : [],
            isAllChecked : false
        }
    },
    //添加todo
    addItem : function(item) {
        var todoList = this.state.todoItem.push(item);
        this.setState({isAllChecked : false});
        this.forceUpdate();
    },
     //更改todo状态
    changeTodoState : function(index, isDone, isAllChange) {
        // isAllChange = false;
        if(isAllChange) {
            this.setState({
                todoItem: this.state.todoItem.map(function(todo) {
                    todo.isDone = isDone;
                    return todo;
                }),
                isAllChecked : isDone
            })
        }else {
            this.state.todoItem[index].isDone = isDone;
            this.allChecked();
            this.forceUpdate();
        }
    },
    //删除todo
    deleteTodo : function(index) {
        var newTodo = this.state.todoItem.splice(index, 1);
        this.setState({todoList: newTodo});
    },
    //清楚已完成
    clearDone : function() {
        var doneList = this.state.todoItem.filter(function(item) {
            return item.isDone === false;
        })
        this.setState({todoItem: doneList, isAllChecked: false});
    },
    //全部完成
    allChecked : function() {
        var allCheck = this.state.todoItem.every(function(item) {
            return item.isDone === true;
        })
        if (allCheck) {
            this.setState({isAllChecked : true})
        };
    },
        render : function(){
            var props = {
                todoLength : this.state.todoItem.length || 0,
                doneLength : this.state.todoItem.filter(function(item) {
                    return item.isDone === true;
                }).length || 0
            };
                return (
                    &lt;div className=&quot;panel&quot;&gt;
                        &lt;header  className=&quot;mainHeader&quot;&gt;&lt;h2&gt;Webpack + React TODO Demo&lt;/h2&gt;&lt;/header&gt;
                        &lt;AppHeader addItem={this.addItem}/&gt;
                        &lt;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} /&gt;
                            &lt;AppFooter {...props} isAllChecked={this.state.isAllChecked} clearDone={this.clearDone} changeAllState={this.changeTodoState} /&gt;
                    &lt;/div&gt;
                )
        }
})

ReactDOM.render(&lt;App/&gt;, document.getElementById(&quot;app&quot;));  //渲染
</code></pre>
<p>从代码上面可以看到各种require，没加载commonjs、seajs或其他模块化工具，为什么能直接require呢，而且还有require less，没错，webpack就是那么暴力！js后面都会打包好一个文件，样式都会加载到html里面，做spa时候，和react简直绝配。</p>
<h4 id="App生命-state"><a href="#App生命-state" class="headerlink" title="App生命 - state"></a>App生命 - state</h4><p>React主流思想就是父组件控制state，然后通过props传递给子组建，所以简单来说界面就像状态机，只要更新state，然后根据新的state重新渲染界面，不需要操作dom，所以react高性能原因也是因为这个。<br>从最上代码就可以看出父组件中的定义的方法基本是整个todo的功能了，然后render方法即渲染html和组件。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">&lt;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} /&gt;
</code></pre>
<p>然后取一小段渲染组件代码（上面代码）就可发现，父组件向ItemMain这个组件传了4个属性，其中itemList为state，只要todoItem一更新，react就会重新渲染这个组件，其他三个为方法，方法更新也会重新渲染组件。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// ItemMain.js
var React = require(&#39;React&#39;);
var Items = require(&#39;./Items&#39;);

var ItemMain = React.createClass({
    render : function() {
        var _this = this;
        return (
            &lt;section&gt;
                &lt;ul className=&quot;itemList&quot;&gt;
                    {_this.props.itemList.map(function (todo, index) {
                        return (
                            &lt;Items {...todo} key={index} index={index} {..._this.props} /&gt;
                        )
                    &lt;!-- })} --&gt;
                    &lt;!--这里不注释代码不高亮，比较奇葩，各位官人将就着看--&gt;
                &lt;/ul&gt;
            &lt;/section&gt;
        )
    }
})

module.exports = ItemMain;
</code></pre>
<p>看这里估计有点蒙，我自己看的时候也有点蒙，因为太久的代码了哈哈哈。<br>这个js只有一个循环Item的逻辑，首先看看<code>{...todo}</code>这个prop，这个是把itemList[i]中的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="external">数组对象解构</a>，然后传到item里面，如果没有…这个字符，则需要</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">&lt;Items text={props.text} isDone={props.isDone} key={index} index={index} changeTodoState={proprs.changeTodoState} deleteTodo={props.deleteTodo} /&gt;
</code></pre>
<p>具体数据大家可以在代码里面console打印一下，这样印象会更深。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// item.js
var React = require(&#39;React&#39;);

var Items = React.createClass({
    handleChange : function() {
        var isDone = !this.props.isDone;
        this.props.changeTodoState(this.props.index, isDone);
    },
    handleDeleteTodo : function() {
        this.props.deleteTodo(this.props.index);
    },
    render : function() {
        var doneStyle = this.props.isDone ? {textDecoration: &#39;line-through&#39;} : {textDecoration : &#39;none&#39;};
        return (
            &lt;li key={this.props.key} onMouseOver={this.handlerMouseOver} onMouseOut={this.handlerMouseOut}&gt;
                &lt;input type=&quot;checkbox&quot; checked={this.props.isDone} onChange={this.handleChange} /&gt;
                &lt;span style={doneStyle}&gt;{this.props.text}&lt;/span&gt;
                &lt;button className=&quot;btn btn-default delete-item&quot; onClick={this.handleDeleteTodo}&gt;delete&lt;/button&gt;
            &lt;/li&gt;
        )
    }
})

module.exports = Items;
</code></pre>
<p>这个就是js里面有两个方法，一个是改变状态，一个是删除当前todo，这这能发现，两个方法都是执行了又父组件传过来的方法，如下</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">this.props.changeTodoState(this.props.index, isDone);
</code></pre>
<p>执行这个函数，state就会更新，react就会根据状态重新渲染组件</p>
<h4 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h4><p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// AppHeader.js
var React = require(&#39;React&#39;);

var AppHeader = React.createClass({
    getInitialState : function() {
        return {
            text : &quot;&quot;
        }
    },
    handlerKeyUp : function(event) {
        if(event.keyCode === 13) {
            var value = event.target.value;
            if(!value) return false;

            var newTodoItem = {
                text : value,
                isDone : false
            }

            event.target.value = &quot;&quot;;
            this.setState({text: &quot;&quot;});
            this.props.addItem(newTodoItem);
        }
    },
    handleChange : function(event) {
        this.setState({text : event.target.value });
    },
    handlerClick : function(event) {
        var newTodoItem = {
            text : this.state.text,
            isDone : false
        }
        this.props.addItem(newTodoItem);
        this.setState({text: &quot;&quot;});
    },
    render : function() {
        return (
            &lt;section className=&quot;appHeader from-group&quot;&gt;
                &lt;input type=&quot;test&quot; className=&quot;form-control&quot; onKeyUp={this.handlerKeyUp} onChange={this.handleChange} placeholder=&quot;add one todo&quot; value={this.state.text}/&gt;
                &lt;button className=&quot;btn btn-primary&quot; onClick={this.handlerClick}&gt;add one&lt;/button&gt;
            &lt;/section&gt;
        )
    }
})

module.exports = AppHeader;
</code></pre>
<pre><code class="javascript">// AppHeader.js
var React = require(&#39;React&#39;);

var AppFooter = React.createClass({
    handleClick : function() {
        this.props.clearDone();
    },
    handleAllState : function(event) {
        this.props.changeAllState(null, event.target.value, true);
    },
    render : function() {
        return (
            &lt;section className=&quot;appFooter&quot;&gt;
                &lt;div&gt;
                    &lt;input type=&quot;checkbox&quot; checked={this.props.isAllChecked} onChange={this.handleAllState}/&gt;
                    &lt;span&gt;{this.props.doneLength}&lt;/span&gt;已经完成 / &lt;span&gt;{this.props.todoLength}&lt;/span&gt;总数
                &lt;/div&gt;
                &lt;button className=&quot;btn btn-default btn-tiny pull-right&quot; onClick={this.handleClick}&gt;clean done&lt;/button&gt;
            &lt;/section&gt;
        )
    }
})

module.exports = AppFooter;
</code></pre>
<p>Header Footer的方法都是大同小异，输入改变state，然后存起来，执行相应操作时候通过props的方法传给父组件，然后重新渲染界面。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回头看代码，react的组件化相比现在的组件化思想真的先进很多。React通过父组件来控制状态，并通过props传递给子组件。因此我们能很容易看出我们的事件属于哪个组件管理，然后修改相应的方法，维护起来相当高效，相比现在的控制dom，每次修改按钮的方法，都需要先找到id或者class，然后绑定响应的方法，假如页面id或者class改变，页面逻辑又非常复杂的话，修改起来是相当麻烦的。<br>React凭着出色的设计思想和性能，我相信不久就会成为主流的移动端开发方式，至于PC端，大天朝你懂的。</p>
</article></main><div class="page-footer"><div class="post-pagination"><a href="/2017/05/16/使用nodejs写一个命令行程序/"><i class="ion-arrow-left-c"></i>使用nodejs写一个命令行程序</a><a href="/2016/03/01/hello-world/">Hello World!<i class="ion-arrow-right-c"></i></a></div></div></div></div></div></div><div class="container-fluid copyright"><div> <span>©   2015 - 2016</span><i class="icon ion-ios-nutrition"></i><span>Kit</span></div><div><span>power by </span><span><a href="//hexo.io">hexo.</a></span><span>Design By Kit.</span></div></div></div><script src="/js/vendor.min.js"></script><script src="/js/post.min.js"></script></body></html>