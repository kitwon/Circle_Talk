{"version":3,"sources":["webpack:///path---post-js-class-88305b1d2ee25bb9790f.js","webpack:///./.cache/json/post-js-class.json"],"names":["webpackJsonp","289","module","exports","data","markdownRemark","html","frontmatter","date","path","title","headings","depth","value","pathContext","prev","category","tags","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,unGAAq5EC,aAAwvBC,KAAA,gBAAAC,KAAA,iBAAAC,MAAA,oBAA0EC,WAAcC,MAAA,EAAAC,MAAA,QAA0BD,MAAA,EAAAC,MAAA,iBAAmCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,iBAAmCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,SAA0BC,aAAgBC,MAAQL,MAAA,sBAAAF,KAAA,aAAAQ,UAAA,QAAAC,MAAA,gCAAAR,KAAA,uBAA2IS,MAASR,MAAA,wBAAAF,KAAA,aAAAQ,SAAA,KAAAC,KAAA,KAAAR,KAAA","file":"path---post-js-class-88305b1d2ee25bb9790f.js","sourcesContent":["webpackJsonp([139993780387781],{\n\n/***/ 289:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>类理论</h1>\\n<p>类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。</p>\\n<p>类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。<strong>汽车</strong>可以被看作<strong>交通工具中的一种</strong>，所以在软件开发时可以定义一个<code>Vehicle</code>类，<code>Vehicle</code>中包含推进器（引擎）、载人能力等方法。定义<code>Car</code>时，只要声明它继承或者拓展<code>Vehicle</code>这个基础定义就行了，其他交通工具如船、飞机也可以继承<code>Vehicle</code>。<strong>这就是类的实例化与继承</strong>。</p>\\n<p>类的另外一个核心概念是<strong>多态</strong>，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。</p>\\n<p>javascript中也有类中的<code>new</code>和<code>instanceof</code>，还有ES6中的<code>class</code>关键字，但这些并不是说明js中有<strong>类</strong>的。javascript中只是为了满足类的设计需求而提供一些类似的语法。</p>\\n<h2>js中实现类复制(混入)</h2>\\n<p>javascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。</p>\\n<!-- more -->\\n<h3>显式混入</h3>\\n<p>显示混入在其他库或者框架中一般被称为<code>extend</code>，在这方便理解会使用<code>mixin</code>。</p>\\n<pre><code class=\\\"language-javascript\\\">// 前面的Vehicle和car的例子\\nfunction mixin(sourceObj, targetObj) {\\n  for(var i in sourceObj) {\\n    if(!(i in targetObj)) {\\n      targetObj[i] = sourceObj[i];\\n    }\\n  }\\n\\n  return targetObj;\\n}\\n\\nvar Vehicle = {\\n  engines: 1,\\n  ignition: function() {\\n    console.log('Turning on my engines.');\\n  },\\n  drive: function() {\\n    this.ignition();\\n    console.log('Steering and moving forward.');\\n  }\\n}\\n\\nvar Car = mixin(Vehicle, {\\n  wheels: 4,\\n  drive: function() {\\n    Vehicle.drive.call(this);\\n    console.log('Rolling on all' + this.wheels + 'wheels!');\\n  }\\n})\\n</code></pre>\\n<p>还有一种显示混入的变体叫<strong>寄生继承</strong></p>\\n<pre><code class=\\\"language-javascript\\\">function Vehicle() {\\n  this.engines = 1;\\n}\\nVehicle.prototype.ignition = function() {\\n  console.log('Turning on my engines.');\\n}\\nVehicle.prototype.drive = function() {\\n  this.ignition();\\n  console.log('Steering and moving forward.');\\n}\\n\\n// 寄生类 car\\nfunction Car() {\\n  var car  = new Vehicle();\\n\\n  car.wheels = 4;\\n  var vehDrive = car.drive;\\n\\n  car.drive = function() {\\n    Vehicle.call(this);\\n    console.log('Rolling on all' + this.wheels + 'wheels!');\\n  }\\n\\n  return car;\\n}\\n\\nvar myCar = new Car();\\nmyCar.drive();\\n</code></pre>\\n<h3>隐式混入</h3>\\n<p>隐式混入就是改变在一个函数体内执行另外另一个函数的方法。</p>\\n<pre><code class=\\\"language-javascript\\\">var foo = {\\n  cool: function() {\\n    this.count = this.count ? this.count++ : 1;\\n    console.log(this.count);\\n  }\\n}\\n\\nfoo.cool(); // 1\\n\\nvar bar = {\\n  cool: function() {\\n    foo.cool.call(this);\\n  }\\n}\\n\\nbar.cool(); // 1, 数据不共享\\n</code></pre>\\n<h1>prototype-原型</h1>\\n<p>JS中，当试图引用对象属性时候就会触发<code>[[GET]]</code>操作，如果在对象属性中没有找到，就会使用对象的<code>[[prototype]]</code>链。JS大部分复杂类型都是<code>object</code>，所以<code>[[prototype]]</code>“尽头”应该是<code>Object.prototype</code>，里面包含了许多原生方法，如<code>toString</code>或<code>valueOf</code>。</p>\\n<h2>如何工作</h2>\\n<p>JS和其他OO语言并不同，JS中并没有类作为对象的抽象模式，JS中只有对象，所以当new一个对象时候，并不是复制一个类函数，而是将目标对象的<code>prototype</code>关联到新对象的<code>prototype</code>中。</p>\\n<h1>小结</h1>\\n<p><code>prototype</code>部分书本总结得比较清楚，想知道更多细节的同学可以参考<strong>you dont know javascript</strong>的5.1-5.4章节。</p>\\n<ul>\\n<li>访问对象时候都会触发对象的[[GET]]操作，如果没有找到属性的话会继续找[[Prototype]]链。</li>\\n<li>普通对象的原型链顶端都是<code>Object.prototype</code></li>\\n<li><code>new</code>调用函数时只会关系到对象，而不会复制</li>\\n</ul>\",\"frontmatter\":{\"date\":\"July 20, 2017\",\"path\":\"/post/js-class\",\"title\":\"深入学习javascript-类\"},\"headings\":[{\"depth\":1,\"value\":\"类理论\"},{\"depth\":2,\"value\":\"js中实现类复制(混入)\"},{\"depth\":3,\"value\":\"显式混入\"},{\"depth\":3,\"value\":\"隐式混入\"},{\"depth\":1,\"value\":\"prototype-原型\"},{\"depth\":2,\"value\":\"如何工作\"},{\"depth\":1,\"value\":\"小结\"}]}},\"pathContext\":{\"prev\":{\"title\":\"在vue项目中使用jest进行单元测试\",\"date\":\"2017-08-18\",\"category\":[\"前端工具\"],\"tags\":[\"unit test\",\"vue\",\"javascript\"],\"path\":\"/post/vue-jest-test\"},\"next\":{\"title\":\"深入学习javascript - this\",\"date\":\"2017-06-27\",\"category\":null,\"tags\":null,\"path\":\"/post/js-this\"}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---post-js-class-88305b1d2ee25bb9790f.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>类理论</h1>\\n<p>类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。</p>\\n<p>类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。<strong>汽车</strong>可以被看作<strong>交通工具中的一种</strong>，所以在软件开发时可以定义一个<code>Vehicle</code>类，<code>Vehicle</code>中包含推进器（引擎）、载人能力等方法。定义<code>Car</code>时，只要声明它继承或者拓展<code>Vehicle</code>这个基础定义就行了，其他交通工具如船、飞机也可以继承<code>Vehicle</code>。<strong>这就是类的实例化与继承</strong>。</p>\\n<p>类的另外一个核心概念是<strong>多态</strong>，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。</p>\\n<p>javascript中也有类中的<code>new</code>和<code>instanceof</code>，还有ES6中的<code>class</code>关键字，但这些并不是说明js中有<strong>类</strong>的。javascript中只是为了满足类的设计需求而提供一些类似的语法。</p>\\n<h2>js中实现类复制(混入)</h2>\\n<p>javascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。</p>\\n<!-- more -->\\n<h3>显式混入</h3>\\n<p>显示混入在其他库或者框架中一般被称为<code>extend</code>，在这方便理解会使用<code>mixin</code>。</p>\\n<pre><code class=\\\"language-javascript\\\">// 前面的Vehicle和car的例子\\nfunction mixin(sourceObj, targetObj) {\\n  for(var i in sourceObj) {\\n    if(!(i in targetObj)) {\\n      targetObj[i] = sourceObj[i];\\n    }\\n  }\\n\\n  return targetObj;\\n}\\n\\nvar Vehicle = {\\n  engines: 1,\\n  ignition: function() {\\n    console.log('Turning on my engines.');\\n  },\\n  drive: function() {\\n    this.ignition();\\n    console.log('Steering and moving forward.');\\n  }\\n}\\n\\nvar Car = mixin(Vehicle, {\\n  wheels: 4,\\n  drive: function() {\\n    Vehicle.drive.call(this);\\n    console.log('Rolling on all' + this.wheels + 'wheels!');\\n  }\\n})\\n</code></pre>\\n<p>还有一种显示混入的变体叫<strong>寄生继承</strong></p>\\n<pre><code class=\\\"language-javascript\\\">function Vehicle() {\\n  this.engines = 1;\\n}\\nVehicle.prototype.ignition = function() {\\n  console.log('Turning on my engines.');\\n}\\nVehicle.prototype.drive = function() {\\n  this.ignition();\\n  console.log('Steering and moving forward.');\\n}\\n\\n// 寄生类 car\\nfunction Car() {\\n  var car  = new Vehicle();\\n\\n  car.wheels = 4;\\n  var vehDrive = car.drive;\\n\\n  car.drive = function() {\\n    Vehicle.call(this);\\n    console.log('Rolling on all' + this.wheels + 'wheels!');\\n  }\\n\\n  return car;\\n}\\n\\nvar myCar = new Car();\\nmyCar.drive();\\n</code></pre>\\n<h3>隐式混入</h3>\\n<p>隐式混入就是改变在一个函数体内执行另外另一个函数的方法。</p>\\n<pre><code class=\\\"language-javascript\\\">var foo = {\\n  cool: function() {\\n    this.count = this.count ? this.count++ : 1;\\n    console.log(this.count);\\n  }\\n}\\n\\nfoo.cool(); // 1\\n\\nvar bar = {\\n  cool: function() {\\n    foo.cool.call(this);\\n  }\\n}\\n\\nbar.cool(); // 1, 数据不共享\\n</code></pre>\\n<h1>prototype-原型</h1>\\n<p>JS中，当试图引用对象属性时候就会触发<code>[[GET]]</code>操作，如果在对象属性中没有找到，就会使用对象的<code>[[prototype]]</code>链。JS大部分复杂类型都是<code>object</code>，所以<code>[[prototype]]</code>“尽头”应该是<code>Object.prototype</code>，里面包含了许多原生方法，如<code>toString</code>或<code>valueOf</code>。</p>\\n<h2>如何工作</h2>\\n<p>JS和其他OO语言并不同，JS中并没有类作为对象的抽象模式，JS中只有对象，所以当new一个对象时候，并不是复制一个类函数，而是将目标对象的<code>prototype</code>关联到新对象的<code>prototype</code>中。</p>\\n<h1>小结</h1>\\n<p><code>prototype</code>部分书本总结得比较清楚，想知道更多细节的同学可以参考<strong>you dont know javascript</strong>的5.1-5.4章节。</p>\\n<ul>\\n<li>访问对象时候都会触发对象的[[GET]]操作，如果没有找到属性的话会继续找[[Prototype]]链。</li>\\n<li>普通对象的原型链顶端都是<code>Object.prototype</code></li>\\n<li><code>new</code>调用函数时只会关系到对象，而不会复制</li>\\n</ul>\",\"frontmatter\":{\"date\":\"July 20, 2017\",\"path\":\"/post/js-class\",\"title\":\"深入学习javascript-类\"},\"headings\":[{\"depth\":1,\"value\":\"类理论\"},{\"depth\":2,\"value\":\"js中实现类复制(混入)\"},{\"depth\":3,\"value\":\"显式混入\"},{\"depth\":3,\"value\":\"隐式混入\"},{\"depth\":1,\"value\":\"prototype-原型\"},{\"depth\":2,\"value\":\"如何工作\"},{\"depth\":1,\"value\":\"小结\"}]}},\"pathContext\":{\"prev\":{\"title\":\"在vue项目中使用jest进行单元测试\",\"date\":\"2017-08-18\",\"category\":[\"前端工具\"],\"tags\":[\"unit test\",\"vue\",\"javascript\"],\"path\":\"/post/vue-jest-test\"},\"next\":{\"title\":\"深入学习javascript - this\",\"date\":\"2017-06-27\",\"category\":null,\"tags\":null,\"path\":\"/post/js-this\"}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/post-js-class.json\n// module id = 289\n// module chunks = 139993780387781"],"sourceRoot":""}