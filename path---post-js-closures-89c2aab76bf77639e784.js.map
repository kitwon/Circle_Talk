{"version":3,"sources":["webpack:///path---post-js-closures-89c2aab76bf77639e784.js","webpack:///./.cache/json/post-js-closures.json"],"names":["webpackJsonp","290","module","exports","data","markdownRemark","html","frontmatter","date","path","title","headings","depth","value","pathContext","prev","category","tags","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,gmJAAs8IC,aAAgLC,KAAA,gBAAAC,KAAA,oBAAAC,MAAA,qBAA8EC,WAAcC,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,YAA8BD,MAAA,EAAAC,MAAA,SAA0BC,aAAgBC,MAAQL,MAAA,iBAAAF,KAAA,aAAAQ,UAAA,QAAAC,MAAA,WAAAR,KAAA,kBAA4GS,MAASR,MAAA,iBAAAF,KAAA,aAAAQ,SAAA,KAAAC,KAAA,KAAAR,KAAA","file":"path---post-js-closures-89c2aab76bf77639e784.js","sourcesContent":["webpackJsonp([180222829725422],{\n\n/***/ 290:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>什么是闭包</h1>\\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\\n<blockquote>\\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）</p>\\n</blockquote>\\n<p>然后看个例子</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    funtion bar() {\\n        console.log(a);\\n    }\\n\\n    bar();\\n}\\n\\nfoo();\\n</code></pre>\\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\\n<pre><code class=\\\"language-javascript\\\">fucntion foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a)\\n    }\\n\\n    return bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n</code></pre>\\n<!-- more -->\\n<p>在这例子中，<code>bar</code>也是在<code>foo</code>的作用域内，但是不是直接执行，而是作为返回值返回。\\n<code>foo()</code>执行后，返回值<code>bar</code>赋值给<code>baz</code>并执行<code>baz()</code>，在这里，<code>bar()</code>显然可以正常执行，它在自己定义的词法作用域<strong>以外</strong>的地方。</p>\\n<p>在<code>foo()</code>执行之后，按js的垃圾回收机制，应该会对其进行回收，而闭包的神奇之处就是可以阻止这事情发生，因此<code>baz()</code>在执行的时候依然可以访问<code>a</code>。在此一看，原来平时写的大多数代码都是闭包啊。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a);\\n    }\\n\\n    baz(bar);\\n}\\n\\nfunction baz(fn) {\\n    fn &#x26;&#x26; fn(); // 这里也是闭包\\n}\\n</code></pre>\\n<h1>闭包与变量</h1>\\n<p>要说明闭包，for循环也是一个很好的例子</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 1; i &#x3C;= 10; i++) {\\n    setTimeout(function timer() {\\n        console.log(i)\\n    }, i * 1000)\\n}\\n</code></pre>\\n<p>正常情况下，我们会预期的认为这段会每秒输出1～10，但实际，这段代码会<strong>每秒输出10次11</strong>。</p>\\n<p>首先<strong>11</strong>是那里来的，这个循环应该是在<code>i=11</code>的时候符合终止条件，所以代码输出的是循环结束时<strong>i</strong>的最终值。</p>\\n<p>细想一下，答案其实显而易见，<strong>setTimeout</strong>会推到栈底部执行，所以会在循环结束后才开始执行，所以每次都是输出<strong>11</strong>。但是什么问题造成这样的结果呢。</p>\\n<p>虽然<strong>setTimeout</strong>都是在每个迭代时候分别定义的，但是根据作用域原理，其实几个函数都是都是<strong>保存在一个封闭的作用域中</strong>，因此它们引用都是同一个<strong>来自全局的i</strong>。</p>\\n<p>所以解决方法也很简单，我们需要每次循环都新建一个作用域，然后把迭代的值传入作用域中，所以我们可以用<strong>IIFE</strong>（上一篇作用域有介绍，IIFE是一个匿名函数，每次调用都会创建作用域）来解决</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 1; i &#x3C;= 10; i++) {\\n    (function(j) {\\n        setTimeout(function timer() {\\n            console.log(j)\\n        }, j * 1000)\\n    })(i)\\n}\\n\\n// 换成ES6中的let也可以\\nfor(let i = 1; i &#x3C;= 10; i++) {\\n    setTimeout(function timer() {\\n        console.log(i)\\n    }, i * 1000)\\n}\\n</code></pre>\\n<h1>模块</h1>\\n<p>闭包除了平时实现的回调功能外，还可以实现另外一个强大的功能，<strong>模块</strong>。\\n旧的模块实现方式，如jQuery就可以使用闭包实现</p>\\n<pre><code class=\\\"language-javascript\\\">var $ = jQuery = (function Module(id) {\\n    var a = 2;\\n\\n    function doSomething() {\\n        console.log(a);\\n    }\\n\\n    function identify1() {\\n        console.log(id);\\n    }\\n\\n    function identify2() {\\n        console.log(id.toUpperCase());\\n    }\\n\\n    function change() {\\n        public.identify = identify2;\\n    }\\n\\n    var public = {\\n        doSomething: doSomething,\\n        identify: identify1,\\n        change: change\\n    }\\n\\n    return public;\\n})('hello')\\n\\n$.doSomething() // 2\\n$.identify() // hello\\n$.change()\\n$.identify() // HELLO\\n</code></pre>\\n<p>如果不用单例的话不用<strong>IIFE</strong>即可，通过在模块内保留对公共API的引用，可以从<strong>内部</strong>对模块实例进行修改，包括添加，删除，修改属性或者方法。</p>\\n<h2>现代的模块机制</h2>\\n<p>现在大部分的模块加载器本质上都是将这种模块定义封装进API中，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var Module = (function Manager() {\\n    var modules = {};\\n\\n    function define(name, deps, impl) {\\n        for(var i = 0; i &#x3C; deps.length; i++) {\\n            // 在modules中寻找名字为deps[i]的模块\\n            deps[i] = modules[deps[i]];\\n        }\\n        // 将依赖的模块作为arguments传入module中\\n        modules[name] = impl.apply(impl, deps);\\n    }\\n\\n    function require(name) {\\n        return modules[name];\\n    }\\n\\n    return {\\n        define: define,\\n        require: require\\n    }\\n})()\\n</code></pre>\\n<p>这段代码核心在<code>module[name] = impl.apply(impl, deps)</code>中，模块都按名字保存在<code>modules</code>变量中，每次都能根据获取相关模块。下面看看使用方式。</p>\\n<pre><code class=\\\"language-javascript\\\">Module.define('foo', [], function() {\\n    function hello(who) {\\n        return 'Hello ' + who;\\n    }\\n\\n    return {\\n        hello: hello\\n    }\\n})\\n\\nModule.define('bar', ['foo'], function(foo) {\\n    function awsome() {\\n        return foo.hello('kit').toUpperCase();\\n    }\\n\\n    return {\\n        awsome: awsome\\n    }\\n})\\n\\nvar foo = Module.require('foo'),\\n    bar = Module.require('bar');\\n\\nfoo.hello('kit'); // Hello kit\\nbar.awsome() // HELLO KIT\\n</code></pre>\\n<h1>总结</h1>\\n<p>从上面可以知道，平时写的js大部分代码都使用了闭包，通过了解闭包和作用域的运行方式，能够减少平时使用的出现的错误。也能通过闭包，使用js实现模块化等其他更多的功能。</p>\",\"frontmatter\":{\"date\":\"June 14, 2017\",\"path\":\"/post/js-closures\",\"title\":\"深入学习javascript-闭包\"},\"headings\":[{\"depth\":1,\"value\":\"什么是闭包\"},{\"depth\":1,\"value\":\"闭包与变量\"},{\"depth\":1,\"value\":\"模块\"},{\"depth\":2,\"value\":\"现代的模块机制\"},{\"depth\":1,\"value\":\"总结\"}]}},\"pathContext\":{\"prev\":{\"title\":\"webpack2新特性&迁移\",\"date\":\"2017-06-24\",\"category\":[\"前端工具\"],\"tags\":[\"webpack\"],\"path\":\"/post/webpack2\"},\"next\":{\"title\":\"用python写一个简单爬虫\",\"date\":\"2017-06-11\",\"category\":null,\"tags\":null,\"path\":\"/post/python-crawler\"}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---post-js-closures-89c2aab76bf77639e784.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>什么是闭包</h1>\\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\\n<blockquote>\\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）</p>\\n</blockquote>\\n<p>然后看个例子</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    funtion bar() {\\n        console.log(a);\\n    }\\n\\n    bar();\\n}\\n\\nfoo();\\n</code></pre>\\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\\n<pre><code class=\\\"language-javascript\\\">fucntion foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a)\\n    }\\n\\n    return bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n</code></pre>\\n<!-- more -->\\n<p>在这例子中，<code>bar</code>也是在<code>foo</code>的作用域内，但是不是直接执行，而是作为返回值返回。\\n<code>foo()</code>执行后，返回值<code>bar</code>赋值给<code>baz</code>并执行<code>baz()</code>，在这里，<code>bar()</code>显然可以正常执行，它在自己定义的词法作用域<strong>以外</strong>的地方。</p>\\n<p>在<code>foo()</code>执行之后，按js的垃圾回收机制，应该会对其进行回收，而闭包的神奇之处就是可以阻止这事情发生，因此<code>baz()</code>在执行的时候依然可以访问<code>a</code>。在此一看，原来平时写的大多数代码都是闭包啊。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a);\\n    }\\n\\n    baz(bar);\\n}\\n\\nfunction baz(fn) {\\n    fn &#x26;&#x26; fn(); // 这里也是闭包\\n}\\n</code></pre>\\n<h1>闭包与变量</h1>\\n<p>要说明闭包，for循环也是一个很好的例子</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 1; i &#x3C;= 10; i++) {\\n    setTimeout(function timer() {\\n        console.log(i)\\n    }, i * 1000)\\n}\\n</code></pre>\\n<p>正常情况下，我们会预期的认为这段会每秒输出1～10，但实际，这段代码会<strong>每秒输出10次11</strong>。</p>\\n<p>首先<strong>11</strong>是那里来的，这个循环应该是在<code>i=11</code>的时候符合终止条件，所以代码输出的是循环结束时<strong>i</strong>的最终值。</p>\\n<p>细想一下，答案其实显而易见，<strong>setTimeout</strong>会推到栈底部执行，所以会在循环结束后才开始执行，所以每次都是输出<strong>11</strong>。但是什么问题造成这样的结果呢。</p>\\n<p>虽然<strong>setTimeout</strong>都是在每个迭代时候分别定义的，但是根据作用域原理，其实几个函数都是都是<strong>保存在一个封闭的作用域中</strong>，因此它们引用都是同一个<strong>来自全局的i</strong>。</p>\\n<p>所以解决方法也很简单，我们需要每次循环都新建一个作用域，然后把迭代的值传入作用域中，所以我们可以用<strong>IIFE</strong>（上一篇作用域有介绍，IIFE是一个匿名函数，每次调用都会创建作用域）来解决</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 1; i &#x3C;= 10; i++) {\\n    (function(j) {\\n        setTimeout(function timer() {\\n            console.log(j)\\n        }, j * 1000)\\n    })(i)\\n}\\n\\n// 换成ES6中的let也可以\\nfor(let i = 1; i &#x3C;= 10; i++) {\\n    setTimeout(function timer() {\\n        console.log(i)\\n    }, i * 1000)\\n}\\n</code></pre>\\n<h1>模块</h1>\\n<p>闭包除了平时实现的回调功能外，还可以实现另外一个强大的功能，<strong>模块</strong>。\\n旧的模块实现方式，如jQuery就可以使用闭包实现</p>\\n<pre><code class=\\\"language-javascript\\\">var $ = jQuery = (function Module(id) {\\n    var a = 2;\\n\\n    function doSomething() {\\n        console.log(a);\\n    }\\n\\n    function identify1() {\\n        console.log(id);\\n    }\\n\\n    function identify2() {\\n        console.log(id.toUpperCase());\\n    }\\n\\n    function change() {\\n        public.identify = identify2;\\n    }\\n\\n    var public = {\\n        doSomething: doSomething,\\n        identify: identify1,\\n        change: change\\n    }\\n\\n    return public;\\n})('hello')\\n\\n$.doSomething() // 2\\n$.identify() // hello\\n$.change()\\n$.identify() // HELLO\\n</code></pre>\\n<p>如果不用单例的话不用<strong>IIFE</strong>即可，通过在模块内保留对公共API的引用，可以从<strong>内部</strong>对模块实例进行修改，包括添加，删除，修改属性或者方法。</p>\\n<h2>现代的模块机制</h2>\\n<p>现在大部分的模块加载器本质上都是将这种模块定义封装进API中，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var Module = (function Manager() {\\n    var modules = {};\\n\\n    function define(name, deps, impl) {\\n        for(var i = 0; i &#x3C; deps.length; i++) {\\n            // 在modules中寻找名字为deps[i]的模块\\n            deps[i] = modules[deps[i]];\\n        }\\n        // 将依赖的模块作为arguments传入module中\\n        modules[name] = impl.apply(impl, deps);\\n    }\\n\\n    function require(name) {\\n        return modules[name];\\n    }\\n\\n    return {\\n        define: define,\\n        require: require\\n    }\\n})()\\n</code></pre>\\n<p>这段代码核心在<code>module[name] = impl.apply(impl, deps)</code>中，模块都按名字保存在<code>modules</code>变量中，每次都能根据获取相关模块。下面看看使用方式。</p>\\n<pre><code class=\\\"language-javascript\\\">Module.define('foo', [], function() {\\n    function hello(who) {\\n        return 'Hello ' + who;\\n    }\\n\\n    return {\\n        hello: hello\\n    }\\n})\\n\\nModule.define('bar', ['foo'], function(foo) {\\n    function awsome() {\\n        return foo.hello('kit').toUpperCase();\\n    }\\n\\n    return {\\n        awsome: awsome\\n    }\\n})\\n\\nvar foo = Module.require('foo'),\\n    bar = Module.require('bar');\\n\\nfoo.hello('kit'); // Hello kit\\nbar.awsome() // HELLO KIT\\n</code></pre>\\n<h1>总结</h1>\\n<p>从上面可以知道，平时写的js大部分代码都使用了闭包，通过了解闭包和作用域的运行方式，能够减少平时使用的出现的错误。也能通过闭包，使用js实现模块化等其他更多的功能。</p>\",\"frontmatter\":{\"date\":\"June 14, 2017\",\"path\":\"/post/js-closures\",\"title\":\"深入学习javascript-闭包\"},\"headings\":[{\"depth\":1,\"value\":\"什么是闭包\"},{\"depth\":1,\"value\":\"闭包与变量\"},{\"depth\":1,\"value\":\"模块\"},{\"depth\":2,\"value\":\"现代的模块机制\"},{\"depth\":1,\"value\":\"总结\"}]}},\"pathContext\":{\"prev\":{\"title\":\"webpack2新特性&迁移\",\"date\":\"2017-06-24\",\"category\":[\"前端工具\"],\"tags\":[\"webpack\"],\"path\":\"/post/webpack2\"},\"next\":{\"title\":\"用python写一个简单爬虫\",\"date\":\"2017-06-11\",\"category\":null,\"tags\":null,\"path\":\"/post/python-crawler\"}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/post-js-closures.json\n// module id = 290\n// module chunks = 180222829725422"],"sourceRoot":""}