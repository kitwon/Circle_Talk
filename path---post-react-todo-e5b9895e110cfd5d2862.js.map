{"version":3,"sources":["webpack:///path---post-react-todo-e5b9895e110cfd5d2862.js","webpack:///./.cache/json/post-react-todo.json"],"names":["webpackJsonp","302","module","exports","data","markdownRemark","html","frontmatter","date","path","title","headings","depth","value","pathContext","prev","category","tags","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,2pUAAy2TC,aAA4XC,KAAA,iBAAAC,KAAA,mBAAAC,MAAA,mBAA4EC,WAAcC,MAAA,EAAAC,MAAA,QAA0BD,MAAA,EAAAC,MAAA,aAA+BD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,QAA0BD,MAAA,EAAAC,MAAA,kBAAoCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,SAA0BC,aAAgBC,MAAQL,MAAA,mBAAAF,KAAA,aAAAQ,UAAA,MAAAC,MAAA,iBAAAR,KAAA,0BAA0HS,MAAA","file":"path---post-react-todo-e5b9895e110cfd5d2862.js","sourcesContent":["webpackJsonp([187574574908053],{\n\n/***/ 302:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。</p>\\n<h3>小科普</h3>\\n<p>什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！</p>\\n<!-- more -->\\n<h3>Demo功能需求</h3>\\n<ul>\\n<li>input输入内容，回车键或按钮增加一条todo</li>\\n<li>checkbox添加完成状态</li>\\n<li>移动到列表时显示删除</li>\\n<li>显示todo总数和已经完成数</li>\\n<li>list全选</li>\\n<li>清除已完成</li>\\n<li>添加动画效果</li>\\n</ul>\\n<h3>开始</h3>\\n<p>开始需要npm安装一下等下要用的packages，如果是checkout我的demo，就动动手指头，install一下，我的demo地址是<a href=\\\"https://github.com/kitwon/react-todo\\\">https://github.com/kitwon/react-todo</a></p>\\n<pre><code class=\\\"language-bash\\\">$npm install\\n</code></pre>\\n<h4>配置webpack</h4>\\n<p>所有东西安装完成之后首先就是配置<a href=\\\"http://webpack.github.io/docs/\\\">webpack</a></p>\\n<pre><code class=\\\"language-javascript\\\">var path = require('path');\\n\\nmodule.exports = {\\n    entry : \\\"./src/entry.js\\\",\\n    output : {\\n        path : path.join(__dirname, \\\"out\\\"),\\n        publicPath : \\\"./out/\\\",\\n        filename : \\\"bundle.js\\\"\\n    },\\n    externals : {\\n        react : \\\"React\\\"\\n    },\\n    module : {\\n        loaders : [\\n            { test : /\\\\.js$/, loader : \\\"jsx\\\",include: /src/ },\\n            { test : /\\\\.css$/, loader : \\\"style!css\\\" },\\n            { test : /\\\\.less$/, loader : \\\"style!css!less\\\" },\\n            { test : /\\\\.(jpg|png)$/, loader : \\\"url?limit=8192\\\" }\\n        ]\\n    }\\n}\\n</code></pre>\\n<p>从上面可以看到，webpack的入口文件是entry.js，打包输出的文件是bundle.js，external属性是告诉webpack，当API已经存在的时候，使用全局变量，并不作任何操作。</p>\\n<p>loader的话没啥，看文档就知道，各种编译打包。具体使用方法可以看官方文档。</p>\\n<h4>上代码</h4>\\n<pre><code class=\\\"language-javascript\\\">var React = require('React'),\\n    ReactDOM = require('react-dom');\\n\\nrequire('../less/app.less');\\n\\nvar AppFooter = require('./AppFooter'),\\n    AppHeader = require('./AppHeader'),\\n    ItemMain = require('./ItemMain');\\n\\n\\nvar App = React.createClass ({\\n    getInitialState : function() {\\n        return {\\n            todoItem : [],\\n            isAllChecked : false\\n        }\\n    },\\n    //添加todo\\n    addItem : function(item) {\\n        var todoList = this.state.todoItem.push(item);\\n        this.setState({isAllChecked : false});\\n        this.forceUpdate();\\n    },\\n     //更改todo状态\\n    changeTodoState : function(index, isDone, isAllChange) {\\n        // isAllChange = false;\\n        if(isAllChange) {\\n            this.setState({\\n                todoItem: this.state.todoItem.map(function(todo) {\\n                    todo.isDone = isDone;\\n                    return todo;\\n                }),\\n                isAllChecked : isDone\\n            })\\n        }else {\\n            this.state.todoItem[index].isDone = isDone;\\n            this.allChecked();\\n            this.forceUpdate();\\n        }\\n    },\\n    //删除todo\\n    deleteTodo : function(index) {\\n        var newTodo = this.state.todoItem.splice(index, 1);\\n        this.setState({todoList: newTodo});\\n    },\\n    //清楚已完成\\n    clearDone : function() {\\n        var doneList = this.state.todoItem.filter(function(item) {\\n            return item.isDone === false;\\n        })\\n        this.setState({todoItem: doneList, isAllChecked: false});\\n    },\\n    //全部完成\\n    allChecked : function() {\\n        var allCheck = this.state.todoItem.every(function(item) {\\n            return item.isDone === true;\\n        })\\n        if (allCheck) {\\n            this.setState({isAllChecked : true})\\n        };\\n    },\\n        render : function(){\\n            var props = {\\n                todoLength : this.state.todoItem.length || 0,\\n                doneLength : this.state.todoItem.filter(function(item) {\\n                    return item.isDone === true;\\n                }).length || 0\\n            };\\n                return (\\n                    &#x3C;div className=\\\"panel\\\">\\n                        &#x3C;header  className=\\\"mainHeader\\\">&#x3C;h2>Webpack + React TODO Demo&#x3C;/h2>&#x3C;/header>\\n                        &#x3C;AppHeader addItem={this.addItem}/>\\n                        &#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\\n                            &#x3C;AppFooter {...props} isAllChecked={this.state.isAllChecked} clearDone={this.clearDone} changeAllState={this.changeTodoState} />\\n                    &#x3C;/div>\\n                )\\n        }\\n})\\n\\nReactDOM.render(&#x3C;App/>, document.getElementById(\\\"app\\\"));  //渲染\\n</code></pre>\\n<p>从代码上面可以看到各种require，没加载commonjs、seajs或其他模块化工具，为什么能直接require呢，而且还有require less，没错，webpack就是那么暴力！js后面都会打包好一个文件，样式都会加载到html里面，做spa时候，和react简直绝配。</p>\\n<h4>App生命 - state</h4>\\n<p>React主流思想就是父组件控制state，然后通过props传递给子组建，所以简单来说界面就像状态机，只要更新state，然后根据新的state重新渲染界面，不需要操作dom，所以react高性能原因也是因为这个。\\n从最上代码就可以看出父组件中的定义的方法基本是整个todo的功能了，然后render方法即渲染html和组件。</p>\\n<pre><code class=\\\"language-javascript\\\">&#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\\n</code></pre>\\n<p>然后取一小段渲染组件代码（上面代码）就可发现，父组件向ItemMain这个组件传了4个属性，其中itemList为state，只要todoItem一更新，react就会重新渲染这个组件，其他三个为方法，方法更新也会重新渲染组件。</p>\\n<pre><code class=\\\"language-javascript\\\">// ItemMain.js\\nvar React = require('React');\\nvar Items = require('./Items');\\n\\nvar ItemMain = React.createClass({\\n    render : function() {\\n        var _this = this;\\n        return (\\n            &#x3C;section>\\n                &#x3C;ul className=\\\"itemList\\\">\\n                    {_this.props.itemList.map(function (todo, index) {\\n                        return (\\n                            &#x3C;Items {...todo} key={index} index={index} {..._this.props} />\\n                        )\\n                    &#x3C;!-- })} -->\\n                    &#x3C;!--这里不注释代码不高亮，比较奇葩，各位官人将就着看-->\\n                &#x3C;/ul>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = ItemMain;\\n</code></pre>\\n<p>看这里估计有点蒙，我自己看的时候也有点蒙，因为太久的代码了哈哈哈。\\n这个js只有一个循环Item的逻辑，首先看看<code>{...todo}</code>这个prop，这个是把itemList[i]中的<a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\\\">数组对象解构</a>，然后传到item里面，如果没有...这个字符，则需要</p>\\n<pre><code class=\\\"language-javascript\\\">    &#x3C;Items text={props.text} isDone={props.isDone} key={index} index={index} changeTodoState={proprs.changeTodoState} deleteTodo={props.deleteTodo} />\\n</code></pre>\\n<p>具体数据大家可以在代码里面console打印一下，这样印象会更深。</p>\\n<pre><code class=\\\"language-javascript\\\">// item.js\\nvar React = require('React');\\n\\nvar Items = React.createClass({\\n    handleChange : function() {\\n        var isDone = !this.props.isDone;\\n        this.props.changeTodoState(this.props.index, isDone);\\n    },\\n    handleDeleteTodo : function() {\\n        this.props.deleteTodo(this.props.index);\\n    },\\n    render : function() {\\n        var doneStyle = this.props.isDone ? {textDecoration: 'line-through'} : {textDecoration : 'none'};\\n        return (\\n            &#x3C;li key={this.props.key} onMouseOver={this.handlerMouseOver} onMouseOut={this.handlerMouseOut}>\\n                &#x3C;input type=\\\"checkbox\\\" checked={this.props.isDone} onChange={this.handleChange} />\\n                &#x3C;span style={doneStyle}>{this.props.text}&#x3C;/span>\\n                &#x3C;button className=\\\"btn btn-default delete-item\\\" onClick={this.handleDeleteTodo}>delete&#x3C;/button>\\n            &#x3C;/li>\\n        )\\n    }\\n})\\n\\nmodule.exports = Items;\\n</code></pre>\\n<p>这个就是js里面有两个方法，一个是改变状态，一个是删除当前todo，这这能发现，两个方法都是执行了又父组件传过来的方法，如下</p>\\n<pre><code class=\\\"language-javascript\\\">this.props.changeTodoState(this.props.index, isDone);\\n</code></pre>\\n<p>执行这个函数，state就会更新，react就会根据状态重新渲染组件</p>\\n<h4>其他组件</h4>\\n<pre><code class=\\\"language-javascript\\\">// AppHeader.js\\nvar React = require('React');\\n\\nvar AppHeader = React.createClass({\\n    getInitialState : function() {\\n        return {\\n            text : \\\"\\\"\\n        }\\n    },\\n    handlerKeyUp : function(event) {\\n        if(event.keyCode === 13) {\\n            var value = event.target.value;\\n            if(!value) return false;\\n\\n            var newTodoItem = {\\n                text : value,\\n                isDone : false\\n            }\\n\\n            event.target.value = \\\"\\\";\\n            this.setState({text: \\\"\\\"});\\n            this.props.addItem(newTodoItem);\\n        }\\n    },\\n    handleChange : function(event) {\\n        this.setState({text : event.target.value });\\n    },\\n    handlerClick : function(event) {\\n        var newTodoItem = {\\n            text : this.state.text,\\n            isDone : false\\n        }\\n        this.props.addItem(newTodoItem);\\n        this.setState({text: \\\"\\\"});\\n    },\\n    render : function() {\\n        return (\\n            &#x3C;section className=\\\"appHeader from-group\\\">\\n                &#x3C;input type=\\\"test\\\" className=\\\"form-control\\\" onKeyUp={this.handlerKeyUp} onChange={this.handleChange} placeholder=\\\"add one todo\\\" value={this.state.text}/>\\n                &#x3C;button className=\\\"btn btn-primary\\\" onClick={this.handlerClick}>add one&#x3C;/button>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = AppHeader;\\n</code></pre>\\n<pre><code class=\\\"language-javascript\\\">// AppHeader.js\\nvar React = require('React');\\n\\nvar AppFooter = React.createClass({\\n    handleClick : function() {\\n        this.props.clearDone();\\n    },\\n    handleAllState : function(event) {\\n        this.props.changeAllState(null, event.target.value, true);\\n    },\\n    render : function() {\\n        return (\\n            &#x3C;section className=\\\"appFooter\\\">\\n                &#x3C;div>\\n                    &#x3C;input type=\\\"checkbox\\\" checked={this.props.isAllChecked} onChange={this.handleAllState}/>\\n                    &#x3C;span>{this.props.doneLength}&#x3C;/span>已经完成 / &#x3C;span>{this.props.todoLength}&#x3C;/span>总数\\n                &#x3C;/div>\\n                &#x3C;button className=\\\"btn btn-default btn-tiny pull-right\\\" onClick={this.handleClick}>clean done&#x3C;/button>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = AppFooter;\\n</code></pre>\\n<p>Header Footer的方法都是大同小异，输入改变state，然后存起来，执行相应操作时候通过props的方法传给父组件，然后重新渲染界面。</p>\\n<h3>总结</h3>\\n<p>回头看代码，react的组件化相比现在的组件化思想真的先进很多。React通过父组件来控制状态，并通过props传递给子组件。因此我们能很容易看出我们的事件属于哪个组件管理，然后修改相应的方法，维护起来相当高效，相比现在的控制dom，每次修改按钮的方法，都需要先找到id或者class，然后绑定响应的方法，假如页面id或者class改变，页面逻辑又非常复杂的话，修改起来是相当麻烦的。\\nReact凭着出色的设计思想和性能，我相信不久就会成为主流的移动端开发方式，至于PC端，大天朝你懂的。</p>\",\"frontmatter\":{\"date\":\"March 02, 2016\",\"path\":\"/post/react-todo\",\"title\":\"React-todo demo\"},\"headings\":[{\"depth\":3,\"value\":\"小科普\"},{\"depth\":3,\"value\":\"Demo功能需求\"},{\"depth\":3,\"value\":\"开始\"},{\"depth\":4,\"value\":\"配置webpack\"},{\"depth\":4,\"value\":\"上代码\"},{\"depth\":4,\"value\":\"App生命 - state\"},{\"depth\":4,\"value\":\"其他组件\"},{\"depth\":3,\"value\":\"总结\"}]}},\"pathContext\":{\"prev\":{\"title\":\"使用nodejs写一个命令行程序\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":[\"nodejs\",\"bash\"],\"path\":\"/post/node-command-app\"},\"next\":false}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---post-react-todo-e5b9895e110cfd5d2862.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。</p>\\n<h3>小科普</h3>\\n<p>什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！</p>\\n<!-- more -->\\n<h3>Demo功能需求</h3>\\n<ul>\\n<li>input输入内容，回车键或按钮增加一条todo</li>\\n<li>checkbox添加完成状态</li>\\n<li>移动到列表时显示删除</li>\\n<li>显示todo总数和已经完成数</li>\\n<li>list全选</li>\\n<li>清除已完成</li>\\n<li>添加动画效果</li>\\n</ul>\\n<h3>开始</h3>\\n<p>开始需要npm安装一下等下要用的packages，如果是checkout我的demo，就动动手指头，install一下，我的demo地址是<a href=\\\"https://github.com/kitwon/react-todo\\\">https://github.com/kitwon/react-todo</a></p>\\n<pre><code class=\\\"language-bash\\\">$npm install\\n</code></pre>\\n<h4>配置webpack</h4>\\n<p>所有东西安装完成之后首先就是配置<a href=\\\"http://webpack.github.io/docs/\\\">webpack</a></p>\\n<pre><code class=\\\"language-javascript\\\">var path = require('path');\\n\\nmodule.exports = {\\n    entry : \\\"./src/entry.js\\\",\\n    output : {\\n        path : path.join(__dirname, \\\"out\\\"),\\n        publicPath : \\\"./out/\\\",\\n        filename : \\\"bundle.js\\\"\\n    },\\n    externals : {\\n        react : \\\"React\\\"\\n    },\\n    module : {\\n        loaders : [\\n            { test : /\\\\.js$/, loader : \\\"jsx\\\",include: /src/ },\\n            { test : /\\\\.css$/, loader : \\\"style!css\\\" },\\n            { test : /\\\\.less$/, loader : \\\"style!css!less\\\" },\\n            { test : /\\\\.(jpg|png)$/, loader : \\\"url?limit=8192\\\" }\\n        ]\\n    }\\n}\\n</code></pre>\\n<p>从上面可以看到，webpack的入口文件是entry.js，打包输出的文件是bundle.js，external属性是告诉webpack，当API已经存在的时候，使用全局变量，并不作任何操作。</p>\\n<p>loader的话没啥，看文档就知道，各种编译打包。具体使用方法可以看官方文档。</p>\\n<h4>上代码</h4>\\n<pre><code class=\\\"language-javascript\\\">var React = require('React'),\\n    ReactDOM = require('react-dom');\\n\\nrequire('../less/app.less');\\n\\nvar AppFooter = require('./AppFooter'),\\n    AppHeader = require('./AppHeader'),\\n    ItemMain = require('./ItemMain');\\n\\n\\nvar App = React.createClass ({\\n    getInitialState : function() {\\n        return {\\n            todoItem : [],\\n            isAllChecked : false\\n        }\\n    },\\n    //添加todo\\n    addItem : function(item) {\\n        var todoList = this.state.todoItem.push(item);\\n        this.setState({isAllChecked : false});\\n        this.forceUpdate();\\n    },\\n     //更改todo状态\\n    changeTodoState : function(index, isDone, isAllChange) {\\n        // isAllChange = false;\\n        if(isAllChange) {\\n            this.setState({\\n                todoItem: this.state.todoItem.map(function(todo) {\\n                    todo.isDone = isDone;\\n                    return todo;\\n                }),\\n                isAllChecked : isDone\\n            })\\n        }else {\\n            this.state.todoItem[index].isDone = isDone;\\n            this.allChecked();\\n            this.forceUpdate();\\n        }\\n    },\\n    //删除todo\\n    deleteTodo : function(index) {\\n        var newTodo = this.state.todoItem.splice(index, 1);\\n        this.setState({todoList: newTodo});\\n    },\\n    //清楚已完成\\n    clearDone : function() {\\n        var doneList = this.state.todoItem.filter(function(item) {\\n            return item.isDone === false;\\n        })\\n        this.setState({todoItem: doneList, isAllChecked: false});\\n    },\\n    //全部完成\\n    allChecked : function() {\\n        var allCheck = this.state.todoItem.every(function(item) {\\n            return item.isDone === true;\\n        })\\n        if (allCheck) {\\n            this.setState({isAllChecked : true})\\n        };\\n    },\\n        render : function(){\\n            var props = {\\n                todoLength : this.state.todoItem.length || 0,\\n                doneLength : this.state.todoItem.filter(function(item) {\\n                    return item.isDone === true;\\n                }).length || 0\\n            };\\n                return (\\n                    &#x3C;div className=\\\"panel\\\">\\n                        &#x3C;header  className=\\\"mainHeader\\\">&#x3C;h2>Webpack + React TODO Demo&#x3C;/h2>&#x3C;/header>\\n                        &#x3C;AppHeader addItem={this.addItem}/>\\n                        &#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\\n                            &#x3C;AppFooter {...props} isAllChecked={this.state.isAllChecked} clearDone={this.clearDone} changeAllState={this.changeTodoState} />\\n                    &#x3C;/div>\\n                )\\n        }\\n})\\n\\nReactDOM.render(&#x3C;App/>, document.getElementById(\\\"app\\\"));  //渲染\\n</code></pre>\\n<p>从代码上面可以看到各种require，没加载commonjs、seajs或其他模块化工具，为什么能直接require呢，而且还有require less，没错，webpack就是那么暴力！js后面都会打包好一个文件，样式都会加载到html里面，做spa时候，和react简直绝配。</p>\\n<h4>App生命 - state</h4>\\n<p>React主流思想就是父组件控制state，然后通过props传递给子组建，所以简单来说界面就像状态机，只要更新state，然后根据新的state重新渲染界面，不需要操作dom，所以react高性能原因也是因为这个。\\n从最上代码就可以看出父组件中的定义的方法基本是整个todo的功能了，然后render方法即渲染html和组件。</p>\\n<pre><code class=\\\"language-javascript\\\">&#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\\n</code></pre>\\n<p>然后取一小段渲染组件代码（上面代码）就可发现，父组件向ItemMain这个组件传了4个属性，其中itemList为state，只要todoItem一更新，react就会重新渲染这个组件，其他三个为方法，方法更新也会重新渲染组件。</p>\\n<pre><code class=\\\"language-javascript\\\">// ItemMain.js\\nvar React = require('React');\\nvar Items = require('./Items');\\n\\nvar ItemMain = React.createClass({\\n    render : function() {\\n        var _this = this;\\n        return (\\n            &#x3C;section>\\n                &#x3C;ul className=\\\"itemList\\\">\\n                    {_this.props.itemList.map(function (todo, index) {\\n                        return (\\n                            &#x3C;Items {...todo} key={index} index={index} {..._this.props} />\\n                        )\\n                    &#x3C;!-- })} -->\\n                    &#x3C;!--这里不注释代码不高亮，比较奇葩，各位官人将就着看-->\\n                &#x3C;/ul>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = ItemMain;\\n</code></pre>\\n<p>看这里估计有点蒙，我自己看的时候也有点蒙，因为太久的代码了哈哈哈。\\n这个js只有一个循环Item的逻辑，首先看看<code>{...todo}</code>这个prop，这个是把itemList[i]中的<a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\\\">数组对象解构</a>，然后传到item里面，如果没有...这个字符，则需要</p>\\n<pre><code class=\\\"language-javascript\\\">    &#x3C;Items text={props.text} isDone={props.isDone} key={index} index={index} changeTodoState={proprs.changeTodoState} deleteTodo={props.deleteTodo} />\\n</code></pre>\\n<p>具体数据大家可以在代码里面console打印一下，这样印象会更深。</p>\\n<pre><code class=\\\"language-javascript\\\">// item.js\\nvar React = require('React');\\n\\nvar Items = React.createClass({\\n    handleChange : function() {\\n        var isDone = !this.props.isDone;\\n        this.props.changeTodoState(this.props.index, isDone);\\n    },\\n    handleDeleteTodo : function() {\\n        this.props.deleteTodo(this.props.index);\\n    },\\n    render : function() {\\n        var doneStyle = this.props.isDone ? {textDecoration: 'line-through'} : {textDecoration : 'none'};\\n        return (\\n            &#x3C;li key={this.props.key} onMouseOver={this.handlerMouseOver} onMouseOut={this.handlerMouseOut}>\\n                &#x3C;input type=\\\"checkbox\\\" checked={this.props.isDone} onChange={this.handleChange} />\\n                &#x3C;span style={doneStyle}>{this.props.text}&#x3C;/span>\\n                &#x3C;button className=\\\"btn btn-default delete-item\\\" onClick={this.handleDeleteTodo}>delete&#x3C;/button>\\n            &#x3C;/li>\\n        )\\n    }\\n})\\n\\nmodule.exports = Items;\\n</code></pre>\\n<p>这个就是js里面有两个方法，一个是改变状态，一个是删除当前todo，这这能发现，两个方法都是执行了又父组件传过来的方法，如下</p>\\n<pre><code class=\\\"language-javascript\\\">this.props.changeTodoState(this.props.index, isDone);\\n</code></pre>\\n<p>执行这个函数，state就会更新，react就会根据状态重新渲染组件</p>\\n<h4>其他组件</h4>\\n<pre><code class=\\\"language-javascript\\\">// AppHeader.js\\nvar React = require('React');\\n\\nvar AppHeader = React.createClass({\\n    getInitialState : function() {\\n        return {\\n            text : \\\"\\\"\\n        }\\n    },\\n    handlerKeyUp : function(event) {\\n        if(event.keyCode === 13) {\\n            var value = event.target.value;\\n            if(!value) return false;\\n\\n            var newTodoItem = {\\n                text : value,\\n                isDone : false\\n            }\\n\\n            event.target.value = \\\"\\\";\\n            this.setState({text: \\\"\\\"});\\n            this.props.addItem(newTodoItem);\\n        }\\n    },\\n    handleChange : function(event) {\\n        this.setState({text : event.target.value });\\n    },\\n    handlerClick : function(event) {\\n        var newTodoItem = {\\n            text : this.state.text,\\n            isDone : false\\n        }\\n        this.props.addItem(newTodoItem);\\n        this.setState({text: \\\"\\\"});\\n    },\\n    render : function() {\\n        return (\\n            &#x3C;section className=\\\"appHeader from-group\\\">\\n                &#x3C;input type=\\\"test\\\" className=\\\"form-control\\\" onKeyUp={this.handlerKeyUp} onChange={this.handleChange} placeholder=\\\"add one todo\\\" value={this.state.text}/>\\n                &#x3C;button className=\\\"btn btn-primary\\\" onClick={this.handlerClick}>add one&#x3C;/button>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = AppHeader;\\n</code></pre>\\n<pre><code class=\\\"language-javascript\\\">// AppHeader.js\\nvar React = require('React');\\n\\nvar AppFooter = React.createClass({\\n    handleClick : function() {\\n        this.props.clearDone();\\n    },\\n    handleAllState : function(event) {\\n        this.props.changeAllState(null, event.target.value, true);\\n    },\\n    render : function() {\\n        return (\\n            &#x3C;section className=\\\"appFooter\\\">\\n                &#x3C;div>\\n                    &#x3C;input type=\\\"checkbox\\\" checked={this.props.isAllChecked} onChange={this.handleAllState}/>\\n                    &#x3C;span>{this.props.doneLength}&#x3C;/span>已经完成 / &#x3C;span>{this.props.todoLength}&#x3C;/span>总数\\n                &#x3C;/div>\\n                &#x3C;button className=\\\"btn btn-default btn-tiny pull-right\\\" onClick={this.handleClick}>clean done&#x3C;/button>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = AppFooter;\\n</code></pre>\\n<p>Header Footer的方法都是大同小异，输入改变state，然后存起来，执行相应操作时候通过props的方法传给父组件，然后重新渲染界面。</p>\\n<h3>总结</h3>\\n<p>回头看代码，react的组件化相比现在的组件化思想真的先进很多。React通过父组件来控制状态，并通过props传递给子组件。因此我们能很容易看出我们的事件属于哪个组件管理，然后修改相应的方法，维护起来相当高效，相比现在的控制dom，每次修改按钮的方法，都需要先找到id或者class，然后绑定响应的方法，假如页面id或者class改变，页面逻辑又非常复杂的话，修改起来是相当麻烦的。\\nReact凭着出色的设计思想和性能，我相信不久就会成为主流的移动端开发方式，至于PC端，大天朝你懂的。</p>\",\"frontmatter\":{\"date\":\"March 02, 2016\",\"path\":\"/post/react-todo\",\"title\":\"React-todo demo\"},\"headings\":[{\"depth\":3,\"value\":\"小科普\"},{\"depth\":3,\"value\":\"Demo功能需求\"},{\"depth\":3,\"value\":\"开始\"},{\"depth\":4,\"value\":\"配置webpack\"},{\"depth\":4,\"value\":\"上代码\"},{\"depth\":4,\"value\":\"App生命 - state\"},{\"depth\":4,\"value\":\"其他组件\"},{\"depth\":3,\"value\":\"总结\"}]}},\"pathContext\":{\"prev\":{\"title\":\"使用nodejs写一个命令行程序\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":[\"nodejs\",\"bash\"],\"path\":\"/post/node-command-app\"},\"next\":false}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/post-react-todo.json\n// module id = 302\n// module chunks = 187574574908053"],"sourceRoot":""}