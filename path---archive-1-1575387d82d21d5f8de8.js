webpackJsonp([0x99e4a9614cd],{280:function(n,e){n.exports={data:{allMarkdownRemark:{edges:[{node:{excerpt:"\n这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。\n\n# 项目构建\n项目创建是使用vue-cli创建的，模版则是使用我自己维护的[vue-mpa](https://github.com/kitwon/vue-mpa)多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。\n\n",frontmatter:{title:"年底项目复盘",date:"2018-01-23",category:["工作"],path:"/post/2017-review"}}},{node:{excerpt:"\n> 这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。\n\n----\n\n> 现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的[render performance](https://developers.google.com/web/fundamentals/performance/rendering/)对前端渲染优化有了一个新的认识。\n\n# 几个重要概念\n## 60fps与设备刷新率\n目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。\n\n其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\n\n",frontmatter:{title:"构建60fps-web-app",date:"2017-09-13",category:["前端"],path:"/post/60fps-web-app"}}},{node:{excerpt:"\n在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下[jest](http://facebook.github.io/jest/)，这是一个[Facebook OpenSource](https://code.facebook.com/projects/)的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持**快照测试**(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。\n\n# 配置\n首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析'.vue'文件的)。\n```shell\n$npm install jest jest-vue-preprocessor --save-dev\n\n$yarn add jest jest-vue-preprocessor --save\n```\n\n",frontmatter:{title:"在vue项目中使用jest进行单元测试",date:"2017-08-18",category:["前端工具"],path:"/post/vue-jest-test"}}},{node:{excerpt:"\n# 类理论\n类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。\n\n类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。**汽车**可以被看作**交通工具中的一种**，所以在软件开发时可以定义一个`Vehicle`类，`Vehicle`中包含推进器（引擎）、载人能力等方法。定义`Car`时，只要声明它继承或者拓展`Vehicle`这个基础定义就行了，其他交通工具如船、飞机也可以继承`Vehicle`。**这就是类的实例化与继承**。\n\n类的另外一个核心概念是**多态**，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。\n\njavascript中也有类中的`new`和`instanceof`，还有ES6中的`class`关键字，但这些并不是说明js中有**类**的。javascript中只是为了满足类的设计需求而提供一些类似的语法。\n\n## js中实现类复制(混入)\njavascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。\n\n",frontmatter:{title:"深入学习javascript-类",date:"2017-07-20",category:null,path:"/post/js-class"}}},{node:{excerpt:"\n# 关于this\n\n`this`应该是javascript中一个比较复杂的机制了，在日常工作中我们可能有意无意都会使用到这个机制，但是`this`的工作机制真正了解的可能只有皮毛，通过学习这一机制，能够提高对js代码的理解和阅读能力，还有对js程序设计模式有着更深的理解。\n\n# this的指向\nthis是运行时进行绑定的，而不是编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n\n通过分析调用位置，就能知道this到底引用的是什么。所以，寻找调用位置就能弄清上面的问题，通过一个例子，就能很好地理解这个问题：\n```javascript\nfunction baz() {\n  // 当前调用栈是 baz\n  // 当前调用位置是全局作用域\n\n  console.log('baz');\n  bar(); // bar的调用位置\n}\n\nfunction bar() {\n  // 当前的调用栈是 baz -> bar\n  // 当前的调用位置是baz\n\n  console.log('bar');\n  foo();\n}\n\nfunction foo() {\n  // 当前的调用栈是 baz -> bar -> foo\n  // 当前的调用位置是bar\n\n  console.log('foo');\n}\n\nbaz();\n```\n\n",frontmatter:{title:"深入学习javascript - this",date:"2017-06-27",category:null,path:"/post/js-this"}}},{node:{excerpt:"\nwebpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。\n\n# 从webpack1中迁移\n官方已经给出了详细的[迁移指南](https://webpack.js.org/guides/migrating/)，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。\n\n## 配置文件\n如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。\n\n### `module.loaders`变成`module.rules`\n旧的`module.loader`被`module.rules`取代，后者允许配置`loader`更多选项，具体查看文档[module.rules](https://webpack.js.org/configuration/module/#module-rules)\n\n```javascript\n// ...\nmdoule: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [\n                { loader: 'style-loader' },\n                {\n                    loader: 'css-loader',\n                    options: { module: true }\n                }\n            ]\n        },\n        {\n            test: /\\.jsx$/,\n            loader: 'babel-loader',\n            options: {\n                // ...\n            }\n        }\n    ]\n}\n// ...\n```\n\n",frontmatter:{title:"webpack2新特性&迁移",date:"2017-06-24",category:["前端工具"],path:"/post/webpack2"}}},{node:{excerpt:"\n# 什么是闭包\n记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。\n\n> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\n--- 你不知道的javascript（上卷）\n\n然后看个例子\n```javascript\nfunction foo() {\n\tvar a = 2;\n\n\tfuntion bar() {\n\t\tconsole.log(a);\n\t}\n\n\tbar();\n}\n\nfoo();\n```\n如果按上面第一条的定义，这里一定是生成了闭包，但是**确切的说并不是**，这里最准确的说是`bar`对`a`的引用方式是词法作用域的查找规则，而这些只是**闭包**的一部分。然后再看清晰闭包的例子\n\n```javascript\nfucntion foo() {\n\tvar a = 2;\n\n\tfunction bar() {\n\t\tconsole.log(a)\n\t}\n\n\treturn bar;\n}\n\nvar baz = foo()；\n\nbaz(); // 这就是闭包效果\n```\n\n",frontmatter:{title:"深入学习javascript-闭包",date:"2017-06-14",category:null,path:"/post/js-closures"}}},{node:{excerpt:"\n之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。\n\n# 主要需求\n这个demo中爬虫有3个主要模块，**URL管理器**、**下载器**、**解析器**\n* URL管理器主要处理爬取的URL的状态。\n* 下载器会通过**URL管理器**传送过来有效URL进行下载。\n* 解析器会将**下载器**下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给**URL管理器**进行重复操作。\n\n## 入口程序\n`spider_main`文件为程序入口，处理整个爬虫的运行逻辑\n\n",frontmatter:{title:"用python写一个简单爬虫",date:"2017-06-11",category:null,path:"/post/python-crawler"}}},{node:{excerpt:"\n# 前言\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\n\n# 作用域是什么\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\n\n\n\n## 理解作用域执行过程\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\n\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\n\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\n\n",frontmatter:{title:"深入学习javascript--作用域",date:"2017-05-31",category:null,path:"/post/js-scope"}}},{node:{excerpt:"\n# 题目\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现\n```javascript\nfunction add(x) {\n\tvar fn = function(y) {\n\t\treturn add(x + y);\n\t}\n\n\treturn fn;\n}\n\nconsole.log(add(1)(2)(3))\n```\n\n",frontmatter:{title:"js实现add(1)(2)(3)",date:"2017-05-28",category:["javascript"],path:"/post/add-chain"}}},{node:{excerpt:"\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\n\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\n\n\n\n# 初步构建一个Promise\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\n```javascript\n// 例1\nfunction getAsyncData() {\n\treturn new Promise(function(resolve, reject) {\n\t\tsetTimeout(function() {\n\t\t\tresolve('promise done!')\n\t\t}, 1000)\n\t})\n}\n\ngetAsyncData().then(function(result) {\n\tconsole.log(result);\n}).then(function() {\n\tconsole.log('done too!');\n})\n```\n\n",frontmatter:{title:"Promise的简单实现",date:"2017-05-17",category:["前端"],path:"/post/js-promise"}}},{node:{excerpt:"\n# 什么是单元-测试?\n- 单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。\n- 而测试，就是测试啦。\n\n所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。\n\n# 为什么要写单元测试？\n单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。\n\n",frontmatter:{title:"前端单元测试&Mocha指北",date:"2017-05-16",category:["前端"],path:"/post/unit-test"}}},{node:{excerpt:'\n> 原文译自[Smashing Magazine](https://www.smashingmagazine.com/) -- [[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)\n\n相信很多前端都听说过或者使用过[Gulp](http://www.gulpjs.com.cn/), [Angular CLI](https://cli.angular.io/), [Cordova](https://cordova.apache.org/), [Yeoman](http://yeoman.io/)或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用`ng new <project-name>`后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。\n\n在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用[SendGrid Api](https://github.com/sendgrid/sendgrid-nodejs)模拟发送）\n文章目录：\n1."Hello World"\n2.处理命令行参数\n3.运行时输入参数\n4.模拟发送邮件\n5.改变输出内容样式\n6.变成shell命令\n\n',frontmatter:{title:"使用nodejs写一个命令行程序",date:"2017-05-16",category:["前端"],path:"/post/node-command-app"}}},{node:{excerpt:"\n好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。\n\n### 小科普\n什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！\n\n",frontmatter:{title:"React-todo demo",date:"2016-03-02",category:["js framework"],path:"/post/react-todo"}}}]}},pathContext:{nodes:[{node:{frontmatter:{title:"年底项目复盘",date:"2018-01-23",category:["工作"],tags:["work","vue","webpack"],path:"/post/2017-review"},excerpt:"\n这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。\n\n# 项目构建\n项目创建是使用vue-cli创建的，模版则是使用我自己维护的[vue-mpa](https://github.com/kitwon/vue-mpa)多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。\n\n",headings:[{depth:1,value:"项目构建"},{depth:2,value:"代码分割"},{depth:2,value:"代码风格及限制"},{depth:1,value:"开发阶段"},{depth:2,value:"组件化"},{depth:2,value:"动态接口地址"},{depth:2,value:"测试"},{depth:1,value:"SSR"},{depth:1,value:"总结"}],html:'<p>这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。</p>\n<h1>项目构建</h1>\n<p>项目创建是使用vue-cli创建的，模版则是使用我自己维护的<a href="https://github.com/kitwon/vue-mpa">vue-mpa</a>多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。</p>\n<!-- more -->\n<h2>代码分割</h2>\n<p>SPA一个比较重要的点就是如何做代码分割了。代码分割涉及到几个方面：</p>\n<ol>\n<li><a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html">路由分割</a>官方已经有很好的解决方案了。除文档基本说明外，还使用了<a href="https://doc.webpack-china.org/api/module-methods/#import-"><code>webpackChunkName</code></a>对组件进行模块合并，减少文件请求。</li>\n<li>一些比较大的库例如<code>momentjs</code>、<code>lodash</code>代码提取。虽然<code>webpack</code>里面提供了<code>commonChunkPlugin</code>，但是这个插件只对入口文件进行分析和代码提取，而组件里面的一些库则使用了<a href="https://github.com/asfktz/autodll-webpack-plugin">autodll-webpack-plugin</a>，对一些依赖库进行提取和合并操作，并配合<code>html-webpack-plugin</code>配合自动注入，生成页面模板。</li>\n</ol>\n<p>另外，引入了<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">BundleAnalyzerPlugin</a>，对module进行图形化的分析。进行各种优化后，<code>vendor</code>和入口文件维持在600k左右，gzip后在200k左右，其他模块gzip后基本在<strong>20-50kb</strong>左右。</p>\n<h2>代码风格及限制</h2>\n<p>由于项目使用webpack和node构建，所以可以使用<code>eslint</code>等工具去做提交前代码规范检查，另外还使用了<code>editorconfig</code>和<a href="https://github.com/prettier/prettier"><code>prettier</code></a>去编辑器的设置和统一代码格式化。另外提一下，<a href="https://github.com/prettier/prettier"><code>prettier</code></a>可以通过配置项统一多种代码的格式化，因为在node端运行，所以可以做提交前的代码格式化。\n在各种工具配合下，基本可以做到代码风格的统一。</p>\n<p>此外，css方面没有使用csslint，但是普及了一下<a href="http://getbem.com/"><strong><code>BEM</code></strong></a>，样式方面的统一情况也收到不错的成效。</p>\n<h1>开发阶段</h1>\n<p>vue在开发时候的好处就体现出来了，没写过项目的同事基本都能把页面写出来，但是对于一些参数传递、父子组件相互调用会需要一点时间去熟悉。但是在开发流程中基本没有出现什么断链的情况。</p>\n<h2>组件化</h2>\n<p>在公司期间接触过几个项目，项目结构都比较凌乱，并没有把组件化的优势发挥出来，很多页面都是重新写几遍。所以这项目开始做之前，就普及了一下react生态圈里面的几个组件概念。</p>\n<ol>\n<li><strong>container component(接入型组件)</strong>。负责主要业务逻辑，组装数据，提供业务方法。</li>\n<li><strong>exhibition component(展示型组件)</strong>。负责数据展示工作，大部分是业务组件，数据进，页面出这样，没有复杂功能。</li>\n<li><strong>interactive component(交互型组件)</strong>。复用性比较强的组件，如<code>dialog</code>、<code>toast</code>等组件。</li>\n<li><strong>functional component(功能型组件)</strong>。这种组件一般都是作为一种扩展，抽象机制存在，没有渲染动作，例如vue中的<code>router-view</code>，<code>transition</code>等。</li>\n</ol>\n<p>了解大概组成后，一般都会把组件拆分得比较细，基本组件代码维持在<strong>300行代码</strong>左右，这样做得好处就是，业务变动时候需要改动的地方就比较少，但是组件对每个模块的影响相对的就变大了，但是这个可以通过<strong>测试</strong>去解决的。</p>\n<h2>动态接口地址</h2>\n<p>项目中接口跟静态资源会动态改变，所以需要取后台返回的值去拼接，页面静态资源可以自己写一个模板然后去拼接，接口可以取页面的变量，但是打包到项目的时候，发现路由分割的代码资源地址不对，由于代码是动态分割的，所以地址应该是取<code>config</code>里面的资源地址，所以导致加载失败。\n通过webpack文档跟stackoverflow里面相似案例，可以在动态引入js之前加入一个<a href="https://webpack.js.org/api/module-variables/#__webpack_public_path__-webpack-specific-"><code>__webpack_public_path__</code></a>配置项，动态获取异步模块的地址。具体代码如下：</p>\n<pre><code class="language-javascript">if (process.env.NODE_ENV === \'production\') {\n  // variables就是动态的地址\n  __webpack_public_path__ = variables + \'/\';\n};\n</code></pre>\n<h2>测试</h2>\n<p>由于前期比较急，单元测试到了中后期才加上，直接导致了单元测试的覆盖率不够，正常情况下应该一写完代码就马上加上测试。测试这些前期费点时间，后期获益良多的工作，项目、团队越大就越能体现测试的重要性了。\n现在是使用<a href="https://facebook.github.io/jest/">Jest</a> + <a href="https://eddyerburgh.gitbooks.io/avoriaz/content/">Avariaz</a>的组合去做测试工作，后期会切换为<code>Jest</code> + 官方提供的<a href="https://vue-test-utils.vuejs.org/zh-cn/">vue-test-utils</a>，两个<code>API</code>相似，切换代价不大。</p>\n<h1>SSR</h1>\n<p>项目没有这部分的需求，就自己在有空时间折腾了一下，照着官方的SSR文档搭了出来，不过用<a href="http://koajs.com/"><code>koa</code></a>代替了express（await、async写起来更爽一点）。直出的速度果然是不一样啊，不过也存在几个暂时还没空看的问题。</p>\n<ol>\n<li>按需直出页面设置，比如我需要A页面直出，B页面不直出，这操作还没找到怎么配置。</li>\n<li><code>Route</code>函数式的跳转无效，比如按钮需要动态去定义跳转方式的，绑定了函数，但是SSR处理后点击无效。</li>\n<li>服务器性能测试。由于node是单线程的，没做过对应的项目，不知道流量大的时候怎么处理，有机会要了解下。</li>\n</ol>\n<h1>总结</h1>\n<p>项目进行过程除了上面动态绑定接口地址，开发过程还是比较顺利的，不过还有几个需要改进的地方</p>\n<ol>\n<li>虽然有做code review，但是大部分都是自己改进，可以多留点问题和提出多点意见给对<code>vue</code>或者项目其他模块还不是很熟悉的同事去学习，共同进步。</li>\n<li>项目启动前对业务的了解不够清楚，导致后期才介入<code>vuex</code>去改进一些模块，做了无用功。</li>\n<li>项目启动前和设计沟通不够，导致后期图标没有使用到<code>iconfont</code>。不过后面也配合用按<code>BE(Block-Modify)</code>的方式命名图标，写了个脚本去自动生成less文件。</li>\n</ol>',htmlExcerpt:'<p>这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。</p>\n<h1>项目构建</h1>\n<p>项目创建是使用vue-cli创建的，模版则是使用我自己维护的<a href="https://github.com/kitwon/vue-mpa">vue-mpa</a>多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。</p>\n'}},{node:{frontmatter:{title:"构建60fps-web-app",date:"2017-09-13",category:["前端"],tags:["chrome","develop tool","javascript"],path:"/post/60fps-web-app"},excerpt:"\n> 这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。\n\n----\n\n> 现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的[render performance](https://developers.google.com/web/fundamentals/performance/rendering/)对前端渲染优化有了一个新的认识。\n\n# 几个重要概念\n## 60fps与设备刷新率\n目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。\n\n其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\n\n",headings:[{depth:1,value:"几个重要概念"},{depth:2,value:"60fps与设备刷新率"},{depth:2,value:"pixel pipeline"},{depth:1,value:"关键渲染行为"},{depth:2,value:"触发layout、paint的关键操作"},{depth:1,value:"优化程序"},{depth:2,value:"performance panel"},{depth:2,value:"javascript"},{depth:2,value:"style & layout"},{depth:2,value:"paint & composite"},{depth:3,value:"怎么看到网页的分层"},{depth:3,value:"怎么生成层"}],html:'<blockquote>\n<p>这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的<a href="https://developers.google.com/web/fundamentals/performance/rendering/">render performance</a>对前端渲染优化有了一个新的认识。</p>\n</blockquote>\n<h1>几个重要概念</h1>\n<h2>60fps与设备刷新率</h2>\n<p>目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。</p>\n<p>其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。</p>\n<!-- more -->\n<h2>pixel pipeline</h2>\n<p>影响浏览器渲染有很多因素，但是下面这5个关键的地方是我们可以控制的，也是像素至屏幕管道中关键的地方。\n<img src="http://kiit-1253813979.cosgz.myqcloud.com/%25E6%259E%2584%25E5%25BB%25BA60fps-web-app/pixel-pipline.jpg" alt="pixel pipeline"></p>\n<ul>\n<li>Javascript。 js中的动画效果和一些dom操作。</li>\n<li>样式计算(style)。 css匹配器的计算过程。例如<code>.nav__item > .slot</code>。</li>\n<li>布局(layout)。dom元素应用了规则之后，浏览器就会对其进行大小及位置的计算，这时候就会触发布局，而布局由于改变dom大小及位置，所以对其他元素也会造成影响。</li>\n<li>绘制(paint)。绘制就是填充像素的过程。大部分像素相关如文字、图片、阴影等都会触发绘制。绘制一般在层(layer)上面完成。</li>\n<li>合成。层的概念一般都出现在设计上面，但是浏览器中也有层的概念，所以有时候我们一些错误的操作或者属性都会使层的渲染顺序出现错误。</li>\n</ul>\n<h1>关键渲染行为</h1>\n<p>从服务器返回一个html开始，可以分为以下几步(这里英文的过程分别对应开发工具中<strong>performance</strong>面板的表示</p>\n<ol>\n<li>解析html，生成dom树，这里显示为<strong>Parser Html</strong></li>\n<li>然后根据页面的样式，将dom和css进行结合，此过程为<strong>Recalculate Style</strong></li>\n<li>最后就生成渲染树，<code>display: none</code>或<code>:after</code>等伪元素都不会出现在渲染树上</li>\n<li>浏览器知道哪个css规则应用哪个dom元素后，就开始计算布局(计算元素占用多少空间，出现在什么位置)，此过程是<strong>layout</strong></li>\n<li>确定位置后浏览器就开始对dom的样式及内容进行渲染，称为<strong>paint</strong></li>\n<li>dom渲染的时候，可能还会有图片资源，浏览器这时候就会将这些内容解码成内存，称为<strong>Image Decode + Resize</strong></li>\n<li><strong>paint</strong>开始的操作都是在同一个层面中执行，但其实浏览器还会创建多个图层，并且对这些图层进行单独的绘制，这个过程称为<strong>Composite Layers</strong></li>\n<li>这些操作在CPU中进行，执行完后上传到GPU中，最后显示到屏幕上</li>\n</ol>\n<h2>触发layout、paint的关键操作</h2>\n<p>我们知道一帧中就包含了上面的操作，但并不是所有改变网页外观操作都会触发上面的行为。回到<strong>pipeline</strong>，看看什么操作会分别触发什么行为。(下面会用数字代表对应图片上的位置)\n<img src="http://kiit-1253813979.cosgz.myqcloud.com/%25E6%259E%2584%25E5%25BB%25BA60fps-web-app/pixel-pipline.jpg" alt="pixel pipeline"></p>\n<ul>\n<li>第一种，通过css或者js进行了外观的更改(1)，这时浏览器就要重新计算元素的样式(2)，如果还更改了布局属性，元素的大小改变，必定会影响其他元素的位置，这时就要重新布局(3)，然后受影响的区域就需要重新绘制(4)，最后将所有东西合成在一起(5)。</li>\n<li>第二种，仅改变绘制属性(1)，例如背景、文字颜色、阴影等(2)，由于这些操作没有改变布局，所以会跳过(3)，直接进行(4)(5)的操作。</li>\n<li>第三种，通过改变样式(1)(2)，但是样式并没有对(3)(4)进行改动，所以会直接执行(5)的操作，例如<code>cursor: pointer</code>等属性。</li>\n</ul>\n<h1>优化程序</h1>\n<p>通过上面的介绍，我们知道影响帧数的主要是上面的几个渲染行为，但是要怎么知道是什么更改操作使帧数下降，就需要<strong>develop tool</strong>的帮助。</p>\n<h2>performance panel</h2>\n<p>性能分析面板是chrome中开发者工具自带的一个功能，我们能在上面看到录制实践中，<strong>pipeline</strong>的具体运行情况。\n<img src="http://kiit-1253813979.cosgz.myqcloud.com/%25E6%259E%2584%25E5%25BB%25BA60fps-web-app/performance.jpg" alt="performance panel"></p>\n<ol>\n<li>在(1)<strong>overview</strong>中，我们可以看到程序中大概的性能状况，fps、cpu、网络使用情况，还有对应的截图。一般情况，看到<strong>cpu</strong>部分一大片一大片的颜色就证明你的程序需要优化了。</li>\n<li>(2)中的<strong>main</strong>部分，可以看到主进程中的活动，所有时间点执行的操作及渲染行为都能在这个部分找到，主要的性能分析也是围绕这里展开，一半看到<strong>飙红</strong>的地方就证明那里是要下手的地方。</li>\n<li>(3)中则是对某个浏览器行为进行统计分析，能看到详细调用树和渲染层，找代码和<strong>layer tree</strong>都是(3)中。</li>\n</ol>\n<p>由于网上教程大部分的教程都用较低的版本，所以很多教程中的面板都找不到，比如<strong>painter</strong>就需要开启<strong>advance paint insturmentation</strong>，所以教程中找不到就需要google一下或者看下<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/">goole的官方教程</a>。具体的使用方法就不赘述，反正看见<strong>飙红就是要优化了</strong>。</p>\n<p>有工具之后，就可以针对具体的东西进行优化了，根据<strong>pipeline</strong>，我们其实可以知道优化点是哪几个了，javascript, style &#x26; layout, paint &#x26; composite。下面一个个分析下优化点。</p>\n<h2>javascript</h2>\n<p>由于javascript在<strong>pipeline</strong>中，所以在渲染过程中执行javascript代码必定会造成卡顿，俗称的帧丢失。在渲染过程中需要执行js代码的操作最常见的例子就是<strong>用js去操作动画</strong>，还有<strong>在浏览过程中做一些数据拉取及组装数据的操作</strong>。所以针对这些问题，我们需要使用一些新的api去改进我们的app。</p>\n<p><strong>1.使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame</a>代替setTimeout和setInterval去执行动画。</strong>\n一开始我们就说到帧数的概念，一个app想要不卡顿，必须达到60fps每秒的速度才能保证，减去浏览器自己的行为，每帧留给javascript执行的时间大概剩下10ms左右。或许不断调用setTimeout或者setIntervarl可以自定义函数执行时间，但是由于javascript是单线程，活着其他堆在栈中的代码会突然插入，导致函数执行中断。这时候raf就能解决这个问题了。具体使用方法可以自行查看<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">文档</a>。</p>\n<p><strong>2.使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">web worker</a>去进行一些多线程的操作。</strong>\n使用web worker后，浏览器会另起一个线程，所以就不会妨碍主线程中的pipeline了。我们可以在一些加载列表的场景中使用，比如用户在浏览，但是你想用这些时间去load一些数据回来，然后渲染页面，这时候worker会执行ajax，也不会妨碍到主线程执行。</p>\n<h2>style &#x26; layout</h2>\n<p>样式和布局也是帧里面的一部分，复杂的选择器或者某些js操作触发了强制布局，都会使性能下降，下面可以用这几个方法避免这些问题。\n<strong>1.操作数量多的dom时，减少选择器的复杂度。</strong>\n通常做项目的时候，我们一般都是操作少数的dom，但是某些特殊情况下可能要操作上千个dom(当然这不太现实)，这时候保持选择器的简洁就相当重要了，一个多级选择器计算时间足以超出10ms，所以，保持css中选择器的简洁是十分重要的。</p>\n<p><strong>2.避免布局反复FSL</strong>\n什么是布局反复，一帧的流程应该是按照<strong>pipeline</strong>的执行顺序去执行的，但是某些错误的javascript读写操作就很容易造成布局反复，如下代码</p>\n<pre><code class="language-javascript">var elms = document.getElementByTagName(\'p\')\nvar block = ducoment.getElementById(\'block\')\n\nfor (let i = 0; i &#x3C; elms.length; i++) {\n  var height = block.offsetHeight\n  elms[i].style.height = height\n}\n</code></pre>\n<p>在这段代码中，由于属性的读取操作<code>offsetHeight</code>会触发layout布局，然后下面设置高度的属性会触发style修改样式，两个在一个循环中就会造成布局反复，从而造成性能的损失。在<strong>performance panel</strong>中，缩小范围，如果看见layout中有红色的小三角，那么就是触发了FSL了，点进详情就能看到代码运行的地方在哪里了。</p>\n<h2>paint &#x26; composite</h2>\n<p>绘制和合成是一个相对比较复杂的流程，大多数样式更改都会触发这个过程，但是如果是大批量的元素或者一个复杂的动画绘制，在主线程中必定会造成性能问题。在这里就引入图层这个概念，由于浏览器的呈现器不在主线程中，所以图层会单独绘制，然后再和树进行合成。但如果层多的话，合成时间也会加长，所以使用层和限制层的数量也是需要注意的问题。</p>\n<h3>怎么看到网页的分层</h3>\n<p>具体看<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#paint-profiler">教程</a>\n进去搜<strong>View paint profiler</strong></p>\n<ol>\n<li>Enable advanced paint instrumentation.(这个选项在上图面板一，点击右上角的小齿轮)</li>\n<li>Select a Paint event in the Main section.(教程里面看图)</li>\n</ol>\n<h3>怎么生成层</h3>\n<ol>\n<li>社区中比较常见的<code>transform: translate3d(0, 0, 0)</code>、<code>transform: translateZ(0)</code>。虽然会有一些性能的浪费，但是好像是现在比较好的解决方法了。</li>\n<li>使用css新属性<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change"><code>will-change: transform</code></a>，浏览器支持度一般般。</li>\n</ol>\n<p>能够看完整篇的同学估计耐性都不错。通过一些基本的介绍，基本可以了解怎么查看和修复app的渲染性能问题了，不过使用现代的开发框架如<strong>react</strong>、<strong>vue</strong>、<strong>angular</strong>都很少会出现<strong>FSL</strong>的问题了，因为很大部分的<strong>layout</strong>动作都直接被<code>rerender</code>，但是一些比较旧的用dom操作些的APP或多或少都会出现上面的问题。大家可以看看自己的APP有没有达到要求。不说了，我去改代码了。</p>',htmlExcerpt:'<blockquote>\n<p>这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的<a href="https://developers.google.com/web/fundamentals/performance/rendering/">render performance</a>对前端渲染优化有了一个新的认识。</p>\n</blockquote>\n<h1>几个重要概念</h1>\n<h2>60fps与设备刷新率</h2>\n<p>目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。</p>\n<p>其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。</p>\n'}},{node:{frontmatter:{title:"在vue项目中使用jest进行单元测试",date:"2017-08-18",category:["前端工具"],tags:["unit test","vue","javascript"],path:"/post/vue-jest-test"},excerpt:"\n在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下[jest](http://facebook.github.io/jest/)，这是一个[Facebook OpenSource](https://code.facebook.com/projects/)的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持**快照测试**(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。\n\n# 配置\n首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析'.vue'文件的)。\n```shell\n$npm install jest jest-vue-preprocessor --save-dev\n\n$yarn add jest jest-vue-preprocessor --save\n```\n\n",headings:[{depth:1,value:"配置"},{depth:2,value:"package.json"},{depth:1,value:"跑个测试"},{depth:1,value:"last"}],html:'<p>在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下<a href="http://facebook.github.io/jest/">jest</a>，这是一个<a href="https://code.facebook.com/projects/">Facebook OpenSource</a>的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持<strong>快照测试</strong>(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。</p>\n<h1>配置</h1>\n<p>首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析\'.vue\'文件的)。</p>\n<pre><code class="language-shell">$npm install jest jest-vue-preprocessor --save-dev\n\n$yarn add jest jest-vue-preprocessor --save\n</code></pre>\n<!-- more -->\n<h2>package.json</h2>\n<p>下面的配置都在<strong>package.json</strong>文件中配置。</p>\n<p>在文件最底部添加下面代码</p>\n<pre><code class="language-javascript">{\n  // ...\n  "jest": {\n    // 配置文件拓展名\n    "moduleFileExtensions": [\n      "js",\n      "vue"\n    ],\n    // 匹配webpack中配置的alias\n    "moduleNameMapper": {\n      "^vue$": "vue/dist/vue.common.js",\n      "^@(.*)$": "&#x3C;rootDir>/src$1"\n    },\n    // 编译工具\n    "transform": {\n      ".*\\\\.(vue)$": "&#x3C;rootDir>/node_modules/jest-vue-preprocessor",\n      ".*": "babel-jest"\n    }\n  }\n}\n</code></pre>\n<!-- more -->\n<p>然后在上面<code>script</code>中添加一条新的命令</p>\n<pre><code class="language-javascript">{\n  // ...\n  "test": "./node_modules/.bin/jest"\n}\n</code></pre>\n<p>然后就配置好了，很快，很舒服。</p>\n<h1>跑个测试</h1>\n<p>首先，我有个vue组件cell，一个简单的列表item组件，代码如下</p>\n<pre><code class="language-vue">&#x3C;template>\n  &#x3C;a class="ui-cell" :href="href">\n    &#x3C;div class="ui-cell-wrapper">\n      &#x3C;slot name="icon">\n        &#x3C;i v-if="iconClass" :class="iconClass">&#x3C;/i>\n      &#x3C;/slot>\n      &#x3C;slot name="title">\n        &#x3C;div class="ui-cell-title">\n          &#x3C;div class="ui-cell-text" v-text="title">&#x3C;/div>\n          &#x3C;div class="ui-cell-label" v-if="label" v-text="label">&#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/slot>\n      &#x3C;div class="ui-cell-value" :class="{ \'isLink\': isLink }">\n        &#x3C;slot>\n           &#x3C;div v-text="value">&#x3C;/div>\n        &#x3C;/slot>\n      &#x3C;/div>\n      &#x3C;i class="icon-arrow-right" v-if="isLink">&#x3C;/i>\n    &#x3C;/div>\n  &#x3C;/a>\n&#x3C;/template>\n\n...\n\n&#x3C;script>\n  export default {\n    name: \'ui-cell\',\n    props: {\n      to: [String, Object],\n      iconClass: String,\n      title: String,\n      label: String,\n      value: {\n        default: \'\'\n      }\n    },\n    computed: {\n      href () {\n        if (this.to &#x26;&#x26; !this.added &#x26;&#x26; this.$router) {\n          const resolve = this.$router.match(this.to)\n          if (resolve.matched.length &#x3C;= 0) {\n            return this.to\n          }\n\n          this.$nextTick(() => {\n            this.added = true\n            this.$el.addEventListener(\'click\', this.handleClick)\n          })\n          return resolve.path\n        }\n\n        return this.to\n      },\n      isLink () {\n        return !!this.to\n      }\n    },\n    methods: {\n      handleClick (e) {\n        e.preventDefault()\n        this.$router.push(this.href)\n      }\n    }\n  }\n&#x3C;/script>\n</code></pre>\n<p>然后编写测试文件</p>\n<pre><code class="language-javascript">import Vue from \'vue\'\nimport Cell from \'@/components/cell\'\nimport VueRouter from \'vue-router\'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    path: \'/foo\',\n    component: Cell\n  }\n]\nconst router = new VueRouter({\n  routes\n})\n\nconst mockFn = jest.fn()\nCell.methods = {\n  handleClick(e) {\n    mockFn.mockReturnValue(true)\n  }\n}\n\nconst Constructor = Vue.extend(Cell)\nconst vm = new Constructor({\n  propsData: {\n    title: \'cell1\',\n    value: \'value1\',\n    label: \'label1\'\n  }\n}).$mount()\n\nconst vm2 = new Constructor({\n  router,\n  propsData: {\n    title: \'cell2\',\n    value: \'value2\',\n    to: \'/foo\'\n  }\n}).$mount()\n\nconst vm3 = new Constructor({\n  propsData: {\n    title: \'cell3\',\n    value: \'value3\',\n    iconClass: \'icon-test\'\n  }\n}).$mount()\n\ndescribe(\'Cell component\', () => {\n  test(\'render currect dom\', () => {\n    expect(vm.$el).toMatchSnapshot()\n    expect(vm2.$el).toMatchSnapshot()\n    expect(vm3.$el).toMatchSnapshot()\n  })\n\n  test(\'router action currectly run\', () => {\n    vm2.$nextTick(() => {\n      vm2.$el.click()\n      expect(vm2.href).toBe(vm2.to)\n      expect(mockFn()).toBe(true)\n    })\n  })\n})\n</code></pre>\n<p>然后跑一下命令</p>\n<pre><code class="language-shell">$npm run test\n\n> jest-test@1.0.0 test /Users/kit/projects/jest-test\n> jest\n\n PASS  test/unit/Cell.spec.js\n  Cell component\n    ✓ render currect dom (8ms)\n    ✓ router action currectly run (2ms)\n\nSnapshot Summary\n › 3 snapshots written in 1 test suite.\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   3 added, 3 total\nTime:        2.295\n</code></pre>\n<h1>last</h1>\n<p>jest给我们提供了一个便捷的测试环境，简单的几个配置项，即可完成编译，不像mocha或jasmine需要其他<code>node module</code>配合完成测试的工作。个人认为fb还是做到了他希望的，让测试变得简单，让开发者有更多的时间去开发。至于自动化测试的好处这里就不再赘述了，有兴趣的朋友可以自行baidu、google。</p>',htmlExcerpt:'<p>在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下<a href="http://facebook.github.io/jest/">jest</a>，这是一个<a href="https://code.facebook.com/projects/">Facebook OpenSource</a>的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持<strong>快照测试</strong>(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。</p>\n<h1>配置</h1>\n<p>首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析\'.vue\'文件的)。</p>\n<pre><code class="language-shell">$npm install jest jest-vue-preprocessor --save-dev\n\n$yarn add jest jest-vue-preprocessor --save\n</code></pre>\n'}},{node:{frontmatter:{title:"深入学习javascript-类",date:"2017-07-20",category:null,tags:null,path:"/post/js-class"},excerpt:"\n# 类理论\n类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。\n\n类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。**汽车**可以被看作**交通工具中的一种**，所以在软件开发时可以定义一个`Vehicle`类，`Vehicle`中包含推进器（引擎）、载人能力等方法。定义`Car`时，只要声明它继承或者拓展`Vehicle`这个基础定义就行了，其他交通工具如船、飞机也可以继承`Vehicle`。**这就是类的实例化与继承**。\n\n类的另外一个核心概念是**多态**，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。\n\njavascript中也有类中的`new`和`instanceof`，还有ES6中的`class`关键字，但这些并不是说明js中有**类**的。javascript中只是为了满足类的设计需求而提供一些类似的语法。\n\n## js中实现类复制(混入)\njavascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。\n\n",headings:[{depth:1,value:"类理论"},{depth:2,value:"js中实现类复制(混入)"},{depth:3,value:"显式混入"},{depth:3,value:"隐式混入"},{depth:1,value:"prototype-原型"},{depth:2,value:"如何工作"},{depth:1,value:"小结"}],html:"<h1>类理论</h1>\n<p>类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。</p>\n<p>类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。<strong>汽车</strong>可以被看作<strong>交通工具中的一种</strong>，所以在软件开发时可以定义一个<code>Vehicle</code>类，<code>Vehicle</code>中包含推进器（引擎）、载人能力等方法。定义<code>Car</code>时，只要声明它继承或者拓展<code>Vehicle</code>这个基础定义就行了，其他交通工具如船、飞机也可以继承<code>Vehicle</code>。<strong>这就是类的实例化与继承</strong>。</p>\n<p>类的另外一个核心概念是<strong>多态</strong>，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。</p>\n<p>javascript中也有类中的<code>new</code>和<code>instanceof</code>，还有ES6中的<code>class</code>关键字，但这些并不是说明js中有<strong>类</strong>的。javascript中只是为了满足类的设计需求而提供一些类似的语法。</p>\n<h2>js中实现类复制(混入)</h2>\n<p>javascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。</p>\n<!-- more -->\n<h3>显式混入</h3>\n<p>显示混入在其他库或者框架中一般被称为<code>extend</code>，在这方便理解会使用<code>mixin</code>。</p>\n<pre><code class=\"language-javascript\">// 前面的Vehicle和car的例子\nfunction mixin(sourceObj, targetObj) {\n  for(var i in sourceObj) {\n    if(!(i in targetObj)) {\n      targetObj[i] = sourceObj[i];\n    }\n  }\n\n  return targetObj;\n}\n\nvar Vehicle = {\n  engines: 1,\n  ignition: function() {\n    console.log('Turning on my engines.');\n  },\n  drive: function() {\n    this.ignition();\n    console.log('Steering and moving forward.');\n  }\n}\n\nvar Car = mixin(Vehicle, {\n  wheels: 4,\n  drive: function() {\n    Vehicle.drive.call(this);\n    console.log('Rolling on all' + this.wheels + 'wheels!');\n  }\n})\n</code></pre>\n<p>还有一种显示混入的变体叫<strong>寄生继承</strong></p>\n<pre><code class=\"language-javascript\">function Vehicle() {\n  this.engines = 1;\n}\nVehicle.prototype.ignition = function() {\n  console.log('Turning on my engines.');\n}\nVehicle.prototype.drive = function() {\n  this.ignition();\n  console.log('Steering and moving forward.');\n}\n\n// 寄生类 car\nfunction Car() {\n  var car  = new Vehicle();\n\n  car.wheels = 4;\n  var vehDrive = car.drive;\n\n  car.drive = function() {\n    Vehicle.call(this);\n    console.log('Rolling on all' + this.wheels + 'wheels!');\n  }\n\n  return car;\n}\n\nvar myCar = new Car();\nmyCar.drive();\n</code></pre>\n<h3>隐式混入</h3>\n<p>隐式混入就是改变在一个函数体内执行另外另一个函数的方法。</p>\n<pre><code class=\"language-javascript\">var foo = {\n  cool: function() {\n    this.count = this.count ? this.count++ : 1;\n    console.log(this.count);\n  }\n}\n\nfoo.cool(); // 1\n\nvar bar = {\n  cool: function() {\n    foo.cool.call(this);\n  }\n}\n\nbar.cool(); // 1, 数据不共享\n</code></pre>\n<h1>prototype-原型</h1>\n<p>JS中，当试图引用对象属性时候就会触发<code>[[GET]]</code>操作，如果在对象属性中没有找到，就会使用对象的<code>[[prototype]]</code>链。JS大部分复杂类型都是<code>object</code>，所以<code>[[prototype]]</code>“尽头”应该是<code>Object.prototype</code>，里面包含了许多原生方法，如<code>toString</code>或<code>valueOf</code>。</p>\n<h2>如何工作</h2>\n<p>JS和其他OO语言并不同，JS中并没有类作为对象的抽象模式，JS中只有对象，所以当new一个对象时候，并不是复制一个类函数，而是将目标对象的<code>prototype</code>关联到新对象的<code>prototype</code>中。</p>\n<h1>小结</h1>\n<p><code>prototype</code>部分书本总结得比较清楚，想知道更多细节的同学可以参考<strong>you dont know javascript</strong>的5.1-5.4章节。</p>\n<ul>\n<li>访问对象时候都会触发对象的[[GET]]操作，如果没有找到属性的话会继续找[[Prototype]]链。</li>\n<li>普通对象的原型链顶端都是<code>Object.prototype</code></li>\n<li><code>new</code>调用函数时只会关系到对象，而不会复制</li>\n</ul>",
htmlExcerpt:"<h1>类理论</h1>\n<p>类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。</p>\n<p>类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。<strong>汽车</strong>可以被看作<strong>交通工具中的一种</strong>，所以在软件开发时可以定义一个<code>Vehicle</code>类，<code>Vehicle</code>中包含推进器（引擎）、载人能力等方法。定义<code>Car</code>时，只要声明它继承或者拓展<code>Vehicle</code>这个基础定义就行了，其他交通工具如船、飞机也可以继承<code>Vehicle</code>。<strong>这就是类的实例化与继承</strong>。</p>\n<p>类的另外一个核心概念是<strong>多态</strong>，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。</p>\n<p>javascript中也有类中的<code>new</code>和<code>instanceof</code>，还有ES6中的<code>class</code>关键字，但这些并不是说明js中有<strong>类</strong>的。javascript中只是为了满足类的设计需求而提供一些类似的语法。</p>\n<h2>js中实现类复制(混入)</h2>\n<p>javascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。</p>\n"}},{node:{frontmatter:{title:"深入学习javascript - this",date:"2017-06-27",category:null,tags:null,path:"/post/js-this"},excerpt:"\n# 关于this\n\n`this`应该是javascript中一个比较复杂的机制了，在日常工作中我们可能有意无意都会使用到这个机制，但是`this`的工作机制真正了解的可能只有皮毛，通过学习这一机制，能够提高对js代码的理解和阅读能力，还有对js程序设计模式有着更深的理解。\n\n# this的指向\nthis是运行时进行绑定的，而不是编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n\n通过分析调用位置，就能知道this到底引用的是什么。所以，寻找调用位置就能弄清上面的问题，通过一个例子，就能很好地理解这个问题：\n```javascript\nfunction baz() {\n  // 当前调用栈是 baz\n  // 当前调用位置是全局作用域\n\n  console.log('baz');\n  bar(); // bar的调用位置\n}\n\nfunction bar() {\n  // 当前的调用栈是 baz -> bar\n  // 当前的调用位置是baz\n\n  console.log('bar');\n  foo();\n}\n\nfunction foo() {\n  // 当前的调用栈是 baz -> bar -> foo\n  // 当前的调用位置是bar\n\n  console.log('foo');\n}\n\nbaz();\n```\n\n",headings:[{depth:1,value:"关于this"},{depth:1,value:"this的指向"},{depth:1,value:"绑定规则"},{depth:2,value:"默认绑定"},{depth:2,value:"隐式绑定"},{depth:3,value:"隐式丢失"},{depth:2,value:"显式绑定"},{depth:2,value:"硬绑定"},{depth:2,value:"new绑定"},{depth:1,value:"绑定优先级"},{depth:1,value:"绑定例外"},{depth:2,value:"被忽略的this"},{depth:2,value:"间接引用"},{depth:2,value:"软绑定"},{depth:1,value:"箭头函数"}],html:'<h1>关于this</h1>\n<p><code>this</code>应该是javascript中一个比较复杂的机制了，在日常工作中我们可能有意无意都会使用到这个机制，但是<code>this</code>的工作机制真正了解的可能只有皮毛，通过学习这一机制，能够提高对js代码的理解和阅读能力，还有对js程序设计模式有着更深的理解。</p>\n<h1>this的指向</h1>\n<p>this是运行时进行绑定的，而不是编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>\n<p>通过分析调用位置，就能知道this到底引用的是什么。所以，寻找调用位置就能弄清上面的问题，通过一个例子，就能很好地理解这个问题：</p>\n<pre><code class="language-javascript">function baz() {\n  // 当前调用栈是 baz\n  // 当前调用位置是全局作用域\n\n  console.log(\'baz\');\n  bar(); // bar的调用位置\n}\n\nfunction bar() {\n  // 当前的调用栈是 baz -> bar\n  // 当前的调用位置是baz\n\n  console.log(\'bar\');\n  foo();\n}\n\nfunction foo() {\n  // 当前的调用栈是 baz -> bar -> foo\n  // 当前的调用位置是bar\n\n  console.log(\'foo\');\n}\n\nbaz();\n</code></pre>\n<!-- more -->\n<h1>绑定规则</h1>\n<p>除了像上面分析代码，还有一个最简单的方式就是分析调用工具。找到调用位置后，就能根据下面的4条规则来判断this如何绑定。</p>\n<h2>默认绑定</h2>\n<pre><code class="language-javascript">function foo() {\n  console.log(this.a);\n}\n\nvar a = 2;\n\nfoo(); // 2\n</code></pre>\n<p>从上面代码可以知道，<code>foo</code>的调用位置在全局中，不带任何修饰地调用，因此只能使用<strong>默认绑定</strong>。</p>\n<p>在这里要注意一个细节，如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定。</p>\n<h2>隐式绑定</h2>\n<pre><code class="language-javascript">function  foo() {\n  console.log(this.a);\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n}\n\nobj.foo(); // 2\n</code></pre>\n<p>从上代码可以看出<code>obj</code>，调用位置会使用<code>obj</code>上下文来引用函数，因此，可以说函数被调用时候<code>obj</code>对象“包含”它。当函数引用有上下文对象时，<strong>隐式绑定</strong> 规则会把函数引用调用中的<code>this</code>绑定到这个对象中。所以<code>this.a</code>与<code>obj.a</code>在此时是一样的。</p>\n<p>对象属性应用链中只有最顶层或者说最后一层会影响调用位置。如下:</p>\n<pre><code class="language-javascript">function foo() {\n  console.log(this.a);\n}\n\nvar obj2 = {\n  a: 42,\n  foo: foo\n}\n\nvar obj1 = {\n  a: 2,\n  obj2: obj2\n}\n\nobj1.obj2.foo(); // 42\n</code></pre>\n<h3>隐式丢失</h3>\n<p><strong>隐式丢失</strong> 就是隐式绑定的函数丢失绑定对象，然后应用<strong>默认绑定</strong>，从而把<code>this</code>绑定到全局对象或者<code>undefined</code>中，取决于是否严格模式。</p>\n<pre><code class="language-javascript">function foo() {\n  console.log(this.a);\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n}\n\nvar bar = obj.foo; // 函数别名\n\nvar a = \'oops, global\';\n\nbar(); // opps, global\n</code></pre>\n<p>或者在传入回调函数的时候：</p>\n<pre><code class="language-javascript">function foo() {\n  console.log(this.a);\n}\n\nfunction doFoo(fn) {\n  fn();\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n}\n\nvar a = \'oops, global\';\n\ndoFoo(obj.foo); // opps, global\n</code></pre>\n<p>传入函数就是一种隐式赋值，所以结果和上一个例子也是一样的。</p>\n<h2>显式绑定</h2>\n<p>使用<code>call</code>和<code>apply</code>方法对对象进行强制调用函数。</p>\n<pre><code class="language-javascript">function foo() {\n  console.log(this.a);\n}\n\nvar obj = {\n  a: 2\n}\n\nfoo.call(obj); // 2\n</code></pre>\n<p><code>call</code>和<code>apply</code>在绑定的机制基本是一样的，就是传参不一样，<code>call</code>为单独的参数，<code>apply</code>为数组。</p>\n<h2>硬绑定</h2>\n<p>硬绑定为显式绑定的一个变种，能够解决丢失绑定的问题，先思考下面代码：</p>\n<pre><code class="language-javascript">function foo() {\n  console.log(this.a);\n}\n\nvar obj = {\n  a: 2\n}\n\nvar bar = function() {\n  foo.call(obj);\n}\n\nbar();\nsetTimeout(bar, 100); // 2\n\n// 硬绑定的bar不能再修改它的this\nbar.call(window);\n</code></pre>\n<p>可以创建一个可以重复使用的硬绑定函数：</p>\n<pre><code class="language-javascript">function foo(something) {\n  console.log(this.a, something);\n  return this.a + something;\n}\n\n// 辅助绑定函数\nfunction bind(fn, obj) {\n  return function() {\n    return fn.apply(obj, arguments);\n  }\n}\n\nvar obj = {\n  a: 2\n};\n\nvar bar = bind(foo, obj);\n\nvar b = bar(3); // 2 3\nconsole.log(b); // 5\n</code></pre>\n<p>其实在ES5中已经提供了原生的<code>Fucntion.prototype.bind</code>的方法，可以直接使用：</p>\n<pre><code class="language-javascript">function foo(something) {\n  console.log(this.a, something);\n  return this.a + something;\n}\n\nvar obj = {\n  a: 2\n}\n\nvar bar = foo.bind(obj);\n\nvar b = bar(3);\nconsole.log(b);\n</code></pre>\n<h2>new绑定</h2>\n<p>JavaScript中的new并不想其他oo语言那样会实例化一个类，只是使用new操作符调用普通的函数，在这个调用也会对this进行绑定。\n使用new调用函数时，会自动执行下面操作：</p>\n<ol>\n<li>创建（或者说构造）一个全新的对象。</li>\n<li>这个对象会被执行[[原型]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>看下面代码：</p>\n<pre><code class="language-javascript">function foo(a) {\n  this.a = a;\n}\n\nvar bar = new foo(2);\n\nconsole.log(bar.a);\n</code></pre>\n<p>像这样普通的new调用<code>foo(...)</code>时，会构造一个新的对象并把它绑定到<code>foo(..)</code>调用中的this上。这个就称为new绑定。</p>\n<h1>绑定优先级</h1>\n<p>绑定优先级按照下面的顺序来判断：</p>\n<ol>\n<li>\n<p>函数是否在new中调用(new绑定)？如果是的话this绑定的是新创建的对象。</p>\n<pre><code class="language-javascript">var bar = new foo();\n</code></pre>\n</li>\n<li>\n<p>函数是否通过call、apply(显示绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。</p>\n<pre><code class="language-javascript">var bar = foo.call(obj2);\n</code></pre>\n</li>\n<li>\n<p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是哪个上下文对象。</p>\n<pre><code class="language-javascript">var bar = obj.foo();\n</code></pre>\n</li>\n<li>\n<p>若果都不是的话，适用默认绑定，严格模式下绑定到<code>undefined</code>，否则就绑到全局对象。</p>\n<pre><code class="language-javascript">var bar = foo();\n</code></pre>\n</li>\n</ol>\n<h1>绑定例外</h1>\n<p>在某些场景下this的绑定用上面的规制是判断不了的，可能认为是其他绑定规则，实际引用的是<a href="#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A">默认绑定</a>规则。</p>\n<h2>被忽略的this</h2>\n<p>如果把<code>null</code>或者<code>undefined</code>作为this的绑定对象传入call、apply或者bind中，这些值在调用时会被忽略，实际应用的是默认规则。</p>\n<pre><code class="language-javascript">function fOO() {\n  console.log(this.a);\n}\n\nvar a = 2;\n\nfoo.call(null); // 2\n</code></pre>\n<p>这种情况虽然并不多见，但是使用apply展开数组或者适用<code>bind(...)</code>进行<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a>的时候会用到。</p>\n<pre><code class="language-javascript">function foo(a, b) {\n  console.log(\'a: \' + a + \'b: \' + b);\n}\n\nfoo.apply(null, [2, 3]); // a: 2, b: 3\n\n// 适用bind(..) 进行柯里化\nvar bar = foo.bind(nul, 2);\nbar(3); // a: 2, b: 3\n</code></pre>\n<p><strong>注意：很多时候新建一个空对象<code>var n = Object.creat(null)</code>代替<code>null</code>更为安全。</strong></p>\n<h2>间接引用</h2>\n<p>间接引用上面介绍<a href="#%E9%9A%90%E5%BC%8F%E4%B8%A2%E5%A4%B1">隐式丢失</a>的时候也有举过例子，调用间接引用的函数也会造成绑定例外。</p>\n<pre><code class="language-javascript">function foo() {\n  console.log(this.a);\n}\n\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4 };\n\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n</code></pre>\n<h2>软绑定</h2>\n<p>软绑定可以实现硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改this的能力。具体使用方式如下：</p>\n<pre><code class="language-javascript">function foo() {\n  console.log(\'name：\' + this.name);\n}\n\nvar obj = { name: \'obj\' };\nvar obj2 = { name: \'obj2\' };\nvar obj3 = { name: \'obj3\' };\n\n// 稍后实现softBind\nvar fooOBJ = foo.softBind(obj);\n\nfooOBJ(); // name: obj\n\nobj2.foo = foo.softBind(obj);\nobj2.foo(); // name: obj2\n\nfooOBJ.call(obj3); // name: obj3\n\nsetTimeout(obj2.foo, 10); // name: obj 应用了软绑定\n</code></pre>\n<p>可以看到，软绑定的<code>foo()</code>可以手动将this绑定到<code>obj2</code>或者<code>obj3</code>上，但如果应用默认绑定，则会将this绑定到obj中。</p>\n<p><code>softBind</code>的实现方式如下:</p>\n<pre><code class="language-javascript">if(!Function.prototype.softBind) {\n  Function.prototype.softBind = function(obj) {\n    var fn = this;\n    var curried = [].slice.call(arguments, 1);\n    var bound = function() {\n      return fn.apply(!this || this === (window || global) ? obj: this);\n\n      curried.concat.apply(curried, arguments)\n    };\n\n    bound.prototype = Object.create(fn.prototype);\n    return bound;\n  }\n}\n</code></pre>\n<p>这个函数首先检查调用时候的this，如果this绑定到全局或者undefined中，那就把指定的默认对象<code>obj</code>绑定到this，否则不修改this。<strong>ES5中的bind()已经实现此部分功能</strong>。</p>\n<h1>箭头函数</h1>\n<p>前面接受的<a href="#%E7%BB%91%E5%AE%9A%E4%BC%98%E5%85%88%E7%BA%A7">四条规则</a>可以包含所有正常函数。但是ES6中的<strong>箭头函数</strong>则无法使用这些规则。</p>\n<pre><code class="language-javascript">function foo() {\n  return (a) => {\n    // this继承foo\n    console.log(this.a);\n  };\n}\n\nvar obj1 = {\n  a: 2\n};\n\nvar obj2 = {\n  a: 3\n};\n\nvar bar = foo.call(obj1);\nbar.call(obj2); // 2，不是3\n</code></pre>\n<p><code>foo()</code>内部的箭头函数会捕获调用<code>foo()</code>时的this。由于<code>foo()</code>的this绑定到<code>obj1</code>,<code>bar</code>的this也会绑定到<code>obj1</code>，箭头函数的绑定无法被修改。(new也不行)</p>\n<p>在ES6出现之前我们经常写的一种模式与箭头函数是几乎相同的：</p>\n<pre><code class="language-javascript">function foo() {\n    var self = this;\n    setTimeout(function() {\n        console.log(self.a);\n    }, 100);\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo.call(obj); // 2\n</code></pre>\n<p><code>var self = this</code>和箭头函数从本质来说是想取代this的机制，如果代码中大多数使用<code>var self = this;</code>，那么应该完全使用词法作用域或箭头函数，抛弃this风格的代码。相反，如果使用this，则可以上方的绑定机制。</p>',htmlExcerpt:"<h1>关于this</h1>\n<p><code>this</code>应该是javascript中一个比较复杂的机制了，在日常工作中我们可能有意无意都会使用到这个机制，但是<code>this</code>的工作机制真正了解的可能只有皮毛，通过学习这一机制，能够提高对js代码的理解和阅读能力，还有对js程序设计模式有着更深的理解。</p>\n<h1>this的指向</h1>\n<p>this是运行时进行绑定的，而不是编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>\n<p>通过分析调用位置，就能知道this到底引用的是什么。所以，寻找调用位置就能弄清上面的问题，通过一个例子，就能很好地理解这个问题：</p>\n<pre><code class=\"language-javascript\">function baz() {\n  // 当前调用栈是 baz\n  // 当前调用位置是全局作用域\n\n  console.log('baz');\n  bar(); // bar的调用位置\n}\n\nfunction bar() {\n  // 当前的调用栈是 baz -> bar\n  // 当前的调用位置是baz\n\n  console.log('bar');\n  foo();\n}\n\nfunction foo() {\n  // 当前的调用栈是 baz -> bar -> foo\n  // 当前的调用位置是bar\n\n  console.log('foo');\n}\n\nbaz();\n</code></pre>\n"}},{node:{frontmatter:{title:"webpack2新特性&迁移",date:"2017-06-24",category:["前端工具"],tags:["webpack"],path:"/post/webpack2"},excerpt:"\nwebpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。\n\n# 从webpack1中迁移\n官方已经给出了详细的[迁移指南](https://webpack.js.org/guides/migrating/)，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。\n\n## 配置文件\n如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。\n\n### `module.loaders`变成`module.rules`\n旧的`module.loader`被`module.rules`取代，后者允许配置`loader`更多选项，具体查看文档[module.rules](https://webpack.js.org/configuration/module/#module-rules)\n\n```javascript\n// ...\nmdoule: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [\n                { loader: 'style-loader' },\n                {\n                    loader: 'css-loader',\n                    options: { module: true }\n                }\n            ]\n        },\n        {\n            test: /\\.jsx$/,\n            loader: 'babel-loader',\n            options: {\n                // ...\n            }\n        }\n    ]\n}\n// ...\n```\n\n",headings:[{depth:1,value:"从webpack1中迁移"},{depth:2,value:"配置文件"},{depth:3,value:"变成"},{depth:3,value:"改动"},{depth:3,value:null},{depth:3,value:"CLI中配置使用自定义参数"},{depth:2,value:"主要变更"},{depth:3,value:"ES6模块"},{depth:1,value:"总结"},{depth:2,value:"参考"}],html:"<p>webpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。</p>\n<h1>从webpack1中迁移</h1>\n<p>官方已经给出了详细的<a href=\"https://webpack.js.org/guides/migrating/\">迁移指南</a>，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。</p>\n<h2>配置文件</h2>\n<p>如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。</p>\n<h3><code>module.loaders</code>变成<code>module.rules</code></h3>\n<p>旧的<code>module.loader</code>被<code>module.rules</code>取代，后者允许配置<code>loader</code>更多选项，具体查看文档<a href=\"https://webpack.js.org/configuration/module/#module-rules\">module.rules</a></p>\n<pre><code class=\"language-javascript\">// ...\nmdoule: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [\n                { loader: 'style-loader' },\n                {\n                    loader: 'css-loader',\n                    options: { module: true }\n                }\n            ]\n        },\n        {\n            test: /\\.jsx$/,\n            loader: 'babel-loader',\n            options: {\n                // ...\n            }\n        }\n    ]\n}\n// ...\n</code></pre>\n<!-- more -->\n<pre><code class=\"language-javascript\">// ...\nmodule: {\n    rules: {\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n    }\n}\n// ...\n</code></pre>\n<p>除上面两项外还有</p>\n<ul>\n<li>现在指定loader的时候不能再省略<code>-loader</code>后缀。具体原因参阅<a href=\"https://github.com/webpack/webpack/issues/2986\">#2968</a></li>\n<li><code>json-loader</code>不需再手动添加。</li>\n<li>loader默认的resolve配置是相对于<code>context</code>配置项的。</li>\n<li>取消了<code>module.preLoaders</code>以及<code>module.postLoaders</code>。</li>\n</ul>\n<h3><code>UglifyPlugin</code>改动</h3>\n<ul>\n<li><code>UglifyPlugin</code>的<code>sourceMap</code>现在的默认值的<code>false</code>而不是<code>true</code>。</li>\n<li><code>UglifyJsPlugin</code>的<code>compress.warnings</code>配置项现在默认为<code>false</code>而不是<code>true</code>。</li>\n</ul>\n<h3><code>ExtractTextWebpackPlugin</code></h3>\n<p>插件变化主要体现在语法上，又原来的单个参数传变成了对象，现在的配置方式如下</p>\n<pre><code class=\"language-javascript\">// ExtractTextPlugin.extract\nmodule: {\n    rules: [\n        test: /\\.css$/,\n        loader: ExtractTextPlugin.extract({\n            fallbackLoader: 'style-loader',\n            loader: 'css-loader',\n            publicPath: '/dist'\n        })\n    ]\n}\n\n// new ExtractTextPlugin({options})\nplugins: [\n    new ExtractTextPlugin({\n        filename: 'bundle.css',\n        disabled: true,\n        allChunks: true\n    })\n]\n</code></pre>\n<h3>CLI中配置使用自定义参数</h3>\n<p>在webpack1中可以用<code>process.argv</code>获取自定义参数，但是在webpack2中这行为被禁止了，替代地提供了一个接口<code>env</code>去获取自定义参数</p>\n<pre><code class=\"language-javascript\">module.export = function(env) {\n    var customStuff = env.customStuff;\n\n    // ...\n    return config;\n};\n</code></pre>\n<h2>主要变更</h2>\n<h3>ES6模块</h3>\n<p>webpack2现在增加对ES6的模块化的原生支持，意味着现在能够直接识别<code>import</code>和<code>export</code>了，不需要先转成CommonJS模块的格式。\n支持原生<code>import</code>带来的影响就是支持异步加载模块，webpack1使用异步模块的时候如下</p>\n<pre><code class=\"language-javascript\">require.ensure(['a'], function(a) {\n    a.doSomething()\n}, 'chunkName')\n</code></pre>\n<p>webpack2的<code>import</code>会返回一个<code>promise</code>对象</p>\n<pre><code class=\"language-javascript\">import('a').then(function(a) {\n    a.doSomething()\n})\n</code></pre>\n<p>而且现在<strong>chunk加载失败能被Promise捕捉到</strong>，那就意味着我们能够在组件加载失败的时候采取相应的操作。</p>\n<p>另外现在<code>import</code>还支持动态表达式。</p>\n<pre><code class=\"language-javascript\">function route(path, query) {\n    return import('/routes/${path}/route').then(route => new route.Route(query);\n    })\n}\n</code></pre>\n<h1>总结</h1>\n<p>用着<em>vim-mode</em>，写完这篇已经完全头皮发麻了，完全熟悉估计不知道还要多久呢。回正题，·从官方文档来看，改动的地方的确不多，迁移成本应该是比较低的，至于要不要迁移我觉得还是见仁见智吧，如果新版的优点好处大于迁移的成本的话各位应该可以放心去改动你的配置文件了。总的来说webpack2有以下几个优点</p>\n<ul>\n<li>编译速度提高</li>\n<li>编译文件大小相对减少了</li>\n<li>支持promise</li>\n<li>能捕捉到chunk加载失败</li>\n</ul>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://webpack.js.org/guides/migrating/\">Migrating from v1 to v2</a></li>\n<li><a href=\"http://www.tuicool.com/articles/aieAnan\">升级到 webpack2</a></li>\n<li><a href=\"http://imweb.io/topic/58666d57b3ce6d8e3f9f99b0\">webpack2 的 tree-shaking 好用吗？</a></li>\n</ul>",htmlExcerpt:"<p>webpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。</p>\n<h1>从webpack1中迁移</h1>\n<p>官方已经给出了详细的<a href=\"https://webpack.js.org/guides/migrating/\">迁移指南</a>，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。</p>\n<h2>配置文件</h2>\n<p>如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。</p>\n<h3><code>module.loaders</code>变成<code>module.rules</code></h3>\n<p>旧的<code>module.loader</code>被<code>module.rules</code>取代，后者允许配置<code>loader</code>更多选项，具体查看文档<a href=\"https://webpack.js.org/configuration/module/#module-rules\">module.rules</a></p>\n<pre><code class=\"language-javascript\">// ...\nmdoule: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [\n                { loader: 'style-loader' },\n                {\n                    loader: 'css-loader',\n                    options: { module: true }\n                }\n            ]\n        },\n        {\n            test: /\\.jsx$/,\n            loader: 'babel-loader',\n            options: {\n                // ...\n            }\n        }\n    ]\n}\n// ...\n</code></pre>\n"}},{node:{frontmatter:{title:"深入学习javascript-闭包",date:"2017-06-14",category:null,tags:null,path:"/post/js-closures"},excerpt:"\n# 什么是闭包\n记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。\n\n> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\n--- 你不知道的javascript（上卷）\n\n然后看个例子\n```javascript\nfunction foo() {\n\tvar a = 2;\n\n\tfuntion bar() {\n\t\tconsole.log(a);\n\t}\n\n\tbar();\n}\n\nfoo();\n```\n如果按上面第一条的定义，这里一定是生成了闭包，但是**确切的说并不是**，这里最准确的说是`bar`对`a`的引用方式是词法作用域的查找规则，而这些只是**闭包**的一部分。然后再看清晰闭包的例子\n\n```javascript\nfucntion foo() {\n\tvar a = 2;\n\n\tfunction bar() {\n\t\tconsole.log(a)\n\t}\n\n\treturn bar;\n}\n\nvar baz = foo()；\n\nbaz(); // 这就是闭包效果\n```\n\n",headings:[{depth:1,value:"什么是闭包"},{depth:1,value:"闭包与变量"},{depth:1,value:"模块"},{depth:2,value:"现代的模块机制"},{depth:1,value:"总结"}],html:"<h1>什么是闭包</h1>\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\n<blockquote>\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\n--- 你不知道的javascript（上卷）</p>\n</blockquote>\n<p>然后看个例子</p>\n<pre><code class=\"language-javascript\">function foo() {\n    var a = 2;\n\n    funtion bar() {\n        console.log(a);\n    }\n\n    bar();\n}\n\nfoo();\n</code></pre>\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\n<pre><code class=\"language-javascript\">fucntion foo() {\n    var a = 2;\n\n    function bar() {\n        console.log(a)\n    }\n\n    return bar;\n}\n\nvar baz = foo()；\n\nbaz(); // 这就是闭包效果\n</code></pre>\n<!-- more -->\n<p>在这例子中，<code>bar</code>也是在<code>foo</code>的作用域内，但是不是直接执行，而是作为返回值返回。\n<code>foo()</code>执行后，返回值<code>bar</code>赋值给<code>baz</code>并执行<code>baz()</code>，在这里，<code>bar()</code>显然可以正常执行，它在自己定义的词法作用域<strong>以外</strong>的地方。</p>\n<p>在<code>foo()</code>执行之后，按js的垃圾回收机制，应该会对其进行回收，而闭包的神奇之处就是可以阻止这事情发生，因此<code>baz()</code>在执行的时候依然可以访问<code>a</code>。在此一看，原来平时写的大多数代码都是闭包啊。</p>\n<pre><code class=\"language-javascript\">function foo() {\n    var a = 2;\n\n    function bar() {\n        console.log(a);\n    }\n\n    baz(bar);\n}\n\nfunction baz(fn) {\n    fn &#x26;&#x26; fn(); // 这里也是闭包\n}\n</code></pre>\n<h1>闭包与变量</h1>\n<p>要说明闭包，for循环也是一个很好的例子</p>\n<pre><code class=\"language-javascript\">for(var i = 1; i &#x3C;= 10; i++) {\n    setTimeout(function timer() {\n        console.log(i)\n    }, i * 1000)\n}\n</code></pre>\n<p>正常情况下，我们会预期的认为这段会每秒输出1～10，但实际，这段代码会<strong>每秒输出10次11</strong>。</p>\n<p>首先<strong>11</strong>是那里来的，这个循环应该是在<code>i=11</code>的时候符合终止条件，所以代码输出的是循环结束时<strong>i</strong>的最终值。</p>\n<p>细想一下，答案其实显而易见，<strong>setTimeout</strong>会推到栈底部执行，所以会在循环结束后才开始执行，所以每次都是输出<strong>11</strong>。但是什么问题造成这样的结果呢。</p>\n<p>虽然<strong>setTimeout</strong>都是在每个迭代时候分别定义的，但是根据作用域原理，其实几个函数都是都是<strong>保存在一个封闭的作用域中</strong>，因此它们引用都是同一个<strong>来自全局的i</strong>。</p>\n<p>所以解决方法也很简单，我们需要每次循环都新建一个作用域，然后把迭代的值传入作用域中，所以我们可以用<strong>IIFE</strong>（上一篇作用域有介绍，IIFE是一个匿名函数，每次调用都会创建作用域）来解决</p>\n<pre><code class=\"language-javascript\">for(var i = 1; i &#x3C;= 10; i++) {\n    (function(j) {\n        setTimeout(function timer() {\n            console.log(j)\n        }, j * 1000)\n    })(i)\n}\n\n// 换成ES6中的let也可以\nfor(let i = 1; i &#x3C;= 10; i++) {\n    setTimeout(function timer() {\n        console.log(i)\n    }, i * 1000)\n}\n</code></pre>\n<h1>模块</h1>\n<p>闭包除了平时实现的回调功能外，还可以实现另外一个强大的功能，<strong>模块</strong>。\n旧的模块实现方式，如jQuery就可以使用闭包实现</p>\n<pre><code class=\"language-javascript\">var $ = jQuery = (function Module(id) {\n    var a = 2;\n\n    function doSomething() {\n        console.log(a);\n    }\n\n    function identify1() {\n        console.log(id);\n    }\n\n    function identify2() {\n        console.log(id.toUpperCase());\n    }\n\n    function change() {\n        public.identify = identify2;\n    }\n\n    var public = {\n        doSomething: doSomething,\n        identify: identify1,\n        change: change\n    }\n\n    return public;\n})('hello')\n\n$.doSomething() // 2\n$.identify() // hello\n$.change()\n$.identify() // HELLO\n</code></pre>\n<p>如果不用单例的话不用<strong>IIFE</strong>即可，通过在模块内保留对公共API的引用，可以从<strong>内部</strong>对模块实例进行修改，包括添加，删除，修改属性或者方法。</p>\n<h2>现代的模块机制</h2>\n<p>现在大部分的模块加载器本质上都是将这种模块定义封装进API中，如下代码</p>\n<pre><code class=\"language-javascript\">var Module = (function Manager() {\n    var modules = {};\n\n    function define(name, deps, impl) {\n        for(var i = 0; i &#x3C; deps.length; i++) {\n            // 在modules中寻找名字为deps[i]的模块\n            deps[i] = modules[deps[i]];\n        }\n        // 将依赖的模块作为arguments传入module中\n        modules[name] = impl.apply(impl, deps);\n    }\n\n    function require(name) {\n        return modules[name];\n    }\n\n    return {\n        define: define,\n        require: require\n    }\n})()\n</code></pre>\n<p>这段代码核心在<code>module[name] = impl.apply(impl, deps)</code>中，模块都按名字保存在<code>modules</code>变量中，每次都能根据获取相关模块。下面看看使用方式。</p>\n<pre><code class=\"language-javascript\">Module.define('foo', [], function() {\n    function hello(who) {\n        return 'Hello ' + who;\n    }\n\n    return {\n        hello: hello\n    }\n})\n\nModule.define('bar', ['foo'], function(foo) {\n    function awsome() {\n        return foo.hello('kit').toUpperCase();\n    }\n\n    return {\n        awsome: awsome\n    }\n})\n\nvar foo = Module.require('foo'),\n    bar = Module.require('bar');\n\nfoo.hello('kit'); // Hello kit\nbar.awsome() // HELLO KIT\n</code></pre>\n<h1>总结</h1>\n<p>从上面可以知道，平时写的js大部分代码都使用了闭包，通过了解闭包和作用域的运行方式，能够减少平时使用的出现的错误。也能通过闭包，使用js实现模块化等其他更多的功能。</p>",htmlExcerpt:'<h1>什么是闭包</h1>\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\n<blockquote>\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\n--- 你不知道的javascript（上卷）</p>\n</blockquote>\n<p>然后看个例子</p>\n<pre><code class="language-javascript">function foo() {\n    var a = 2;\n\n    funtion bar() {\n        console.log(a);\n    }\n\n    bar();\n}\n\nfoo();\n</code></pre>\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\n<pre><code class="language-javascript">fucntion foo() {\n    var a = 2;\n\n    function bar() {\n        console.log(a)\n    }\n\n    return bar;\n}\n\nvar baz = foo()；\n\nbaz(); // 这就是闭包效果\n</code></pre>\n'}},{node:{frontmatter:{title:"用python写一个简单爬虫",date:"2017-06-11",category:null,tags:null,path:"/post/python-crawler"},excerpt:"\n之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。\n\n# 主要需求\n这个demo中爬虫有3个主要模块，**URL管理器**、**下载器**、**解析器**\n* URL管理器主要处理爬取的URL的状态。\n* 下载器会通过**URL管理器**传送过来有效URL进行下载。\n* 解析器会将**下载器**下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给**URL管理器**进行重复操作。\n\n## 入口程序\n`spider_main`文件为程序入口，处理整个爬虫的运行逻辑\n\n",headings:[{depth:1,value:"主要需求"},{depth:2,value:"入口程序"},{depth:2,value:"url管理器"},{depth:2,value:"下载器"},{depth:2,value:"解析器"},{depth:1,value:"总结"}],html:"<p>之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。</p>\n<h1>主要需求</h1>\n<p>这个demo中爬虫有3个主要模块，<strong>URL管理器</strong>、<strong>下载器</strong>、<strong>解析器</strong></p>\n<ul>\n<li>URL管理器主要处理爬取的URL的状态。</li>\n<li>下载器会通过<strong>URL管理器</strong>传送过来有效URL进行下载。</li>\n<li>解析器会将<strong>下载器</strong>下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给<strong>URL管理器</strong>进行重复操作。</li>\n</ul>\n<h2>入口程序</h2>\n<p><code>spider_main</code>文件为程序入口，处理整个爬虫的运行逻辑</p>\n<!-- more -->\n<pre><code class=\"language-python\">import url_manager, html_downloader, html_outputer, html_parser\nimport sys\n\nclass SpiderMain(object):\n    def __init__(self):\n        self.urls = url_manager.UrlManager()\n        self.downloder = html_downloader.HtmlDownloader()\n        self.parser = html_parser.HtmlParser()\n        self.outputer = html_outputer.HtmlOutputer()\n\n    def crawl(self, root_url):\n        count = 1\n        # 初始化原始的爬取地址\n        self.urls.add_new_ursl(root_url)\n\n        while self.urls.has_new_url():\n            try:\n                new_url = self.urls.get_new_url()\n                print 'crawl %d : %s' % (count, new_url)\n                html_cont = self.downloder.download(new_url)\n                new_urls, new_data = self.parser.parse(new_url, html_cont)\n\n                self.urls.add_new_urls(new_urls)\n                self.outputer.collect_data(new_data)\n\n                # 爬取的数据到1000条时跳出循环\n                if count == 1000:\n                    break\n\n                count = count + 1\n            except:\n                # 使用sys抛出其他函数错误\n                info=sys.exc_info()\n                print info[0],\":\",info[1]\n\n                print 'crawl failed'\n\n        # 将爬取的数据组装\n        self.outputer.output_html()\n\nif __name__ == '__main__':\n    root_url = 'http://baike.baidu.com/item/Python'\n    obj_spider = SpiderMain()\n    obj_spider.crawl(root_url)\n</code></pre>\n<h2>url管理器</h2>\n<pre><code class=\"language-python\"># url_manager.py\nclass UrlManager(object):\n    def __init__(self):\n        self.new_urls = set()\n        self.old_urls = set()\n\n    # 添加一条新的url\n    def add_new_url(self, url):\n        if url is None:\n            return\n\n        if url not in self.new_urls and url not in self.old_urls:\n            self.new_urls.add(url)\n\n    # 添加多条url\n    def add_new_urls(self, urls):\n        if urls is None and len(urls) == 0:\n            return\n\n        for url in urls:\n            self.add_new_url(url)\n\n    # 是否有代爬取地址\n    def has_new_url(self):\n        return len(self.new_urls) != 0\n\n    # 返回一条新的url\n    def get_new_url(self):\n        new_url = self.new_urls.pop()\n        self.old_urls.add(new_url)\n        return new_url\n</code></pre>\n<h2>下载器</h2>\n<p>下载器使用自带的<a href=\"https://docs.python.org/2/library/urllib2.html\">urllib2</a>库处理请求</p>\n<pre><code class=\"language-python\"># html_downloader.py\nimport urllib2\n\nclass HtmlDownloader(object):\n    def download(self, url):\n        if url is None:\n            return\n\n        # 这里设置一下超时，不然网络会使程序运行出现停止\n        response = urllib2.urlopen(url, timeout = 5)\n\n        # 请求失败时候跳出程序\n        if response.getcode() != 200:\n            return None\n\n        return response.read()\n</code></pre>\n<h2>解析器</h2>\n<p>解析器分为两部分，一个解析，一个输出，首先看看解析模块。</p>\n<p>解析html我们使用了<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\">beautifulsoup</a>，解析后可以使用库提供的方法做DOM操作，获取有用的信息</p>\n<pre><code class=\"language-python\"># html_parser.py\nfrom bs4 import BeautifulSoup\nimport re\nimport urlparse\n\nclass HtmlParser(object):\n    def _get_new_urls(self, page_url, soup):\n        new_urls = set()\n\n        # 获取a标签中所有匹配的url地址\n        links = soup.find_all('a', href=re.compile(r'/item/'))\n        for link in links:\n            new_url = link['href']\n            new_full_url = urlparse.urljoin(page_url, new_url)\n            new_urls.add(new_full_url)\n\n        return new_urls\n\n    def _get_new_data(self, page_url, soup):\n        res_data = {}\n\n        # 获取页面相关内容\n        res_data['url'] = page_url\n\n        # &#x3C;dd class=\"lemmaWgt-lemmaTitle-title\"> &#x3C;h1>Python&#x3C;/h1>\n        title_node = soup.find('dd', class_='lemmaWgt-lemmaTitle-title').find('h1')\n        res_data['title'] = title_node.get_text()\n\n        # &#x3C;div class=\"lemma-summary\" label-module=\"lemmaSummary\">\n        summary_node = soup.find('div', class_='lemma-summary')\n        res_data['summary'] = summary_node.get_text()\n\n        return res_data\n\n    def parse(self, page_url, html_cont):\n        if page_url is None or html_cont is None:\n            return\n\n        soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8')\n        new_urls = self._get_new_urls(page_url, soup)\n        new_data = self._get_new_data(page_url, soup)\n\n        return new_urls, new_data\n</code></pre>\n<pre><code class=\"language-python\"># html_outputer.py\nclass HtmlOutputer(object):\n    def __init__(self):\n        self.datas = []\n\n    # 获取到的页面内容对象push到数组中\n    def collect_data(self, data):\n        if data is None:\n            return\n\n        self.datas.append(data)\n\n    # 将数组循环拼接，写入html文件中\n    def output_html(self):\n        fout = open('output.html', 'w')\n\n        fout.write('&#x3C;html>')\n        fout.write('&#x3C;body>')\n        fout.write('&#x3C;table>')\n\n        for data in self.datas:\n            fout.write('&#x3C;tr>')\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['url'])\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['title'].encode('utf-8'))\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['summary'].encode('utf-8'))\n            fout.write('&#x3C;/tr>')\n\n        fout.write('&#x3C;/html>')\n        fout.write('&#x3C;/body>')\n        fout.write('&#x3C;/table>')\n</code></pre>\n<h1>总结</h1>\n<p>短短几行代码就实现了一个简单的爬虫，足以体现python的简单易用。学习python主要是想了解一下机器学习，后面会看一些书籍和资料，应该会再记录，但是后面估计会先写完深度学习javascript系列先。</p>",htmlExcerpt:"<p>之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。</p>\n<h1>主要需求</h1>\n<p>这个demo中爬虫有3个主要模块，<strong>URL管理器</strong>、<strong>下载器</strong>、<strong>解析器</strong></p>\n<ul>\n<li>URL管理器主要处理爬取的URL的状态。</li>\n<li>下载器会通过<strong>URL管理器</strong>传送过来有效URL进行下载。</li>\n<li>解析器会将<strong>下载器</strong>下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给<strong>URL管理器</strong>进行重复操作。</li>\n</ul>\n<h2>入口程序</h2>\n<p><code>spider_main</code>文件为程序入口，处理整个爬虫的运行逻辑</p>\n"}},{node:{frontmatter:{title:"深入学习javascript--作用域",date:"2017-05-31",category:null,tags:null,path:"/post/js-scope"},excerpt:"\n# 前言\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\n\n# 作用域是什么\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\n\n\n\n## 理解作用域执行过程\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\n\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\n\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\n\n",headings:[{depth:1,value:"前言"},{depth:1,value:"作用域是什么"},{depth:2,value:"理解作用域执行过程"},{
depth:3,value:"LSH和RSH查询"},{depth:2,value:"提升"},{depth:3,value:"函数优先"},{depth:2,value:"作用域嵌套"},{depth:1,value:"函数作用域"},{depth:1,value:"块作用域"},{depth:2,value:"延长作用域链(块作用域)"},{depth:1,value:"总结"}],html:'<h1>前言</h1>\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\n<h1>作用域是什么</h1>\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\n<h2>理解作用域执行过程</h2>\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。</p>\n<ol>\n<li>遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。</li>\n<li>接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</li>\n</ol>\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\n<!-- more -->\n<h3>LSH和RSH查询</h3>\n<p>定义一个变量<code>var a = 2</code>，或者执行一个简单的函数<code>console.log(2)</code>中，会同时或者单独出现<strong>LSH</strong>或者<strong>RSH</strong>查询。其实在作用域执行过程中，第一步就是LSH查询，第二步就是RSH查询，简单点来说</p>\n<ul>\n<li>LSH查询就是找到变量的容器本身</li>\n<li>RSH查询就是找到容器的原值</li>\n</ul>\n<pre><code class="language-javascript">// var a就是LSH\n// a = 2就是RSH\nvar a = 2;\n\n// 这里的a其实就是做了一个RSH查询\nconsole.log(a)\n</code></pre>\n<p>为什么需要理解这两个概念呢，因为在变量没有声明的情况下，这两种查询的行为是不一样的。</p>\n<pre><code class="language-javascript">function foo(a) {\n    console.log(a + b);\n    b = a;\n}\n\nfoo(2);\n</code></pre>\n<p>在第一次对b做RSH查询时候是无法找到该变量，所以引擎在这时候就会报出一个<code>ReferenceError</code>的错误。第二个b也还没有声明，但是引擎并没有报错，因为这里先做了LSH查询，所以可以知道，LSH查询如果未找到变量，会在全局中定义一个变量b（非严格模式下），再做RSH查询。引擎还有一个<code>TypeError</code>的错误，在试图对一个非函数类型的值执行函数调用，或者引用<code>null</code>, <code>undefined</code>类型值中的属性时候，就会报这个错误。</p>\n<h2>提升</h2>\n<p>很多时候都会认为javascript代码是由上到下一行一行执行的，但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p>\n<pre><code class="language-javascript">a = 2;\n\nvar a;\n\nconsole.log(a);  // 2\n</code></pre>\n<p>还有另外一段</p>\n<pre><code class="language-javascript">console.log(a); // undefined\n\nvar a = 2;\n</code></pre>\n<p>当js执行一个<code>var a = 2</code>的时候，这里并不是我们看到的一个声明，而是<code>var a</code>, <code>a = 2</code>两个声明，<code>var a</code>会在编译阶段执行，<code>a = 2</code>则会在执行阶段执行。所以第二段代码就很容易解释通了，代码执行顺序应该如下</p>\n<pre><code class="language-javascript">var a;\n\nconsole.log(a);\n\na = 2;\n</code></pre>\n<p>而这个函数声明自动移动到顶部，就叫做<strong>提升</strong>。</p>\n<p>提升操作会出现在<strong>每个作用域</strong>中，看以下代码</p>\n<pre><code class="language-javascript">foo();\n\nfunction foo() {\n    console.log(a);\n    var a = 2;\n}\n</code></pre>\n<p>实际执行如下</p>\n<pre><code class="language-javascript">function foo() {\n    var a;\n    console.log(a);\n    a = 2;\n}\n\nfoo();\n</code></pre>\n<p>可以看到，函数声明会被提升到最顶部，但是函数表达式却不会被提升</p>\n<pre><code>foo(); // TypeError\nbar(); // ReferenceError\n\nvar foo = function bar() {\n    ...\n}\n</code></pre>\n<p>在这里要注意，把foo分配到具名函数下，但是具名函数下也无法在所在作用域中运行。上面函数的执行方式应该如下</p>\n<pre><code class="language-javascript">var foo;\n\nfoo(); // TypeError\n\nbar(); // ReferenceError\n\nfoo = function() {\n    var bar = ... self ...\n}\n</code></pre>\n<h3>函数优先</h3>\n<p>从上面可以知道定义变量和声明函数都会触发提升，但是如果在重复声明的代码下，会出现什么情况呢</p>\n<pre><code class="language-javascript">foo(); // 1\n\nvar foo;\n\nfunction foo() {\n    console.log(1);\n}\n\nfoo = function() {\n    console.log(2);\n}\n</code></pre>\n<p>这里会出现<strong>1</strong>而不是<strong>2</strong>！因为函数会首先被提升，再到变量，所以执行顺序应该如下</p>\n<pre><code class="language-javascript">function foo() {\n    console.log(1);\n}\n\nfoo();\n\nfoo = function() {\n    console.log(2);\n}\n</code></pre>\n<p>在一个普通的块( { ... } 的代码)，函数也会提升，如下代码</p>\n<pre><code class="language-javascript">var a = true;\n\nif(a) {\n    function foo() {\n        ...\n    }\n}else {\n    function bar() {\n        ...\n    }\n}\n</code></pre>\n<p>这里的<code>foo</code>和<code>bar</code>都不会按判断来声明函数，所以在判断声明函数并不可靠。</p>\n<h2>作用域嵌套</h2>\n<p>当一个块或者函数嵌套在另一个块或者函数中，就称为作用域嵌套。在当前作用域没有找到某个变量时，<strong>引擎</strong>就会在外层的作用域继续查找，直到找到该变量，或者抵达最外层（全局）作用域为止。</p>\n<pre><code class="language-javascript">function foo(a) {\n    // b在函数中尚未定义，所以在上一个作用域中查找\n    // 在全局中找到变量b，赋值\n    console.log(a + b);\n}\n\nvar b = 2;\n\nfoo(2); // 4\n</code></pre>\n<h1>函数作用域</h1>\n<p>每个函数都有自己的执行环境，或者说函数有自己作用域。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而函数执行之后，栈将其环境弹出，把控制权返回之前的执行环境。函数作用域内的变量访问正是又这个执行机制控制着。而通过这一机制，能实现隐藏作用域中变量或者函数，规避同名标识符之间的冲突。</p>\n<pre><code class="language-javascript">function foo() {\n    function bar(a) {\n        // i会从for块中找到变量容器，然后执行赋值\n        i = 3;\n        console.log(a + i);\n    }\n\n    for(var i = 0; i &#x3C;= 10; i++) {\n        // 执行bar后会给i重新赋值3，满足i&#x3C;=10，函数死循环\n        bar(i * 2);\n    }\n}\n</code></pre>\n<p>这时候只需要在bar内部修改<code>i = 3</code>为<code>var i = 3</code>，将i变为<code>bar</code>中的本地变量即可。除了新建一个函数去隐藏变量，还能通过匿名函数的特性去实现隐藏变量，社区中也称为<strong>IIFE</strong>。</p>\n<pre><code class="language-javascript">var a = 2;\n\n(function() {\n    var a = 3;\n    console.log(a); // 3\n})()\n\nconsole.log(a); // 2\n</code></pre>\n<p>还能当作函数调用传参</p>\n<pre><code class="language-javascript">var a = 2;\n\n(function(global) {\n    var a = 3;\n\n    console.log(a); // 3\n    console.log(global.a); // 2\n})(window)\n</code></pre>\n<p>通过隐藏变量活着函数，能实现<strong>全局命名空间</strong>或者<strong>JS模块化</strong>(后面会讨论到)。</p>\n<h1>块作用域</h1>\n<p>在JS中块作用域并不常见，但是某些代码却经常会被误以为是块作用域，所以很容易造成理解上的错误，例如下面的常用代码</p>\n<pre><code class="language-javascript">for(var i = 0; i &#x3C; 10; i++) {\n    console.log(i);\n}\n\nif(true) {\n    var foo = \'bar\';\n}\n\nconsole.log(i, foo); // 10 bar\n</code></pre>\n<p>上面代码的<code>i</code>和<code>foo</code>其实都在外部作用域中定义的，而不是在代码块中定义的变量，所以平时在这些代码中定义变量应该是距离使用的地方越近越好。</p>\n<h2>延长作用域链(块作用域)</h2>\n<ul>\n<li>\n<p>with语句。with从对象中创建出来的对象只在with声明中有效。</p>\n<pre><code class="language-javascript">function foo() {\nvar qs = "?bar=true";\n\nwith(location) {\n    // href实际是location.href，只能在with内部使用\n    var url = href + qs;\n}\n\nreturn url;\n}\n</code></pre>\n</li>\n<li>\n<p>try/catch中的catch分句会创造一个块作用域，声明的错误对象变量仅在catch内部有效。</p>\n<pre><code class="language-javascript">try {\nundefined(); // 强制执行一个错误操作\n} catch(err) {\nconsole.log(err);\n}\n</code></pre>\n</li>\n</ul>\n<p>console.log(err); // ReferenceError</p>\n<pre><code>## let/const\n在ES6中，引入了let和const，提供了除var以外的另一种声明变量的方式。用let/const声明的变量会绑定在所在的所用域中（通常是{ ... }内部，换句话说，let/const能劫持所在作用域。\n```javascript\n// 修改下上面的循环例子\nfor(let i = 0; i &#x3C; 10; i++) {\n    console.log(i);\n}\n\nconsole.log(i); // ReferenceError\n</code></pre>\n<p>const在使用方法上跟len是一样，只是创建的值是固定的（常量）。后面任何修改值的操作都会报错。<strong>(注：const实际保证的并不是常量不能改变，而是变量的内存地址不能改变，所以对于复杂的类型object，也只能保证对象的指针地址是固定的，但是对象内部的数据结构则不能固定)</strong></p>\n<pre><code class="language-javascript">const foo = {};\n\nfoo.bar = \'bar\';\nconsole.log(foo.bar); // bar\n\nfoo = {}; // TypeError\n</code></pre>\n<h1>总结</h1>\n<p>通过学习js中的作用域运行方式，了解变量在执行环境的声明周期，以及哪部分代码能访问其中的变量。能为后面学习<strong>闭包</strong>还有实现模块化打下基础。以下是关于作用域的几点总结：</p>\n<ul>\n<li>函数局部环境不仅有访问函数作用域的变量的权限，而且还有权访问其包含(父)环境的变量。</li>\n<li>除全局、函数作用域外，还有比较少用的块作用域。</li>\n</ul>',htmlExcerpt:"<h1>前言</h1>\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\n<h1>作用域是什么</h1>\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\n<h2>理解作用域执行过程</h2>\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\n1. 遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\n2. 接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</p>\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\n"}},{node:{frontmatter:{title:"js实现add(1)(2)(3)",date:"2017-05-28",category:["javascript"],tags:null,path:"/post/add-chain"},excerpt:"\n# 题目\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现\n```javascript\nfunction add(x) {\n\tvar fn = function(y) {\n\t\treturn add(x + y);\n\t}\n\n\treturn fn;\n}\n\nconsole.log(add(1)(2)(3))\n```\n\n",headings:[{depth:1,value:"题目"},{depth:1,value:"实现方法"}],html:'<h1>题目</h1>\n<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现</p>\n<pre><code class="language-javascript">function add(x) {\n    var fn = function(y) {\n        return add(x + y);\n    }\n\n    return fn;\n}\n\nconsole.log(add(1)(2)(3))\n</code></pre>\n<!-- more -->\n<h1>实现方法</h1>\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\n<pre><code class="language-javascript">function add(x) {\n    var fn = function(y) {\n        return add(x + y);\n    }\n\n    fn.toString = function() {\n        return x;\n    }\n\n    return fn;\n}\n\n\n// chrome  function 6\n// firefox function add/fn\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\nconsole.log(add(1)(2)(3))\n\nconsole.log(add(1)(2)(3).toString()) // 6\n</code></pre>\n<p>由此看出在不同客户端下返回的结果并不一样，并不是完美的结果，但是查阅了其他资料并没有其他十分好的解决办法，估计这道题的考查点是关于js深度的，比如原生对象里面的基本方法和<code>alert</code>, <code>console</code>会自动执行toString等方法。</p>\n<p>另外，<code>valueOf</code>和<code>toString</code>方法其实是差不多的，返回的结果基本都是相同的，但是试了一下定义了两个不同的方法，发现总是会返回valueOf的值先，所以觉得toString应该是应用于valueOf的结果。</p>',htmlExcerpt:'<h1>题目</h1>\n<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现</p>\n<pre><code class="language-javascript">function add(x) {\n    var fn = function(y) {\n        return add(x + y);\n    }\n\n    return fn;\n}\n\nconsole.log(add(1)(2)(3))\n</code></pre>\n'}},{node:{frontmatter:{title:"Promise的简单实现",date:"2017-05-17",category:["前端"],tags:["javascript"],path:"/post/js-promise"},excerpt:"\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\n\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\n\n\n\n# 初步构建一个Promise\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\n```javascript\n// 例1\nfunction getAsyncData() {\n\treturn new Promise(function(resolve, reject) {\n\t\tsetTimeout(function() {\n\t\t\tresolve('promise done!')\n\t\t}, 1000)\n\t})\n}\n\ngetAsyncData().then(function(result) {\n\tconsole.log(result);\n}).then(function() {\n\tconsole.log('done too!');\n})\n```\n\n",headings:[{depth:1,value:"初步构建一个Promise"},{depth:1,value:"引入状态"},{depth:1,value:"串行promise"},{depth:1,value:"添加reject功能"},{depth:1,value:"总结"},{depth:2,value:"参考"}],html:"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\"https://promisesaplus.com/\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\n<h1>初步构建一个Promise</h1>\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\n<pre><code class=\"language-javascript\">// 例1\nfunction getAsyncData() {\n    return new Promise(function(resolve, reject) {\n        setTimeout(function() {\n            resolve('promise done!')\n        }, 1000)\n    })\n}\n\ngetAsyncData().then(function(result) {\n    console.log(result);\n}).then(function() {\n    console.log('done too!');\n})\n</code></pre>\n<!-- more -->\n<p><code>getAsyncData</code>函数中返回一个promise对象，然后通过<code>then</code>方法执行函数的回调，然后尝试实现一下这个基本的功能</p>\n<pre><code class=\"language-javascript\">// promise.js\nvar Primose = function(fn) {\n    var callbacks = [];\n\n    this.done = function(onFulfilled) {\n        this.callbacks.push(onFulfilled)\n\n        // 支持链式调用\n        return this;\n    }\n\n    function resolve(value) {\n        // push到队列的最底端，保证链式代码执行完后再执行方法\n        setTimeout(function() {\n            while(callbacks[0]) {\n                callbacks.shift()()\n            }\n        }, 0)\n    }\n\n    fn(resolve)\n}\n</code></pre>\n<p>到这里就完成了promise的基础功能，然后执行一下看下有没有达到预期情况:</p>\n<pre><code class=\"language-bash\">$node promise\npromise done!\ndone too!\n</code></pre>\n<p>乍看一下，怎么有点像lazyman(js中比较有名的题目，可以自行百度一下) ，看来平时多读书还是有好处的（手动滑稽）v</p>\n<h1>引入状态</h1>\n<p>这里我们可以先看下<a href=\"https://promisesaplus.com/#requirements\">promise状态规范</a></p>\n<p>promise必需在pending, fulfilled或者reject三个状态中的一个</p>\n<ul>\n<li>\n<p>当promise在pending状态中</p>\n<ul>\n<li>可以变为fulfilled或者reject状态</li>\n</ul>\n</li>\n<li>\n<p>当promise在fulfilled中</p>\n<ul>\n<li>不能过渡为其他状态</li>\n<li>必需返回一个值，并且不能改变</li>\n</ul>\n</li>\n<li>\n<p>当promise在reject中</p>\n<ul>\n<li>不能过渡为其他状态</li>\n<li>必需返回一个失败原因，并且不能改变</li>\n</ul>\n</li>\n</ul>\n<p>从这里可以看出，我们需要添加一个<code>status</code>变量保存状态，并且随着代码执行更新状态。</p>\n<pre><code class=\"language-javascript\">var Promise = function(fn) {\n    var state = 'pending',\n        value = null,\n        callbacks = [];\n\n    this.then = function(onFulfilled) {\n        if(state === 'pending') {\n            callbacks.push(onFulfilled);\n            return this;\n        }\n\n        onFulfilled(value);\n        return this;\n    }\n\n    function resolve(newValue) {\n        state = 'fulfilled';\n        value = newValue;\n\n        setTimeout(function() {\n            while(callbacks[0]) {\n                callbacks.shift()(value)\n            }\n        }, 0)\n    }\n\n    fn(resolve)\n}\n</code></pre>\n<h1>串行promise</h1>\n<p>在执行promise的时候，经常会在<code>then</code>的方法里面执行另外一个promise，<em>串联执行promise应该是promise里面最有趣并且是最核心的功能了</em>。</p>\n<p>串行promise指执行完一个异步函数达到fulfilled状态后，接着执行下一个promise，例如</p>\n<pre><code class=\"language-javascript\">// 接着例1\n\ngetAsyncData()\n    .then(getAsyncData2)\n    .then(function(data) {\n        console.log(data + 'done too!');\n    })\n\nfunction getAsyncData2(result) {\n    return new Promise(function(resolve, reject) {\n        setTimeout(function() {\n            resolve(result + 'next promise done!')\n        }, 1000)\n    })\n}\n</code></pre>\n<p>要实现这个功能，首先，我们，之前的<code>then</code>方法是直接把<code>this</code>返回出去，所以实现链式调用，执行起来的时候也扛扛的，没毛病，但如果then中执行下一个promise，这时候按上面的代码，应该是直接就return一个promise出去的，走不了下一步，所以<code>then</code>方法应该需要处理一下，promise的执行方式应该要变为：</p>\n<ol>\n<li>执行代码，将所有方法push到<code>callbacks</code>数组里面</li>\n<li>如果<code>then</code>中是一个promise，把剩下的<code>callbacks</code>提交到这个promise中执行</li>\n<li>再循环第一步</li>\n</ol>\n<pre><code class=\"language-javascript\">var Promise = function(fn) {\n    var state = 'pending',\n        // value = null,\n        callbacks = [];\n\n    this.then = function(onFulfilled) {\n        switch(state) {\n            case 'pending':\n                callbacks.push(onFulfilled)\n                return this;\n                break;\n            case 'fulfilled':\n                onFulfilled()\n                return this;\n                break;\n        }\n    }\n\n    function resolve(newValue) {\n        var value = newValue;\n        var temp = null;\n\n        setTimeout(function() {\n            state = 'fulfilled';\n            do {\n                temp = callbacks.shift()(value)\n                // 顺序执行数组，如果是resolve返回value\n                // 如果是promise则把后面的then方法提交到下个promise中执行\n                if(temp instanceof Promise) {\n                    while(callbacks[0]) {\n                        temp.then(callbacks.shift())\n                    }\n                    return;\n                }else {\n                    value = temp;\n                }\n            }while(callbacks[0])\n        }, 0)\n    }\n    fn(resolve)\n}\n</code></pre>\n<h1>添加reject功能</h1>\n<p>因为不确定then方法中是否会添加reject的处理，所以选用了一个比较笨的方法，加一个<code>errDerrers</code>的数组，每次执行不管有没有方法<code>then</code>都<code>push</code>到数组里面，<code>resolve</code>一个方法就<code>shift</code>一个，跟成功的回调一样，当reject的时候，判断下当前的方法是不是一个可执行函数，如果是的话则执行。至于catch的方法按这个思路暂时没想到，后面想到再更新。修改的地方都有添加注释。</p>\n<pre><code class=\"language-javascript\">var Promise = function(fn) {\n    var state = 'pending',\n        // value = null,\n        error = null,\n        errDeffers = [],\n        callbacks = [];\n\n    this.then = function(onFulfilled, rejected) {\n        switch(state) {\n            case 'pending':\n                callbacks.push(onFulfilled);\n                // 每次执行then都push一次\n                errDeffers.push(rejected);\n                return this;\n                break;\n            case 'fulfilled':\n                onFulfilled()\n                return this;\n                break;\n            // reject的话直接执行\n            case 'rejected':\n                rejected(error);\n                return this;\n                break;\n        }\n    }\n\n    this.catch = function(rejected) {\n        if(errDeffer === null) {\n            errDeffer = rejected;\n            return;\n        }\n    }\n\n    function resolve(newValue) {\n        var value = newValue;\n        var temp = null;\n\n        setTimeout(function() {\n            state = 'fulfilled';\n            do {\n                temp = callbacks.shift()(value);\n                errDeffers.shift();\n                // 顺序执行数组，如果是resolve返回value\n                // 如果是promise则把后面的then方法提交到下个promise中执行\n                if(temp instanceof Promise) {\n\n                    while(callbacks[0]) {\n                        // 成功的时候也要更新一下errDeffers数组\n                        temp.then(callbacks.shift(), errDeffers.shift())\n                    }\n\n                    return;\n                }else {\n                    value = temp;\n                }\n            }while(callbacks[0])\n        }, 0)\n    }\n\n    // reject方法\n    // 判断rejected是否一个函数，是的话执行，不是的话抛出一个错误\n    // reject也要提交到栈的最底端执行\n    function reject(err) {\n        setTimeout(function() {\n            state = 'rejected';\n            error = err;\n            var rejected = errDeffers.shift();\n\n            if(Object.prototype.toString.call(rejected) !== '[object Function]') {\n                throw new Error('Uncaught promise error!');\n                return;\n            }\n\n            rejected(error);\n        }, 0)\n    }\n\n    fn(resolve, reject)\n}\n</code></pre>\n<h1>总结</h1>\n<p>找资料的时候看到<a href=\"http://tech.meituan.com/promise-insight.html\">美团技术团队博客的实现方式</a>采用了另外一种解决方式解决串行promise，后面接着研究下，有兴趣也可以自行看下。\n实现promise应该有下面几个要点：</p>\n<ol>\n<li>函数的顺序执行</li>\n<li>处理好状态（这部分感觉我的方法跟promiseA的状态要求有点偏差）</li>\n<li>链式调用\n这个例子只是根据promise的执行方式实现大概的功能，后面或许会根据promise规范去实现一个比较规范的demo。</li>\n</ol>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://promisesaplus.com/#requirements\">Promises/A+</a></li>\n<li><a href=\"http://tech.meituan.com/promise-insight.html\">剖析 Promise 之基础篇</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\">Javascript异步编程的4种方法</a></li>\n</ul>",htmlExcerpt:"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\"https://promisesaplus.com/\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\n<h1>初步构建一个Promise</h1>\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\n<pre><code class=\"language-javascript\">// 例1\nfunction getAsyncData() {\n    return new Promise(function(resolve, reject) {\n        setTimeout(function() {\n            resolve('promise done!')\n        }, 1000)\n    })\n}\n\ngetAsyncData().then(function(result) {\n    console.log(result);\n}).then(function() {\n    console.log('done too!');\n})\n</code></pre>\n"}},{node:{frontmatter:{title:"前端单元测试&Mocha指北",date:"2017-05-16",category:["前端"],tags:null,path:"/post/unit-test"},excerpt:"\n# 什么是单元-测试?\n- 单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。\n- 而测试，就是测试啦。\n\n所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。\n\n# 为什么要写单元测试？\n单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。\n\n",headings:[{depth:1,value:"什么是单元-测试?"},{depth:1,value:"为什么要写单元测试？"},{depth:1,value:'干了这杯 "Mocha"'},{depth:2,value:"举个例子"},{depth:1,value:"小结"}],html:"<h1>什么是单元-测试?</h1>\n<ul>\n<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>\n<li>而测试，就是测试啦。</li>\n</ul>\n<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>\n<h1>为什么要写单元测试？</h1>\n<p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>\n<!-- more -->\n<h1>干了这杯 \"Mocha\"</h1>\n<p>mocha是一个js测试框架，除此外，类似的测试框架还有Jasmine、Karma、Tape等，至于为什么要介绍Mocha？因为我只懂这一个。\n上代码前还要普及一下两个概念</p>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91\">BDD（Behavior Driven Development）</a>\nBDD意为行为驱动开发，是一种敏捷软件开发技术，具体内容大家可以参考wikipedia的解释。</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)\">Assertion 断言</a>\n断言，就是判断代码的执行结果与预期是否一致，不一致就抛出错误，说得简单点就是判断程序的真假。</li>\n</ul>\n<h2>举个例子</h2>\n<pre><code class=\"language-javascript\">// add.js\nfunction add(a, b) {\n    return a + b\n}\nmodule.exports = add\n</code></pre>\n<p>通常测试脚本要与测试源码同名，比如add.js的测试脚本就是add.test.js</p>\n<pre><code class=\"language-javascript\">// add.test.js\nconst add = require('./add.js')\nconst expect = require('chai').expect\n\ndescribe('加法函数测试', function() {\n    it('1 + 1 等于 2', function() {\n        expect(add(1, 1)).to.be.equal(2)\n    })\n    it('返回值是Number', function() {\n        expect(add(1, 1)).to.be.a('number')\n    })\n})\n</code></pre>\n<p>上面代码块就是测试脚本，可独立运行，测试脚本中应该包括一个或多个<code>describe</code>块，每个<code>describe</code>块应包括多个<code>it</code>块。\n<code>describe</code>是测试套件，这个方法需要传两个参数，第一个为测试套件的名称<code>('加法函数测试')</code>，第二个是执行函数。\n<code>it</code>块是测试用例，表示一个单独的测试，是测试的最小单位，第一个参数是测试用例的名称('1 + 1 等于 2')，第二个是执行函数。</p>\n<p>然后在terminal下执行<code>mocha add.test.js</code></p>\n<pre><code class=\"language-terminal\">$ mocha add.test.js\n\n   加法函数测试\n     √ 1 + 1 等于 2\n     √ 返回值是Number\n   2 passing (12ms)\n</code></pre>\n<p>如果我们改变一下<code>add.js</code></p>\n<pre><code class=\"language-javascript\">// add.js\nfunction add(a, b) {\n    return a * b\n}\nmodule.exports = add\n</code></pre>\n<p>然后再执行一下<code>mocha add.test.js</code></p>\n<pre><code class=\"language-terminal\">$ mocha add.test.js\n\n   加法函数测试\n     √ 1 + 1 等于 2\n     1) 返回值是Number\n   1 passing (8ms)\n   1 failing\n\n   1) 加法函数测试 返回值是Number:\n       AssertionError: expected 2 to equal 3\n       + expected - actual\n\n       -2\n       +3\n\n       at Context.it(add.test.js:6:27)\n</code></pre>\n<p>这里也可以很明显看出哪个测试用例报错、还有报错的位置，这样在开发的时候开发人员就能很容易定位错误。</p>\n<h1>小结</h1>\n<p>从上面一个简单的例子可以看出，利用mocha实现自动化测试是很简单的。虽然前期开发需要花一点时间去写单元测试，但是后面提供的便利性足以将其弥补。</p>",htmlExcerpt:"<h1>什么是单元-测试?</h1>\n<ul>\n<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>\n<li>而测试，就是测试啦。</li>\n</ul>\n<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>\n<h1>为什么要写单元测试？</h1>\n<p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>\n"}},{node:{frontmatter:{title:"使用nodejs写一个命令行程序",date:"2017-05-16",category:["前端"],tags:["nodejs","bash"],path:"/post/node-command-app"},excerpt:'\n> 原文译自[Smashing Magazine](https://www.smashingmagazine.com/) -- [[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)\n\n相信很多前端都听说过或者使用过[Gulp](http://www.gulpjs.com.cn/), [Angular CLI](https://cli.angular.io/), [Cordova](https://cordova.apache.org/), [Yeoman](http://yeoman.io/)或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用`ng new <project-name>`后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。\n\n在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用[SendGrid Api](https://github.com/sendgrid/sendgrid-nodejs)模拟发送）\n文章目录：\n1."Hello World"\n2.处理命令行参数\n3.运行时输入参数\n4.模拟发送邮件\n5.改变输出内容样式\n6.变成shell命令\n\n',headings:[{depth:2,value:"“Hello World”"},{depth:2,value:"处理命令行参数"},{depth:2,value:"运行时输入参数"},{depth:2,value:"模拟发送邮件"},{depth:2,value:"变成shell命令"}],html:'<blockquote>\n<p>原文译自<a href="https://www.smashingmagazine.com/">Smashing Magazine</a> -- <a href="https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/">[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)</a></p>\n</blockquote>\n<p>相信很多前端都听说过或者使用过<a href="http://www.gulpjs.com.cn/">Gulp</a>, <a href="https://cli.angular.io/">Angular CLI</a>, <a href="https://cordova.apache.org/">Cordova</a>, <a href="http://yeoman.io/">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code>ng new &#x3C;project-name></code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>\n<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href="https://github.com/sendgrid/sendgrid-nodejs">SendGrid Api</a>模拟发送）\n文章目录：\n1."Hello World"\n2.处理命令行参数\n3.运行时输入参数\n4.模拟发送邮件\n5.改变输出内容样式\n6.变成shell命令</p>\n<!-- more -->\n<hr>\n<h2>“Hello World”</h2>\n<p>开始前，首先你得有node，如果没有，请自行安装下。node中自带npm，使用<a href="https://www.npmjs.com/">npm</a>能安装许多开源的node模块。首先，使用npm创建一个node项目</p>\n<pre><code class="language-shell">$ npm init\nname: broadcast\nversion: 0.0.1\ndescription: CLI utility to broadcast email\nentry point: broadcast.js\n</code></pre>\n<p>除这些参数外，npm还提供了其他如Git repository等参数，可根据自身需求设置输入。执行完<code>npm init</code>后，会发现在同目录下生成了一个<code>package.json</code>文件，文件里面包含了上面命令输入的信息。配置内容信息可以在<a href="https://docs.npmjs.com/files/package.json">package.json文档</a>中找到。</p>\n<p>然后，还是从最简单的Hello World入手。首先在同目录下建一个<code>broadcast.js</code>文件</p>\n<pre><code class="language-javascript">// broadcast.js\nconsole.log(\'Hello World!\')\n</code></pre>\n<p>然后在terminal中执行</p>\n<pre><code class="language-shell">$ node broadcast\nHello World!\n</code></pre>\n<p>well done, 根据<a href="https://docs.npmjs.com/files/package.json">package.json文档</a>，我们可以找到一个<code>dependencies</code>参数，在这参数中你可以找到所有这项目需要用到的第三方模块和它们的版本号，上面也有提及到，我们需要用到模块去开发这个工具。最后开发完成，<code>package.json</code>应该如下</p>\n<pre><code class="language-json">{\n    "name": "broadcast",\n    "version": "0.0.1",\n    "description": "CLI utility to broadcast emails",\n    "main": "broadcast.js",\n    "license": "MIT",\n    "dependencies": {\n        "chalk": "^1.1.3",\n        "commander": "^2.9.0",\n        "csv": "^1.1.0",\n        "inquirer": "^2.0.0"\n    }\n}\n</code></pre>\n<p>这几个模块 <a href="https://github.com/chalk/chalk">Chalk</a>, <a href="https://github.com/tj/commander.js">Commander</a>, <a href="https://github.com/sboudrias/Inquirer.js">Inquirer</a>, <a href="http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/">CSV</a>的具体用处跟其他参数，可以自行查看。</p>\n<h2>处理命令行参数</h2>\n<p>node原生也有读取命令行的函数<a href="https://nodejs.org/docs/latest/api/process.html"><code>process.argv</code></a>，但是解析参数是个繁琐的工作，所以我们会使用<a href="https://github.com/tj/commander.js">Commander</a>去替代这些工作。Commande的另外一个好处就是不用额外的去写一个<code>--help</code>函数，只要定义了其他参数，<code>--help</code>函数就会自动生成。首先安装一下Commander和其他package</p>\n<pre><code class="language-shell">$ npm install commander chalk csv inquirer --save\n</code></pre>\n<p>然后修改<code>broadcast.js</code></p>\n<pre><code class="language-javascript">// broadcast\nconst program = require(\'commander\')\n\nprogram\n    .version(\'0.0.1\')\n    .option(\'-l, --list [list]\', \'list of customers in CSV file\')\n    .parse(process.argv)\n\nconsole.log(program.list)\n</code></pre>\n<p>从上面可以看出，处理一个参数是十分简单的。我们定义了一个<code>--list</code>的参数，现在我们就能通过<code>--list</code>参数获取到命令行传过来的值。在这程序中，list应该是接收一个csv的地址参数，然后打印在console中。</p>\n<pre><code class="language-shell">$ node broadcast --list ./test.csv\n./test.csv\n</code></pre>\n<p>从js中可以看到还有一个<code>version</code>参数，所以我们可以使用<code>--version</code>读取版本号。</p>\n<pre><code class="language-shell">$ node broadcast --version\n0.0.1\n</code></pre>\n<p>又或者能使用<code>--help</code>获取app能接收的参数</p>\n<pre><code class="language-shell">$ node broadcast --help\n\n  Usage: broadcast [options]\n\n  Options:\n\n    -h, --help                 output usage information\n    -V, --version              output the version number\n    -l, --list &#x3C;list>          list of customers in CSV file\n</code></pre>\n<p>现在我们已经能够接收到命令行传递过来的参数了，下面我们会利用接收到的CSV文件地址，并使用<a href="http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/">CSV</a>模块处理CSV文件的内容。\n我们会使用下面的比哦啊哥内容作为CSV文件的内容。使用CSV模块，会读取内容，并显示各列的内容。</p>\n<table>\n<thead>\n<tr>\n<th>First name</th>\n<th>Last name</th>\n<th>Email</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Dwight</td>\n<td>Schrute</td>\n<td>dwight.schrute@dundermifflin.com</td>\n</tr>\n<tr>\n<td>Jim</td>\n<td>Halpert</td>\n<td>jim.halpert@dundermifflin.com</td>\n</tr>\n<tr>\n<td>Pam</td>\n<td>Beesly</td>\n<td>pam.beesly@dundermifflin.com</td>\n</tr>\n<tr>\n<td>Ryan</td>\n<td>Howard</td>\n<td>ryan.howard@dundermifflin.com</td>\n</tr>\n<tr>\n<td>Stanley</td>\n<td>Hudson</td>\n<td>stanley.hudson@dundermifflin.com</td>\n</tr>\n</tbody>\n</table>\n<p>现在，更新下<code>broadcast.js</code>，使用CSV读取内容并打印在console</p>\n<pre><code class="language-javascript">// broadcast.js\nconst program = require(\'commander\')\nconst csv = require(\'csv\')\nconst fs = require(\'fs\')\n\nprogram\n    .version(\'0.0.1\')\n    .option(\'-l, --list [list]\', \'List of customers in CSV\')\n    .parse(process.argv)\n\nconst stream = fs.createReadStream(program.list)\nstream\n    .pipe(csv.parse({ delimiter : "," }))\n    .on(\'data\', function(data) {\n         const firstname = data[0]\n         const lastname = data[1]\n         const email = data[2]\n\n         console.log(firstname, lastname, email)\n    })\n</code></pre>\n<p>除csv模块外，还使用了node的<a href="https://nodejs.org/dist/latest-v7.x/docs/api/fs.html">File System</a>模块读取文件内容，csv的<code>parse</code>方法把列数据解析为数组，然后在terminal中运行一下命令</p>\n<pre><code class="language-shell">$ node broadcast.js --list ./test.csv\nDwight Schrute dwight.schrute@dundermifflin.com\nJim Halpert jim.halpert@dundermifflin.com\nPam Beesly pam.beesly@dundermifflin.com\nRyan Howard ryan.howard@dundermifflin.com\nStanley Hudson stanley.hudson@dundermifflin.com\n</code></pre>\n<h2>运行时输入参数</h2>\n<p>上面已经实现了获取命令行参数，但如果想在运行时候接收参数值的话我们就需要另外一个模块<a href="https://github.com/sboudrias/Inquirer.js">inquirer.js</a>，通过这个模块，用户可以自定义多种参数类型，如文本，密码，单选或者多选列表等。</p>\n<p>下面的demo会通过inquirer接收邮件发送人的名字，email还有邮件主题。</p>\n<pre><code class="language-javascript">// broadcast.js\n...\nconst inquirer = require(\'inquirer\')\nconst questions = [\n  {\n    type : "input",\n    name : "sender.email",\n    message : "Sender\'s email address - "\n  },\n  {\n    type : "input",\n    name : "sender.name",\n    message : "Sender\'s name - "\n  },\n  {\n    type : "input",\n    name : "subject",\n    message : "Subject - "\n  }\n]\n\nprogram\n  .version(\'0.0.1\')\n  .option(\'-l, --list [list]\', \'List of customers in CSV\')\n  .parse(process.argv)\n\n// 储存CSV数据\nconst contactList = []\nconst stream = fs.createReadStream(program.list)\n    .pipe(csv.parse({ delimiter : "," }))\n\nstream\n  .on(\'error\', function (err) {\n    return console.error(err.message)\n  })\n  .on(\'data\', function (data) {\n    let name = data[0] + " " + data[1]\n    let email = data[2]\n    contactList.push({ name : name, email : email })\n  })\n  .on(\'end\', function () {\n    inquirer.prompt(questions).then(function (answers) {\n      console.log(answers)\n    })\n  })\n</code></pre>\n<p>Inquire.js的<code>prompt</code>方法接受一个数组参数，数组里可以自定义运行时需要接受的问题参数，在这demo里面，我们想知道发送者的名字还要email还有邮件主题，所以定义了一个<code>questions</code>的数组来储存问题，从对象里面可以看到有一个<code>input</code>的参数，除此外还可以接受<code>password</code>等其他类型，具体可以查询一下<a href="https://github.com/SBoudrias/Inquirer.js/">inquirer的文档</a>。此外，参数<code>name</code>保存input的key值。<code>prompt</code>方法会返还一个promise对象，promise中会返回一个<code>answer</code>变量，里面带有刚才输入的值。</p>\n<pre><code class="language-shell">$ node broadcast -l input/employees.csv\n? Sender\'s email address -  kitssang_demo@163.com\n? Sender\'s name -  kit\n? Subject - Hello World\n{ sender:\n   { email: \'  kitssang_demo@163.com\',\n     name: \'kit\' },\n  subject: \'Hello World\' }\n</code></pre>\n<h2>模拟发送邮件</h2>\n<p>由于原文使用的<code>sendgrid</code>没有跑通，所以只组装了一下数据模拟了发送邮件。原本的第五部分也在这里一起用上了。</p>\n<pre><code class="language-javascript">// broadcast.js\n...\nprogram\n    .version(\'0.0.1\')\n    .option(\'-l, --list [list]\', \'list of customers in CSV file\')\n    .parse(process.argv)\n\nconst sendEmail = function(to, from, subject) {\n    const sender = chalk.green(`${from.name}(${from.email})`)\n    const receiver = chalk.green(`${to.name}(${to.email})`)\n    const theme = chalk.blue(subject)\n\n    console.log(`${sender} send a mail to ${receiver} and the subject of the email is ${theme}`)\n}\n\n// 储存CSV数据\nlet concatList = []\nconst stream = fs.createReadStream(program.list)\n  .pipe(csv.parse({\n    delimiter: \',\'\n  }))\n  .on(\'data\', function(data) {\n    const name = data[0] + \' \' + data[1]\n    const email = data[2]\n\n    concatList.push({\n      name: name,\n      email: email\n    })\n  })\n  .on(\'end\', function() {\n    inquirer.prompt(questions).then((ans) => {\n      for (let i = 0; i &#x3C; concatList.length; i++) {\n        sendEmail(concatList[i], ans.sender, ans.subject)\n      }\n    }).catch((err) => {\n      console.log(err)\n    })\n  })\n</code></pre>\n<p>由于没有异步请求，<code>async</code>模块没有用上，另外使用了<code>chalk</code>模块改变了console打印结果的颜色。</p>\n<h2>变成shell命令</h2>\n<p>至此，整个工具已经基本完成，但是如果想像一个普通的shell命令(不加<code>$ node xx</code>)执行，还需要做以下操作。首先，添加<a href="https://zh.wikipedia.org/wiki/Shebang">shebang</a>在js的头部，让shell知道如何执行这个文件。</p>\n<pre><code class="language-javascript">#!/usr/bin/env node\n\n// broadcast.js\nconst program = require("commander")\nconst inquirer = require("inquirer")\n...\n</code></pre>\n<p>然后再配置一下<code>package.json</code>使代码可运行</p>\n<pre><code class="language-json">…\n  "description": "CLI utility to broadcast emails",\n  "main": "broadcast.js",\n  "bin" : {\n    "broadcast" : "./broadcast.js"\n  }\n…\n</code></pre>\n<p>从代码可以看到加了一个<a href="https://docs.npmjs.com/files/package.json#bin"><code>bin</code></a>的参数，这个参数可以使broadcast命令与broadcast.js建立连接。</p>\n<p>最后一步，在全局安装一下依赖包。在项目目录运行一下下面的命令。</p>\n<pre><code class="language-shell">$ npm install -g\n</code></pre>\n<p>然后测试一下命令</p>\n<pre><code class="language-shell">$ broadcast --help\n</code></pre>\n<p>需要注意的是，在开发时候如果使用<code>commaner</code>默认给出的命令执行<code>broadcast</code>则在代码中所做的任何更改都是看不见的。假如输入<code>which broadcast</code>，你会发现地址不是你当前目录，所以这时应该要用<code>npm link</code>去查看命令的目录映射。</p>',
htmlExcerpt:'<blockquote>\n<p>原文译自<a href="https://www.smashingmagazine.com/">Smashing Magazine</a> -- <a href="https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/">[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)</a></p>\n</blockquote>\n<p>相信很多前端都听说过或者使用过<a href="http://www.gulpjs.com.cn/">Gulp</a>, <a href="https://cli.angular.io/">Angular CLI</a>, <a href="https://cordova.apache.org/">Cordova</a>, <a href="http://yeoman.io/">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code>ng new &#x3C;project-name></code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>\n<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href="https://github.com/sendgrid/sendgrid-nodejs">SendGrid Api</a>模拟发送）\n文章目录：\n1."Hello World"\n2.处理命令行参数\n3.运行时输入参数\n4.模拟发送邮件\n5.改变输出内容样式\n6.变成shell命令</p>\n'}},{node:{frontmatter:{title:"React-todo demo",date:"2016-03-02",category:["js framework"],tags:["React","Webpack","js框架"],path:"/post/react-todo"},excerpt:"\n好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。\n\n### 小科普\n什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！\n\n",headings:[{depth:3,value:"小科普"},{depth:3,value:"Demo功能需求"},{depth:3,value:"开始"},{depth:4,value:"配置webpack"},{depth:4,value:"上代码"},{depth:4,value:"App生命 - state"},{depth:4,value:"其他组件"},{depth:3,value:"总结"}],html:'<p>好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。</p>\n<h3>小科普</h3>\n<p>什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！</p>\n<!-- more -->\n<h3>Demo功能需求</h3>\n<ul>\n<li>input输入内容，回车键或按钮增加一条todo</li>\n<li>checkbox添加完成状态</li>\n<li>移动到列表时显示删除</li>\n<li>显示todo总数和已经完成数</li>\n<li>list全选</li>\n<li>清除已完成</li>\n<li>添加动画效果</li>\n</ul>\n<h3>开始</h3>\n<p>开始需要npm安装一下等下要用的packages，如果是checkout我的demo，就动动手指头，install一下，我的demo地址是<a href="https://github.com/kitwon/react-todo">https://github.com/kitwon/react-todo</a></p>\n<pre><code class="language-bash">$npm install\n</code></pre>\n<h4>配置webpack</h4>\n<p>所有东西安装完成之后首先就是配置<a href="http://webpack.github.io/docs/">webpack</a></p>\n<pre><code class="language-javascript">var path = require(\'path\');\n\nmodule.exports = {\n    entry : "./src/entry.js",\n    output : {\n        path : path.join(__dirname, "out"),\n        publicPath : "./out/",\n        filename : "bundle.js"\n    },\n    externals : {\n        react : "React"\n    },\n    module : {\n        loaders : [\n            { test : /\\.js$/, loader : "jsx",include: /src/ },\n            { test : /\\.css$/, loader : "style!css" },\n            { test : /\\.less$/, loader : "style!css!less" },\n            { test : /\\.(jpg|png)$/, loader : "url?limit=8192" }\n        ]\n    }\n}\n</code></pre>\n<p>从上面可以看到，webpack的入口文件是entry.js，打包输出的文件是bundle.js，external属性是告诉webpack，当API已经存在的时候，使用全局变量，并不作任何操作。</p>\n<p>loader的话没啥，看文档就知道，各种编译打包。具体使用方法可以看官方文档。</p>\n<h4>上代码</h4>\n<pre><code class="language-javascript">var React = require(\'React\'),\n    ReactDOM = require(\'react-dom\');\n\nrequire(\'../less/app.less\');\n\nvar AppFooter = require(\'./AppFooter\'),\n    AppHeader = require(\'./AppHeader\'),\n    ItemMain = require(\'./ItemMain\');\n\n\nvar App = React.createClass ({\n    getInitialState : function() {\n        return {\n            todoItem : [],\n            isAllChecked : false\n        }\n    },\n    //添加todo\n    addItem : function(item) {\n        var todoList = this.state.todoItem.push(item);\n        this.setState({isAllChecked : false});\n        this.forceUpdate();\n    },\n     //更改todo状态\n    changeTodoState : function(index, isDone, isAllChange) {\n        // isAllChange = false;\n        if(isAllChange) {\n            this.setState({\n                todoItem: this.state.todoItem.map(function(todo) {\n                    todo.isDone = isDone;\n                    return todo;\n                }),\n                isAllChecked : isDone\n            })\n        }else {\n            this.state.todoItem[index].isDone = isDone;\n            this.allChecked();\n            this.forceUpdate();\n        }\n    },\n    //删除todo\n    deleteTodo : function(index) {\n        var newTodo = this.state.todoItem.splice(index, 1);\n        this.setState({todoList: newTodo});\n    },\n    //清楚已完成\n    clearDone : function() {\n        var doneList = this.state.todoItem.filter(function(item) {\n            return item.isDone === false;\n        })\n        this.setState({todoItem: doneList, isAllChecked: false});\n    },\n    //全部完成\n    allChecked : function() {\n        var allCheck = this.state.todoItem.every(function(item) {\n            return item.isDone === true;\n        })\n        if (allCheck) {\n            this.setState({isAllChecked : true})\n        };\n    },\n        render : function(){\n            var props = {\n                todoLength : this.state.todoItem.length || 0,\n                doneLength : this.state.todoItem.filter(function(item) {\n                    return item.isDone === true;\n                }).length || 0\n            };\n                return (\n                    &#x3C;div className="panel">\n                        &#x3C;header  className="mainHeader">&#x3C;h2>Webpack + React TODO Demo&#x3C;/h2>&#x3C;/header>\n                        &#x3C;AppHeader addItem={this.addItem}/>\n                        &#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\n                            &#x3C;AppFooter {...props} isAllChecked={this.state.isAllChecked} clearDone={this.clearDone} changeAllState={this.changeTodoState} />\n                    &#x3C;/div>\n                )\n        }\n})\n\nReactDOM.render(&#x3C;App/>, document.getElementById("app"));  //渲染\n</code></pre>\n<p>从代码上面可以看到各种require，没加载commonjs、seajs或其他模块化工具，为什么能直接require呢，而且还有require less，没错，webpack就是那么暴力！js后面都会打包好一个文件，样式都会加载到html里面，做spa时候，和react简直绝配。</p>\n<h4>App生命 - state</h4>\n<p>React主流思想就是父组件控制state，然后通过props传递给子组建，所以简单来说界面就像状态机，只要更新state，然后根据新的state重新渲染界面，不需要操作dom，所以react高性能原因也是因为这个。\n从最上代码就可以看出父组件中的定义的方法基本是整个todo的功能了，然后render方法即渲染html和组件。</p>\n<pre><code class="language-javascript">&#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\n</code></pre>\n<p>然后取一小段渲染组件代码（上面代码）就可发现，父组件向ItemMain这个组件传了4个属性，其中itemList为state，只要todoItem一更新，react就会重新渲染这个组件，其他三个为方法，方法更新也会重新渲染组件。</p>\n<pre><code class="language-javascript">// ItemMain.js\nvar React = require(\'React\');\nvar Items = require(\'./Items\');\n\nvar ItemMain = React.createClass({\n    render : function() {\n        var _this = this;\n        return (\n            &#x3C;section>\n                &#x3C;ul className="itemList">\n                    {_this.props.itemList.map(function (todo, index) {\n                        return (\n                            &#x3C;Items {...todo} key={index} index={index} {..._this.props} />\n                        )\n                    &#x3C;!-- })} -->\n                    &#x3C;!--这里不注释代码不高亮，比较奇葩，各位官人将就着看-->\n                &#x3C;/ul>\n            &#x3C;/section>\n        )\n    }\n})\n\nmodule.exports = ItemMain;\n</code></pre>\n<p>看这里估计有点蒙，我自己看的时候也有点蒙，因为太久的代码了哈哈哈。\n这个js只有一个循环Item的逻辑，首先看看<code>{...todo}</code>这个prop，这个是把itemList[i]中的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">数组对象解构</a>，然后传到item里面，如果没有...这个字符，则需要</p>\n<pre><code class="language-javascript">    &#x3C;Items text={props.text} isDone={props.isDone} key={index} index={index} changeTodoState={proprs.changeTodoState} deleteTodo={props.deleteTodo} />\n</code></pre>\n<p>具体数据大家可以在代码里面console打印一下，这样印象会更深。</p>\n<pre><code class="language-javascript">// item.js\nvar React = require(\'React\');\n\nvar Items = React.createClass({\n    handleChange : function() {\n        var isDone = !this.props.isDone;\n        this.props.changeTodoState(this.props.index, isDone);\n    },\n    handleDeleteTodo : function() {\n        this.props.deleteTodo(this.props.index);\n    },\n    render : function() {\n        var doneStyle = this.props.isDone ? {textDecoration: \'line-through\'} : {textDecoration : \'none\'};\n        return (\n            &#x3C;li key={this.props.key} onMouseOver={this.handlerMouseOver} onMouseOut={this.handlerMouseOut}>\n                &#x3C;input type="checkbox" checked={this.props.isDone} onChange={this.handleChange} />\n                &#x3C;span style={doneStyle}>{this.props.text}&#x3C;/span>\n                &#x3C;button className="btn btn-default delete-item" onClick={this.handleDeleteTodo}>delete&#x3C;/button>\n            &#x3C;/li>\n        )\n    }\n})\n\nmodule.exports = Items;\n</code></pre>\n<p>这个就是js里面有两个方法，一个是改变状态，一个是删除当前todo，这这能发现，两个方法都是执行了又父组件传过来的方法，如下</p>\n<pre><code class="language-javascript">this.props.changeTodoState(this.props.index, isDone);\n</code></pre>\n<p>执行这个函数，state就会更新，react就会根据状态重新渲染组件</p>\n<h4>其他组件</h4>\n<pre><code class="language-javascript">// AppHeader.js\nvar React = require(\'React\');\n\nvar AppHeader = React.createClass({\n    getInitialState : function() {\n        return {\n            text : ""\n        }\n    },\n    handlerKeyUp : function(event) {\n        if(event.keyCode === 13) {\n            var value = event.target.value;\n            if(!value) return false;\n\n            var newTodoItem = {\n                text : value,\n                isDone : false\n            }\n\n            event.target.value = "";\n            this.setState({text: ""});\n            this.props.addItem(newTodoItem);\n        }\n    },\n    handleChange : function(event) {\n        this.setState({text : event.target.value });\n    },\n    handlerClick : function(event) {\n        var newTodoItem = {\n            text : this.state.text,\n            isDone : false\n        }\n        this.props.addItem(newTodoItem);\n        this.setState({text: ""});\n    },\n    render : function() {\n        return (\n            &#x3C;section className="appHeader from-group">\n                &#x3C;input type="test" className="form-control" onKeyUp={this.handlerKeyUp} onChange={this.handleChange} placeholder="add one todo" value={this.state.text}/>\n                &#x3C;button className="btn btn-primary" onClick={this.handlerClick}>add one&#x3C;/button>\n            &#x3C;/section>\n        )\n    }\n})\n\nmodule.exports = AppHeader;\n</code></pre>\n<pre><code class="language-javascript">// AppHeader.js\nvar React = require(\'React\');\n\nvar AppFooter = React.createClass({\n    handleClick : function() {\n        this.props.clearDone();\n    },\n    handleAllState : function(event) {\n        this.props.changeAllState(null, event.target.value, true);\n    },\n    render : function() {\n        return (\n            &#x3C;section className="appFooter">\n                &#x3C;div>\n                    &#x3C;input type="checkbox" checked={this.props.isAllChecked} onChange={this.handleAllState}/>\n                    &#x3C;span>{this.props.doneLength}&#x3C;/span>已经完成 / &#x3C;span>{this.props.todoLength}&#x3C;/span>总数\n                &#x3C;/div>\n                &#x3C;button className="btn btn-default btn-tiny pull-right" onClick={this.handleClick}>clean done&#x3C;/button>\n            &#x3C;/section>\n        )\n    }\n})\n\nmodule.exports = AppFooter;\n</code></pre>\n<p>Header Footer的方法都是大同小异，输入改变state，然后存起来，执行相应操作时候通过props的方法传给父组件，然后重新渲染界面。</p>\n<h3>总结</h3>\n<p>回头看代码，react的组件化相比现在的组件化思想真的先进很多。React通过父组件来控制状态，并通过props传递给子组件。因此我们能很容易看出我们的事件属于哪个组件管理，然后修改相应的方法，维护起来相当高效，相比现在的控制dom，每次修改按钮的方法，都需要先找到id或者class，然后绑定响应的方法，假如页面id或者class改变，页面逻辑又非常复杂的话，修改起来是相当麻烦的。\nReact凭着出色的设计思想和性能，我相信不久就会成为主流的移动端开发方式，至于PC端，大天朝你懂的。</p>',htmlExcerpt:"<p>好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。</p>\n<h3>小科普</h3>\n<p>什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！</p>\n"}}],page:1,pages:1,total:14,limit:20}}}});
//# sourceMappingURL=path---archive-1-1575387d82d21d5f8de8.js.map