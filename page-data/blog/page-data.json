{"componentChunkName":"component---src-templates-blog-tsx","path":"/blog","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"excerpt":"<p>本文是Vue中3新的Composition API简单介绍及使用指南，具体内容可以自行阅读官方提供的<a href=\"https://vue-composition-api-rfc.netlify.com/#summary\">RFC</a>。</p>\n<p>附上分享PPT</p>\n<blockquote>\n<p>vue-composition-api slides — <a href=\"https://slides.com/kitwang/vue-composition-api/fullscreen\">https://slides.com/kitwang/vue-composition-api/fullscreen</a></p>\n</blockquote>\n<h2>Motivation</h2>\n<p>所有API都不是偶然设计出来的，所以作者的设计的时候必定有他的含义，我们先看看文档中提到的两个设计动机。</p>\n<ul>\n<li>逻辑复用及代码整理</li>\n<li>更好的Typescript支持</li>\n</ul>\n<p>像Vue这种现代框架已经很好解决了组件复用这一问题了，但是随着时间推移，你会发现组件里面的状态和逻辑也越来越多，越来越难维护，以一个普通的搜索组件为例，使用普通的语法就像下面的代码那样，用<code class=\"language-text\">data</code>定义组件的state，在<code class=\"language-text\">methods</code>里面定义组件的方法，看起来就像下面</p>\n","frontmatter":{"title":"Vue composition API 吃螃蟹指南","date":"2019-10-21","category":["前端"],"path":"/post/vue-composition-api"}}},{"node":{"excerpt":"<p>本文是对<a href=\"https://zhuanlan.zhihu.com/p/28113197?edition=yidianzixun&#x26;utm_source=yidianzixun&#x26;yidian_docid=0I3PuKjS\">《设计一个无懈可击的浏览器缓存》</a>文章的延伸，其中应该有以下两个系列的文章：</p>\n<ol>\n<li>Webpack生成能够持久缓存的分包配置</li>\n<li>使用Service Worker缓存资源支持离线访问</li>\n</ol>\n<p>现在大部分现代的前端工程里应该都会使用Webpack去构建项目。虽然Webpack十分强大，但也十分复杂，在不同场景，不同技术里配置都不一样，而且里面还包含很多的专业术语。所以在此文里，希望能帮助你:</p>\n<ul>\n<li>知道哪种种文件分割<strong>file-splitting</strong>策略最优于你的项目</li>\n<li>如何进行文件分割</li>\n</ul>\n","frontmatter":{"title":"使用Webpack设计一个所有项目适用的分包配置","date":"2019-09-06","category":["前端"],"path":"/post/webpack-bundle-design"}}},{"node":{"excerpt":"<p>阅读此文前建议先阅读下官方提供的文档<a href=\"https://ssr.vuejs.org/zh/\">Vue SSR指南</a>，并对以下工具有一定了解。</p>\n<blockquote>\n<p> <a href=\"https://cli.vuejs.org/\">Vue CLI</a> — Vue脚手架，生成vue应用模板</p>\n<p> <a href=\"https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F\">Vue SSR指南</a>  — 官方SSR教程及工具使用教程</p>\n<p><a href=\"https://webpack.js.org/\">Webpack</a> — 前端构建工具</p>\n<p><a href=\"https://koajs.com/\">Koa</a>  — 基于nodejs开发的网络框架</p>\n</blockquote>\n<p><a href=\"https://github.com/kitwon/vue-ssr-boilerplate\">👉🏻完整项目地址</a></p>\n<h2>Why do this</h2>\n<p>现在社区有很多如<a href=\"https://zh.nuxtjs.org/\">Nuxt.js</a>等框架或者插件，为什么还需要自己开发一个呢。首先自己开发能对工程细节有更好的控制，自定义程度更高，比如我需要在路由里面做一个优化点，或者需要结合redis做组件缓存。其次自己搭建能对框架有着更深入的理解，出现问题也能从容应对。</p>\n","frontmatter":{"title":"使用Koa + vue-cli3搭建SSR 开发环境","date":"2019-07-27","category":["前端"],"path":"/post/ssr-with-koa-and-vue"}}},{"node":{"excerpt":"<p>目前JavaScript开发者都会依赖很多如<em>Babel</em>、<em>Eslint</em>等工具去做开发，但会遇到一些小问题需要打下断点debugger一下的时候，这时我们就不知道这些工具里面是如何运作的，如何去做一个调试。 So，在此文章中我们会去学习这些工具内部是如何运作的。通过这篇文章，我们可以学习到：</p>\n<ol>\n<li>理解代码转换工具如Babel等是如何工作的。</li>\n<li>获得这些工具的调试能力。</li>\n<li>使用转换工具去重构现有代码。</li>\n</ol>\n<p>下面我们会通过两个小例子去解释这些工具是如何运作的，以及如何编写转换语法的代码。</p>\n<p>TODO:</p>\n<ul>\n<li>使用Babel-Plugin转换JavaScript代码 —— Babel</li>\n<li><em>code-mods</em>去重构现有的代码，如ES5 to ES6的代码 —— jscodeshift</li>\n</ul>\n","frontmatter":{"title":"What's AST & How AST","date":"2019-05-25","category":["javascript"],"path":"/post/what-and-how-ast"}}},{"node":{"excerpt":"<h1>Apollo GraphQL + Koa实例教程</h1>\n<blockquote>\n<p><a href=\"http://graphql.cn/learn/\">GraphQL 入门 | GraphQL</a> GraphQL中文文档</p>\n<p><a href=\"https://www.apollographql.com/\">Apollo GraphQL</a>, 实现GraphQL的引擎，大部分使用方法能从中查询</p>\n<p><a href=\"https://akryum.github.io/vue-apollo/zh-cn/\">Vue Apollo</a> 客户端中Vue GraphQL库，有一系列封装好的方法。</p>\n</blockquote>\n<p>两个个重要概念</p>\n<ul>\n<li><strong>Schema</strong>  即为GraphQL中的<code class=\"language-text\">types</code>(类型)，为服务中的核心，描述了服务端中提供给客户端可用的功能，或者说可查询的数据。</li>\n<li><strong>Resolver</strong> 在项目设计中是一个<code class=\"language-text\">map</code>对象，对象中的<code class=\"language-text\">key</code>和<strong>schema</strong>中<code class=\"language-text\">types</code>的字段是一对一的关系，描述了<code class=\"language-text\">types</code>中数据的来源。</li>\n</ul>\n<p>两个特殊类型\n每一个 GraphQL 服务都有一个query类型，可能有一个mutation类型。</p>\n<ul>\n<li><strong>Query</strong>里面定义了服务器提供给前端的一些可查询的类型，相当于以前的一个Restful接口，只有<em>Query</em>里的字段才能查询。</li>\n<li><strong>Mutation</strong>亦差不多，只是<strong>Mutation</strong>表示的是变更操作，如增删改这些接口操作。</li>\n</ul>\n","frontmatter":{"title":"Apollo GraphQL + Koa实例教程","date":"2019-03-15","category":["服务端"],"path":"/blog/use-graphql-with-apollo"}}},{"node":{"excerpt":"<p>作为一个程序员，想必每个都有自己的编码风格。有风格虽好，但这问题令很多项目管理者头疼，不一样的代码风格及缩进，必会降低代码可读性，从而间接降低效率。但是这个问题都难不到我们伟大的程序员，很多如eslint，prettier等库的出现帮我们去解决问题。很多cli在生成初始项目时都会给我们加上eslint、csslint等，这不就能解决我们的问题了吗？too young too simple，每保存一次就弹出一个错误，还是一大堆英文，估计大部分人心里就默默一句what the fuck is that了，从而就导致我们嘴上虽很强硬的说着要规范我们的代码风格，身体却很诚实地默默把各种lint的配置关掉🤷🏼‍。\n所以在这篇文章里，会给大家提供一些好用的方法，使各位重拾定规范时候的激情。</p>\n","frontmatter":{"title":"使用pre-commit实现提交前验证或自动部署代码","date":"2018-03-29","category":["前端"],"path":"/post/pre-commit-hook"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"limit":6,"skip":0,"numPages":4,"currentPage":1,"blogInfo":{"edgesCount":21}}}}