{"componentChunkName":"component---src-templates-blog-tsx","path":"/blog/3","webpackCompilationHash":"68b9148d1192a03e40a7","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"excerpt":"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\"https://promisesaplus.com/\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\n<h2>初步构建一个Promise</h2>\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 例1</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getAsyncData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"promise done!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">getAsyncData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"done too!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n","frontmatter":{"title":"Promise的简单实现","date":"2017-05-17","category":["前端"],"path":"/post/js-promise"}}},{"node":{"excerpt":"<h2>什么是单元-测试</h2>\n<ul>\n<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>\n<li>而测试，就是测试啦。</li>\n</ul>\n<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>\n<h2>为什么要写单元测试？</h2>\n<p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>\n","frontmatter":{"title":"前端单元测试&Mocha指北","date":"2017-05-16","category":["前端"],"path":"/post/unit-test"}}},{"node":{"excerpt":"<blockquote>\n<p>原文译自<a href=\"https://www.smashingmagazine.com/\">Smashing Magazine</a> -- <a href=\"https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/\">How To Develop An Interactive Command Line Application Using Node.js</a></p>\n</blockquote>\n<p>相信很多前端都听说过或者使用过<a href=\"http://www.gulpjs.com.cn/\">Gulp</a>, <a href=\"https://cli.angular.io/\">Angular CLI</a>, <a href=\"https://cordova.apache.org/\">Cordova</a>, <a href=\"http://yeoman.io/\">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code class=\"language-text\">ng new &lt;project-name&gt;</code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>\n<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href=\"https://github.com/sendgrid/sendgrid-nodejs\">SendGrid Api</a>模拟发送）\n文章目录：\n1.\"Hello World\"\n2.处理命令行参数\n3.运行时输入参数\n4.模拟发送邮件\n5.改变输出内容样式\n6.变成shell命令</p>\n","frontmatter":{"title":"使用nodejs写一个命令行程序","date":"2017-05-16","category":["前端"],"path":"/post/node-command-app"}}},{"node":{"excerpt":"<p>好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。</p>\n<h2>小科普</h2>\n<p>什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！</p>\n","frontmatter":{"title":"React-todo demo","date":"2016-03-02","category":["前端"],"path":"/post/react-todo"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"limit":6,"skip":12,"numPages":3,"currentPage":3,"blogInfo":{"edgesCount":16}}}}