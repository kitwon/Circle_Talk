{"version":3,"sources":["webpack:///path---post-js-scope-1c2b1868b6097e576c26.js","webpack:///./.cache/json/post-js-scope.json"],"names":["webpackJsonp","294","module","exports","data","markdownRemark","html","frontmatter","date","path","title","headings","depth","value","pathContext","prev","category","tags","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,i4NAAkrNC,aAAyQC,KAAA,eAAAC,KAAA,iBAAAC,MAAA,uBAA4EC,WAAcC,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,WAA6BD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,iBAAmCD,MAAA,EAAAC,MAAA,SAA0BC,aAAgBC,MAAQL,MAAA,iBAAAF,KAAA,aAAAQ,SAAA,KAAAC,KAAA,KAAAR,KAAA,wBAAuGS,MAASR,MAAA,mBAAAF,KAAA,aAAAQ,UAAA,cAAAC,KAAA,KAAAR,KAAA","file":"path---post-js-scope-1c2b1868b6097e576c26.js","sourcesContent":["webpackJsonp([258151503218682],{\n\n/***/ 294:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。</p>\\n<ol>\\n<li>遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。</li>\\n<li>接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</li>\\n</ol>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n<!-- more -->\\n<h3>LSH和RSH查询</h3>\\n<p>定义一个变量<code>var a = 2</code>，或者执行一个简单的函数<code>console.log(2)</code>中，会同时或者单独出现<strong>LSH</strong>或者<strong>RSH</strong>查询。其实在作用域执行过程中，第一步就是LSH查询，第二步就是RSH查询，简单点来说</p>\\n<ul>\\n<li>LSH查询就是找到变量的容器本身</li>\\n<li>RSH查询就是找到容器的原值</li>\\n</ul>\\n<pre><code class=\\\"language-javascript\\\">// var a就是LSH\\n// a = 2就是RSH\\nvar a = 2;\\n\\n// 这里的a其实就是做了一个RSH查询\\nconsole.log(a)\\n</code></pre>\\n<p>为什么需要理解这两个概念呢，因为在变量没有声明的情况下，这两种查询的行为是不一样的。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    console.log(a + b);\\n    b = a;\\n}\\n\\nfoo(2);\\n</code></pre>\\n<p>在第一次对b做RSH查询时候是无法找到该变量，所以引擎在这时候就会报出一个<code>ReferenceError</code>的错误。第二个b也还没有声明，但是引擎并没有报错，因为这里先做了LSH查询，所以可以知道，LSH查询如果未找到变量，会在全局中定义一个变量b（非严格模式下），再做RSH查询。引擎还有一个<code>TypeError</code>的错误，在试图对一个非函数类型的值执行函数调用，或者引用<code>null</code>, <code>undefined</code>类型值中的属性时候，就会报这个错误。</p>\\n<h2>提升</h2>\\n<p>很多时候都会认为javascript代码是由上到下一行一行执行的，但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p>\\n<pre><code class=\\\"language-javascript\\\">a = 2;\\n\\nvar a;\\n\\nconsole.log(a);  // 2\\n</code></pre>\\n<p>还有另外一段</p>\\n<pre><code class=\\\"language-javascript\\\">console.log(a); // undefined\\n\\nvar a = 2;\\n</code></pre>\\n<p>当js执行一个<code>var a = 2</code>的时候，这里并不是我们看到的一个声明，而是<code>var a</code>, <code>a = 2</code>两个声明，<code>var a</code>会在编译阶段执行，<code>a = 2</code>则会在执行阶段执行。所以第二段代码就很容易解释通了，代码执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var a;\\n\\nconsole.log(a);\\n\\na = 2;\\n</code></pre>\\n<p>而这个函数声明自动移动到顶部，就叫做<strong>提升</strong>。</p>\\n<p>提升操作会出现在<strong>每个作用域</strong>中，看以下代码</p>\\n<pre><code class=\\\"language-javascript\\\">foo();\\n\\nfunction foo() {\\n    console.log(a);\\n    var a = 2;\\n}\\n</code></pre>\\n<p>实际执行如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a;\\n    console.log(a);\\n    a = 2;\\n}\\n\\nfoo();\\n</code></pre>\\n<p>可以看到，函数声明会被提升到最顶部，但是函数表达式却不会被提升</p>\\n<pre><code>foo(); // TypeError\\nbar(); // ReferenceError\\n\\nvar foo = function bar() {\\n    ...\\n}\\n</code></pre>\\n<p>在这里要注意，把foo分配到具名函数下，但是具名函数下也无法在所在作用域中运行。上面函数的执行方式应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var foo;\\n\\nfoo(); // TypeError\\n\\nbar(); // ReferenceError\\n\\nfoo = function() {\\n    var bar = ... self ...\\n}\\n</code></pre>\\n<h3>函数优先</h3>\\n<p>从上面可以知道定义变量和声明函数都会触发提升，但是如果在重复声明的代码下，会出现什么情况呢</p>\\n<pre><code class=\\\"language-javascript\\\">foo(); // 1\\n\\nvar foo;\\n\\nfunction foo() {\\n    console.log(1);\\n}\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>这里会出现<strong>1</strong>而不是<strong>2</strong>！因为函数会首先被提升，再到变量，所以执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    console.log(1);\\n}\\n\\nfoo();\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>在一个普通的块( { ... } 的代码)，函数也会提升，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var a = true;\\n\\nif(a) {\\n    function foo() {\\n        ...\\n    }\\n}else {\\n    function bar() {\\n        ...\\n    }\\n}\\n</code></pre>\\n<p>这里的<code>foo</code>和<code>bar</code>都不会按判断来声明函数，所以在判断声明函数并不可靠。</p>\\n<h2>作用域嵌套</h2>\\n<p>当一个块或者函数嵌套在另一个块或者函数中，就称为作用域嵌套。在当前作用域没有找到某个变量时，<strong>引擎</strong>就会在外层的作用域继续查找，直到找到该变量，或者抵达最外层（全局）作用域为止。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    // b在函数中尚未定义，所以在上一个作用域中查找\\n    // 在全局中找到变量b，赋值\\n    console.log(a + b);\\n}\\n\\nvar b = 2;\\n\\nfoo(2); // 4\\n</code></pre>\\n<h1>函数作用域</h1>\\n<p>每个函数都有自己的执行环境，或者说函数有自己作用域。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而函数执行之后，栈将其环境弹出，把控制权返回之前的执行环境。函数作用域内的变量访问正是又这个执行机制控制着。而通过这一机制，能实现隐藏作用域中变量或者函数，规避同名标识符之间的冲突。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    function bar(a) {\\n        // i会从for块中找到变量容器，然后执行赋值\\n        i = 3;\\n        console.log(a + i);\\n    }\\n\\n    for(var i = 0; i &#x3C;= 10; i++) {\\n        // 执行bar后会给i重新赋值3，满足i&#x3C;=10，函数死循环\\n        bar(i * 2);\\n    }\\n}\\n</code></pre>\\n<p>这时候只需要在bar内部修改<code>i = 3</code>为<code>var i = 3</code>，将i变为<code>bar</code>中的本地变量即可。除了新建一个函数去隐藏变量，还能通过匿名函数的特性去实现隐藏变量，社区中也称为<strong>IIFE</strong>。</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function() {\\n    var a = 3;\\n    console.log(a); // 3\\n})()\\n\\nconsole.log(a); // 2\\n</code></pre>\\n<p>还能当作函数调用传参</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function(global) {\\n    var a = 3;\\n\\n    console.log(a); // 3\\n    console.log(global.a); // 2\\n})(window)\\n</code></pre>\\n<p>通过隐藏变量活着函数，能实现<strong>全局命名空间</strong>或者<strong>JS模块化</strong>(后面会讨论到)。</p>\\n<h1>块作用域</h1>\\n<p>在JS中块作用域并不常见，但是某些代码却经常会被误以为是块作用域，所以很容易造成理解上的错误，例如下面的常用代码</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nif(true) {\\n    var foo = 'bar';\\n}\\n\\nconsole.log(i, foo); // 10 bar\\n</code></pre>\\n<p>上面代码的<code>i</code>和<code>foo</code>其实都在外部作用域中定义的，而不是在代码块中定义的变量，所以平时在这些代码中定义变量应该是距离使用的地方越近越好。</p>\\n<h2>延长作用域链(块作用域)</h2>\\n<ul>\\n<li>\\n<p>with语句。with从对象中创建出来的对象只在with声明中有效。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\nvar qs = \\\"?bar=true\\\";\\n\\nwith(location) {\\n    // href实际是location.href，只能在with内部使用\\n    var url = href + qs;\\n}\\n\\nreturn url;\\n}\\n</code></pre>\\n</li>\\n<li>\\n<p>try/catch中的catch分句会创造一个块作用域，声明的错误对象变量仅在catch内部有效。</p>\\n<pre><code class=\\\"language-javascript\\\">try {\\nundefined(); // 强制执行一个错误操作\\n} catch(err) {\\nconsole.log(err);\\n}\\n</code></pre>\\n</li>\\n</ul>\\n<p>console.log(err); // ReferenceError</p>\\n<pre><code>## let/const\\n在ES6中，引入了let和const，提供了除var以外的另一种声明变量的方式。用let/const声明的变量会绑定在所在的所用域中（通常是{ ... }内部，换句话说，let/const能劫持所在作用域。\\n```javascript\\n// 修改下上面的循环例子\\nfor(let i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nconsole.log(i); // ReferenceError\\n</code></pre>\\n<p>const在使用方法上跟len是一样，只是创建的值是固定的（常量）。后面任何修改值的操作都会报错。<strong>(注：const实际保证的并不是常量不能改变，而是变量的内存地址不能改变，所以对于复杂的类型object，也只能保证对象的指针地址是固定的，但是对象内部的数据结构则不能固定)</strong></p>\\n<pre><code class=\\\"language-javascript\\\">const foo = {};\\n\\nfoo.bar = 'bar';\\nconsole.log(foo.bar); // bar\\n\\nfoo = {}; // TypeError\\n</code></pre>\\n<h1>总结</h1>\\n<p>通过学习js中的作用域运行方式，了解变量在执行环境的声明周期，以及哪部分代码能访问其中的变量。能为后面学习<strong>闭包</strong>还有实现模块化打下基础。以下是关于作用域的几点总结：</p>\\n<ul>\\n<li>函数局部环境不仅有访问函数作用域的变量的权限，而且还有权访问其包含(父)环境的变量。</li>\\n<li>除全局、函数作用域外，还有比较少用的块作用域。</li>\\n</ul>\",\"frontmatter\":{\"date\":\"May 31, 2017\",\"path\":\"/post/js-scope\",\"title\":\"深入学习javascript--作用域\"},\"headings\":[{\"depth\":1,\"value\":\"前言\"},{\"depth\":1,\"value\":\"作用域是什么\"},{\"depth\":2,\"value\":\"理解作用域执行过程\"},{\"depth\":3,\"value\":\"LSH和RSH查询\"},{\"depth\":2,\"value\":\"提升\"},{\"depth\":3,\"value\":\"函数优先\"},{\"depth\":2,\"value\":\"作用域嵌套\"},{\"depth\":1,\"value\":\"函数作用域\"},{\"depth\":1,\"value\":\"块作用域\"},{\"depth\":2,\"value\":\"延长作用域链(块作用域)\"},{\"depth\":1,\"value\":\"总结\"}]}},\"pathContext\":{\"prev\":{\"title\":\"用python写一个简单爬虫\",\"date\":\"2017-06-11\",\"category\":null,\"tags\":null,\"path\":\"/post/python-crawler\"},\"next\":{\"title\":\"js实现add(1)(2)(3)\",\"date\":\"2017-05-28\",\"category\":[\"javascript\"],\"tags\":null,\"path\":\"/post/add-chain\"}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---post-js-scope-1c2b1868b6097e576c26.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。</p>\\n<ol>\\n<li>遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。</li>\\n<li>接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</li>\\n</ol>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n<!-- more -->\\n<h3>LSH和RSH查询</h3>\\n<p>定义一个变量<code>var a = 2</code>，或者执行一个简单的函数<code>console.log(2)</code>中，会同时或者单独出现<strong>LSH</strong>或者<strong>RSH</strong>查询。其实在作用域执行过程中，第一步就是LSH查询，第二步就是RSH查询，简单点来说</p>\\n<ul>\\n<li>LSH查询就是找到变量的容器本身</li>\\n<li>RSH查询就是找到容器的原值</li>\\n</ul>\\n<pre><code class=\\\"language-javascript\\\">// var a就是LSH\\n// a = 2就是RSH\\nvar a = 2;\\n\\n// 这里的a其实就是做了一个RSH查询\\nconsole.log(a)\\n</code></pre>\\n<p>为什么需要理解这两个概念呢，因为在变量没有声明的情况下，这两种查询的行为是不一样的。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    console.log(a + b);\\n    b = a;\\n}\\n\\nfoo(2);\\n</code></pre>\\n<p>在第一次对b做RSH查询时候是无法找到该变量，所以引擎在这时候就会报出一个<code>ReferenceError</code>的错误。第二个b也还没有声明，但是引擎并没有报错，因为这里先做了LSH查询，所以可以知道，LSH查询如果未找到变量，会在全局中定义一个变量b（非严格模式下），再做RSH查询。引擎还有一个<code>TypeError</code>的错误，在试图对一个非函数类型的值执行函数调用，或者引用<code>null</code>, <code>undefined</code>类型值中的属性时候，就会报这个错误。</p>\\n<h2>提升</h2>\\n<p>很多时候都会认为javascript代码是由上到下一行一行执行的，但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p>\\n<pre><code class=\\\"language-javascript\\\">a = 2;\\n\\nvar a;\\n\\nconsole.log(a);  // 2\\n</code></pre>\\n<p>还有另外一段</p>\\n<pre><code class=\\\"language-javascript\\\">console.log(a); // undefined\\n\\nvar a = 2;\\n</code></pre>\\n<p>当js执行一个<code>var a = 2</code>的时候，这里并不是我们看到的一个声明，而是<code>var a</code>, <code>a = 2</code>两个声明，<code>var a</code>会在编译阶段执行，<code>a = 2</code>则会在执行阶段执行。所以第二段代码就很容易解释通了，代码执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var a;\\n\\nconsole.log(a);\\n\\na = 2;\\n</code></pre>\\n<p>而这个函数声明自动移动到顶部，就叫做<strong>提升</strong>。</p>\\n<p>提升操作会出现在<strong>每个作用域</strong>中，看以下代码</p>\\n<pre><code class=\\\"language-javascript\\\">foo();\\n\\nfunction foo() {\\n    console.log(a);\\n    var a = 2;\\n}\\n</code></pre>\\n<p>实际执行如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a;\\n    console.log(a);\\n    a = 2;\\n}\\n\\nfoo();\\n</code></pre>\\n<p>可以看到，函数声明会被提升到最顶部，但是函数表达式却不会被提升</p>\\n<pre><code>foo(); // TypeError\\nbar(); // ReferenceError\\n\\nvar foo = function bar() {\\n    ...\\n}\\n</code></pre>\\n<p>在这里要注意，把foo分配到具名函数下，但是具名函数下也无法在所在作用域中运行。上面函数的执行方式应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var foo;\\n\\nfoo(); // TypeError\\n\\nbar(); // ReferenceError\\n\\nfoo = function() {\\n    var bar = ... self ...\\n}\\n</code></pre>\\n<h3>函数优先</h3>\\n<p>从上面可以知道定义变量和声明函数都会触发提升，但是如果在重复声明的代码下，会出现什么情况呢</p>\\n<pre><code class=\\\"language-javascript\\\">foo(); // 1\\n\\nvar foo;\\n\\nfunction foo() {\\n    console.log(1);\\n}\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>这里会出现<strong>1</strong>而不是<strong>2</strong>！因为函数会首先被提升，再到变量，所以执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    console.log(1);\\n}\\n\\nfoo();\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>在一个普通的块( { ... } 的代码)，函数也会提升，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var a = true;\\n\\nif(a) {\\n    function foo() {\\n        ...\\n    }\\n}else {\\n    function bar() {\\n        ...\\n    }\\n}\\n</code></pre>\\n<p>这里的<code>foo</code>和<code>bar</code>都不会按判断来声明函数，所以在判断声明函数并不可靠。</p>\\n<h2>作用域嵌套</h2>\\n<p>当一个块或者函数嵌套在另一个块或者函数中，就称为作用域嵌套。在当前作用域没有找到某个变量时，<strong>引擎</strong>就会在外层的作用域继续查找，直到找到该变量，或者抵达最外层（全局）作用域为止。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    // b在函数中尚未定义，所以在上一个作用域中查找\\n    // 在全局中找到变量b，赋值\\n    console.log(a + b);\\n}\\n\\nvar b = 2;\\n\\nfoo(2); // 4\\n</code></pre>\\n<h1>函数作用域</h1>\\n<p>每个函数都有自己的执行环境，或者说函数有自己作用域。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而函数执行之后，栈将其环境弹出，把控制权返回之前的执行环境。函数作用域内的变量访问正是又这个执行机制控制着。而通过这一机制，能实现隐藏作用域中变量或者函数，规避同名标识符之间的冲突。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    function bar(a) {\\n        // i会从for块中找到变量容器，然后执行赋值\\n        i = 3;\\n        console.log(a + i);\\n    }\\n\\n    for(var i = 0; i &#x3C;= 10; i++) {\\n        // 执行bar后会给i重新赋值3，满足i&#x3C;=10，函数死循环\\n        bar(i * 2);\\n    }\\n}\\n</code></pre>\\n<p>这时候只需要在bar内部修改<code>i = 3</code>为<code>var i = 3</code>，将i变为<code>bar</code>中的本地变量即可。除了新建一个函数去隐藏变量，还能通过匿名函数的特性去实现隐藏变量，社区中也称为<strong>IIFE</strong>。</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function() {\\n    var a = 3;\\n    console.log(a); // 3\\n})()\\n\\nconsole.log(a); // 2\\n</code></pre>\\n<p>还能当作函数调用传参</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function(global) {\\n    var a = 3;\\n\\n    console.log(a); // 3\\n    console.log(global.a); // 2\\n})(window)\\n</code></pre>\\n<p>通过隐藏变量活着函数，能实现<strong>全局命名空间</strong>或者<strong>JS模块化</strong>(后面会讨论到)。</p>\\n<h1>块作用域</h1>\\n<p>在JS中块作用域并不常见，但是某些代码却经常会被误以为是块作用域，所以很容易造成理解上的错误，例如下面的常用代码</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nif(true) {\\n    var foo = 'bar';\\n}\\n\\nconsole.log(i, foo); // 10 bar\\n</code></pre>\\n<p>上面代码的<code>i</code>和<code>foo</code>其实都在外部作用域中定义的，而不是在代码块中定义的变量，所以平时在这些代码中定义变量应该是距离使用的地方越近越好。</p>\\n<h2>延长作用域链(块作用域)</h2>\\n<ul>\\n<li>\\n<p>with语句。with从对象中创建出来的对象只在with声明中有效。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\nvar qs = \\\"?bar=true\\\";\\n\\nwith(location) {\\n    // href实际是location.href，只能在with内部使用\\n    var url = href + qs;\\n}\\n\\nreturn url;\\n}\\n</code></pre>\\n</li>\\n<li>\\n<p>try/catch中的catch分句会创造一个块作用域，声明的错误对象变量仅在catch内部有效。</p>\\n<pre><code class=\\\"language-javascript\\\">try {\\nundefined(); // 强制执行一个错误操作\\n} catch(err) {\\nconsole.log(err);\\n}\\n</code></pre>\\n</li>\\n</ul>\\n<p>console.log(err); // ReferenceError</p>\\n<pre><code>## let/const\\n在ES6中，引入了let和const，提供了除var以外的另一种声明变量的方式。用let/const声明的变量会绑定在所在的所用域中（通常是{ ... }内部，换句话说，let/const能劫持所在作用域。\\n```javascript\\n// 修改下上面的循环例子\\nfor(let i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nconsole.log(i); // ReferenceError\\n</code></pre>\\n<p>const在使用方法上跟len是一样，只是创建的值是固定的（常量）。后面任何修改值的操作都会报错。<strong>(注：const实际保证的并不是常量不能改变，而是变量的内存地址不能改变，所以对于复杂的类型object，也只能保证对象的指针地址是固定的，但是对象内部的数据结构则不能固定)</strong></p>\\n<pre><code class=\\\"language-javascript\\\">const foo = {};\\n\\nfoo.bar = 'bar';\\nconsole.log(foo.bar); // bar\\n\\nfoo = {}; // TypeError\\n</code></pre>\\n<h1>总结</h1>\\n<p>通过学习js中的作用域运行方式，了解变量在执行环境的声明周期，以及哪部分代码能访问其中的变量。能为后面学习<strong>闭包</strong>还有实现模块化打下基础。以下是关于作用域的几点总结：</p>\\n<ul>\\n<li>函数局部环境不仅有访问函数作用域的变量的权限，而且还有权访问其包含(父)环境的变量。</li>\\n<li>除全局、函数作用域外，还有比较少用的块作用域。</li>\\n</ul>\",\"frontmatter\":{\"date\":\"May 31, 2017\",\"path\":\"/post/js-scope\",\"title\":\"深入学习javascript--作用域\"},\"headings\":[{\"depth\":1,\"value\":\"前言\"},{\"depth\":1,\"value\":\"作用域是什么\"},{\"depth\":2,\"value\":\"理解作用域执行过程\"},{\"depth\":3,\"value\":\"LSH和RSH查询\"},{\"depth\":2,\"value\":\"提升\"},{\"depth\":3,\"value\":\"函数优先\"},{\"depth\":2,\"value\":\"作用域嵌套\"},{\"depth\":1,\"value\":\"函数作用域\"},{\"depth\":1,\"value\":\"块作用域\"},{\"depth\":2,\"value\":\"延长作用域链(块作用域)\"},{\"depth\":1,\"value\":\"总结\"}]}},\"pathContext\":{\"prev\":{\"title\":\"用python写一个简单爬虫\",\"date\":\"2017-06-11\",\"category\":null,\"tags\":null,\"path\":\"/post/python-crawler\"},\"next\":{\"title\":\"js实现add(1)(2)(3)\",\"date\":\"2017-05-28\",\"category\":[\"javascript\"],\"tags\":null,\"path\":\"/post/add-chain\"}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/post-js-scope.json\n// module id = 294\n// module chunks = 258151503218682"],"sourceRoot":""}