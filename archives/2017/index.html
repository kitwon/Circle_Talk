<!DOCTYPE html><html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0,  user-scalable=0" name="viewport"><title>KIT</title><link rel="stylesheet" href="/css/index.min.css"></head><body><nav class="nav-button-list"><div class="btn menu show-canvas"><span class="icon-bar"></span></div><div class="btn top btn-go-top"><i class="ion-ios-arrow-up"></i></div></nav><div class="off-canvas-wrap"><div class="off-canvas-content"><header class="header-content"><div class="header-box"><h1>kit.c</h1><h2>宝贝，来看看朕为你打下的江山</h2><div class="banner-menu"><ul><li><a href=""><i class="ion ion-ios-home"></i><span>首页</span></a></li><li class="unopen"><a href=""><i class="ion ion-ios-bookmarks"></i><span>归档</span></a></li><li class="unopen"><a href=""><i class="ion ion-ios-pricetags"></i><span>标签</span></a></li></ul></div></div></header><div class="wrap translate-wrap"><div class="white-container"><div class="container"><div class="row"><div class="col-md-12 content"><article class="post"><header class="header"><h3><a href="/2017/06/14/深入学习javascript-闭包/">深入学习javascript-闭包</a></h3></header><section class="info"><a href="/categories/javascript/">javascript</a><span class="dot-sep"></span><time>Jun 14, 2017</time></section><section class="excerpt"><h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>
<blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。<br>— 你不知道的javascript（上卷）</p>
</blockquote></section><a href="/2017/06/14/深入学习javascript-闭包/" class="readmore">read more</a></article><article class="post"><header class="header"><h3><a href="/2017/06/11/用python写一个简单爬虫/">用python写一个简单爬虫</a></h3></header><section class="info"><a href="/categories/python/">python</a><span class="dot-sep"></span><time>Jun 11, 2017</time></section><section class="excerpt"><p>之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。</p>
<h1 id="主要需求"><a href="#主要需求" class="headerlink" title="主要需求"></a>主要需求</h1><p>这个demo中爬虫有3个主要模块，<strong>URL管理器</strong>、<strong>下载器</strong>、<strong>解析器</strong></p>
<ul>
<li>URL管理器主要处理爬取的URL的状态。</li>
<li>下载器会通过<strong>URL管理器</strong>传送过来有效URL进行下载。</li>
<li>解析器会将<strong>下载器</strong>下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给<strong>URL管理器</strong>进行重复操作。</li>
</ul></section><a href="/2017/06/11/用python写一个简单爬虫/" class="readmore">read more</a></article><article class="post"><header class="header"><h3><a href="/2017/05/31/深入学习javascript-作用域/">深入学习javascript--作用域</a></h3></header><section class="info"><a href="/categories/javascript/">javascript</a><span class="dot-sep"></span><time>May 31, 2017</time></section><section class="excerpt"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>
<h1 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h1><p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p></section><a href="/2017/05/31/深入学习javascript-作用域/" class="readmore">read more</a></article><article class="post"><header class="header"><h3><a href="/2017/05/28/js实现add(1)(2)(3)/">js实现add(1)(2)(3)</a></h3></header><section class="info"><a href="/categories/javascript/">javascript</a><span class="dot-sep"></span><time>May 28, 2017</time></section><section class="excerpt"><p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。<br>当时第一反应就是用递归实现</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function add(x) {
    var fn = function(y) {
        return add(x + y);
    }

    return fn;
}

console.log(add(1)(2)(3))
</code></pre></section><a href="/2017/05/28/js实现add(1)(2)(3)/" class="readmore">read more</a></article><article class="post"><header class="header"><h3><a href="/2017/05/17/Promise的简单实现/">Promise的简单实现</a></h3></header><section class="info"><a href="/categories/前端/">前端</a><span class="dot-sep"></span><time>May 17, 2017</time></section><section class="excerpt"><p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href="https://promisesaplus.com/" target="_blank" rel="external">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>
<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p></section><a href="/2017/05/17/Promise的简单实现/" class="readmore">read more</a></article></div></div><nav class="pagination index-pagination"><a href="/" class="item active">1</a><a href="/page/2/" class="item">2</a><a href="/archives/2017/page/2/" class="item"><i class="ion-ios-arrow-right"></i></a></nav></div></div></div><div class="cp"><div>©   2015 - 2016   Kit</div><div><span>power by </span><span><a href="//hexo.io">hexo.</a></span><span>Design By Kit.</span></div></div></div><div class="off-canvas"><div class="side-bar"><div class="head"><img src="/img/head.jpg" class="img-responsive"></div><div class="info"><h6>kitwang chan</h6><div class="overview"><span><i>9</i><br/> 日志</span><span class="m"><i>4</i><br/> 分类</span><span><i>7</i><br/> 标签</span></div></div><nav><a href="/" class="item"><i class="ion-help-buoy"></i><span>Home</span></a><a href="/archives" class="item m unopen"><i class="ion-nuclear"></i><span>Archives</span></a><a href="//github.com/kitwon" class="item"><i class="ion-social-github"></i><span>Github</span></a></nav></div></div></div><script src="/js/vendor.min.js"></script><script src="/js/index.min.js"></script></body></html>