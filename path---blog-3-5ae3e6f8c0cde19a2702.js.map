{"version":3,"sources":["webpack:///path---blog-3-5ae3e6f8c0cde19a2702.js","webpack:///./.cache/json/blog-3.json"],"names":["webpackJsonp","284","module","exports","pathContext","nodes","node","frontmatter","title","date","category","tags","path","excerpt","headings","depth","value","html","htmlExcerpt","page","pages","total","limit","prev"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAUC,MAAQC,aAAeC,MAAA,eAAAC,KAAA,aAAAC,UAAA,MAAAC,MAAA,cAAAC,KAAA,oBAA6GC,QAAA,6rBAA4rBC,WAAyBC,MAAA,EAAAC,MAAA,kBAAoCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,eAAiCD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,OAAuBC,KAAA,22PAA2uOC,YAAA,uxBAA86CZ,MAAQC,aAAeC,MAAA,iBAAAC,KAAA,aAAAC,UAAA,MAAAC,KAAA,KAAAC,KAAA,mBAAoGC,QAAA,IAAAC,WAA4BC,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,eAAiCD,MAAA,EAAAC,MAAA,iBAAqCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,OAAuBC,KAAA,6qFAAgoEC,YAAA,QAA4kBZ,MAAQC,aAAeC,MAAA,mBAAAC,KAAA,aAAAC,UAAA,MAAAC,MAAA,iBAAAC,KAAA,0BAA0HC,QAAA,8IAAAC,WAAsKC,MAAA,EAAAC,MAAA,kBAAoCD,MAAA,EAAAC,MAAA,YAA8BD,MAAA,EAAAC,MAAA,YAA8BD,MAAA,EAAAC,MAAA,WAA6BD,MAAA,EAAAC,MAAA,cAA8BC,KAAA,+uUAAk0TC,YAAA,QAAgjBZ,MAAQC,aAAeC,MAAA,kBAAAC,KAAA,aAAAC,UAAA,gBAAAC,MAAA,0BAAAC,KAAA,oBAAsIC,QAAA,8HAAAC,WAAsJC,MAAA,EAAAC,MAAA,QAA0BD,MAAA,EAAAC,MAAA,aAA+BD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,QAA0BD,MAAA,EAAAC,MAAA,kBAAoCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,OAAuBC,KAAA;AAAy2TC,YAAA,QAAiYC,KAAA,EAAAC,MAAA,EAAAC,MAAA,GAAAC,MAAA,EAAAC,KAAA","file":"path---blog-3-5ae3e6f8c0cde19a2702.js","sourcesContent":["webpackJsonp([173394108556902],{\n\n/***/ 284:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"nodes\":[{\"node\":{\"frontmatter\":{\"title\":\"Promise的简单实现\",\"date\":\"2017-05-17\",\"category\":[\"前端\"],\"tags\":[\"javascript\"],\"path\":\"/post/js-promise\"},\"excerpt\":\"\\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\\n\\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\\n\\n\\n\\n# 初步构建一个Promise\\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\\n```javascript\\n// 例1\\nfunction getAsyncData() {\\n\\treturn new Promise(function(resolve, reject) {\\n\\t\\tsetTimeout(function() {\\n\\t\\t\\tresolve('promise done!')\\n\\t\\t}, 1000)\\n\\t})\\n}\\n\\ngetAsyncData().then(function(result) {\\n\\tconsole.log(result);\\n}).then(function() {\\n\\tconsole.log('done too!');\\n})\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"初步构建一个Promise\"},{\"depth\":1,\"value\":\"引入状态\"},{\"depth\":1,\"value\":\"串行promise\"},{\"depth\":1,\"value\":\"添加reject功能\"},{\"depth\":1,\"value\":\"总结\"},{\"depth\":2,\"value\":\"参考\"}],\"html\":\"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\\\"https://promisesaplus.com/\\\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\\n<h1>初步构建一个Promise</h1>\\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\\n<pre><code class=\\\"language-javascript\\\">// 例1\\nfunction getAsyncData() {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve('promise done!')\\n        }, 1000)\\n    })\\n}\\n\\ngetAsyncData().then(function(result) {\\n    console.log(result);\\n}).then(function() {\\n    console.log('done too!');\\n})\\n</code></pre>\\n<!-- more -->\\n<p><code>getAsyncData</code>函数中返回一个promise对象，然后通过<code>then</code>方法执行函数的回调，然后尝试实现一下这个基本的功能</p>\\n<pre><code class=\\\"language-javascript\\\">// promise.js\\nvar Primose = function(fn) {\\n    var callbacks = [];\\n\\n    this.done = function(onFulfilled) {\\n        this.callbacks.push(onFulfilled)\\n\\n        // 支持链式调用\\n        return this;\\n    }\\n\\n    function resolve(value) {\\n        // push到队列的最底端，保证链式代码执行完后再执行方法\\n        setTimeout(function() {\\n            while(callbacks[0]) {\\n                callbacks.shift()()\\n            }\\n        }, 0)\\n    }\\n\\n    fn(resolve)\\n}\\n</code></pre>\\n<p>到这里就完成了promise的基础功能，然后执行一下看下有没有达到预期情况:</p>\\n<pre><code class=\\\"language-bash\\\">$node promise\\npromise done!\\ndone too!\\n</code></pre>\\n<p>乍看一下，怎么有点像lazyman(js中比较有名的题目，可以自行百度一下) ，看来平时多读书还是有好处的（手动滑稽）v</p>\\n<h1>引入状态</h1>\\n<p>这里我们可以先看下<a href=\\\"https://promisesaplus.com/#requirements\\\">promise状态规范</a></p>\\n<p>promise必需在pending, fulfilled或者reject三个状态中的一个</p>\\n<ul>\\n<li>\\n<p>当promise在pending状态中</p>\\n<ul>\\n<li>可以变为fulfilled或者reject状态</li>\\n</ul>\\n</li>\\n<li>\\n<p>当promise在fulfilled中</p>\\n<ul>\\n<li>不能过渡为其他状态</li>\\n<li>必需返回一个值，并且不能改变</li>\\n</ul>\\n</li>\\n<li>\\n<p>当promise在reject中</p>\\n<ul>\\n<li>不能过渡为其他状态</li>\\n<li>必需返回一个失败原因，并且不能改变</li>\\n</ul>\\n</li>\\n</ul>\\n<p>从这里可以看出，我们需要添加一个<code>status</code>变量保存状态，并且随着代码执行更新状态。</p>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        value = null,\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled) {\\n        if(state === 'pending') {\\n            callbacks.push(onFulfilled);\\n            return this;\\n        }\\n\\n        onFulfilled(value);\\n        return this;\\n    }\\n\\n    function resolve(newValue) {\\n        state = 'fulfilled';\\n        value = newValue;\\n\\n        setTimeout(function() {\\n            while(callbacks[0]) {\\n                callbacks.shift()(value)\\n            }\\n        }, 0)\\n    }\\n\\n    fn(resolve)\\n}\\n</code></pre>\\n<h1>串行promise</h1>\\n<p>在执行promise的时候，经常会在<code>then</code>的方法里面执行另外一个promise，<em>串联执行promise应该是promise里面最有趣并且是最核心的功能了</em>。</p>\\n<p>串行promise指执行完一个异步函数达到fulfilled状态后，接着执行下一个promise，例如</p>\\n<pre><code class=\\\"language-javascript\\\">// 接着例1\\n\\ngetAsyncData()\\n    .then(getAsyncData2)\\n    .then(function(data) {\\n        console.log(data + 'done too!');\\n    })\\n\\nfunction getAsyncData2(result) {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve(result + 'next promise done!')\\n        }, 1000)\\n    })\\n}\\n</code></pre>\\n<p>要实现这个功能，首先，我们，之前的<code>then</code>方法是直接把<code>this</code>返回出去，所以实现链式调用，执行起来的时候也扛扛的，没毛病，但如果then中执行下一个promise，这时候按上面的代码，应该是直接就return一个promise出去的，走不了下一步，所以<code>then</code>方法应该需要处理一下，promise的执行方式应该要变为：</p>\\n<ol>\\n<li>执行代码，将所有方法push到<code>callbacks</code>数组里面</li>\\n<li>如果<code>then</code>中是一个promise，把剩下的<code>callbacks</code>提交到这个promise中执行</li>\\n<li>再循环第一步</li>\\n</ol>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        // value = null,\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled) {\\n        switch(state) {\\n            case 'pending':\\n                callbacks.push(onFulfilled)\\n                return this;\\n                break;\\n            case 'fulfilled':\\n                onFulfilled()\\n                return this;\\n                break;\\n        }\\n    }\\n\\n    function resolve(newValue) {\\n        var value = newValue;\\n        var temp = null;\\n\\n        setTimeout(function() {\\n            state = 'fulfilled';\\n            do {\\n                temp = callbacks.shift()(value)\\n                // 顺序执行数组，如果是resolve返回value\\n                // 如果是promise则把后面的then方法提交到下个promise中执行\\n                if(temp instanceof Promise) {\\n                    while(callbacks[0]) {\\n                        temp.then(callbacks.shift())\\n                    }\\n                    return;\\n                }else {\\n                    value = temp;\\n                }\\n            }while(callbacks[0])\\n        }, 0)\\n    }\\n    fn(resolve)\\n}\\n</code></pre>\\n<h1>添加reject功能</h1>\\n<p>因为不确定then方法中是否会添加reject的处理，所以选用了一个比较笨的方法，加一个<code>errDerrers</code>的数组，每次执行不管有没有方法<code>then</code>都<code>push</code>到数组里面，<code>resolve</code>一个方法就<code>shift</code>一个，跟成功的回调一样，当reject的时候，判断下当前的方法是不是一个可执行函数，如果是的话则执行。至于catch的方法按这个思路暂时没想到，后面想到再更新。修改的地方都有添加注释。</p>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        // value = null,\\n        error = null,\\n        errDeffers = [],\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled, rejected) {\\n        switch(state) {\\n            case 'pending':\\n                callbacks.push(onFulfilled);\\n                // 每次执行then都push一次\\n                errDeffers.push(rejected);\\n                return this;\\n                break;\\n            case 'fulfilled':\\n                onFulfilled()\\n                return this;\\n                break;\\n            // reject的话直接执行\\n            case 'rejected':\\n                rejected(error);\\n                return this;\\n                break;\\n        }\\n    }\\n\\n    this.catch = function(rejected) {\\n        if(errDeffer === null) {\\n            errDeffer = rejected;\\n            return;\\n        }\\n    }\\n\\n    function resolve(newValue) {\\n        var value = newValue;\\n        var temp = null;\\n\\n        setTimeout(function() {\\n            state = 'fulfilled';\\n            do {\\n                temp = callbacks.shift()(value);\\n                errDeffers.shift();\\n                // 顺序执行数组，如果是resolve返回value\\n                // 如果是promise则把后面的then方法提交到下个promise中执行\\n                if(temp instanceof Promise) {\\n\\n                    while(callbacks[0]) {\\n                        // 成功的时候也要更新一下errDeffers数组\\n                        temp.then(callbacks.shift(), errDeffers.shift())\\n                    }\\n\\n                    return;\\n                }else {\\n                    value = temp;\\n                }\\n            }while(callbacks[0])\\n        }, 0)\\n    }\\n\\n    // reject方法\\n    // 判断rejected是否一个函数，是的话执行，不是的话抛出一个错误\\n    // reject也要提交到栈的最底端执行\\n    function reject(err) {\\n        setTimeout(function() {\\n            state = 'rejected';\\n            error = err;\\n            var rejected = errDeffers.shift();\\n\\n            if(Object.prototype.toString.call(rejected) !== '[object Function]') {\\n                throw new Error('Uncaught promise error!');\\n                return;\\n            }\\n\\n            rejected(error);\\n        }, 0)\\n    }\\n\\n    fn(resolve, reject)\\n}\\n</code></pre>\\n<h1>总结</h1>\\n<p>找资料的时候看到<a href=\\\"http://tech.meituan.com/promise-insight.html\\\">美团技术团队博客的实现方式</a>采用了另外一种解决方式解决串行promise，后面接着研究下，有兴趣也可以自行看下。\\n实现promise应该有下面几个要点：</p>\\n<ol>\\n<li>函数的顺序执行</li>\\n<li>处理好状态（这部分感觉我的方法跟promiseA的状态要求有点偏差）</li>\\n<li>链式调用\\n这个例子只是根据promise的执行方式实现大概的功能，后面或许会根据promise规范去实现一个比较规范的demo。</li>\\n</ol>\\n<h2>参考</h2>\\n<ul>\\n<li><a href=\\\"https://promisesaplus.com/#requirements\\\">Promises/A+</a></li>\\n<li><a href=\\\"http://tech.meituan.com/promise-insight.html\\\">剖析 Promise 之基础篇</a></li>\\n<li><a href=\\\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\\\">Javascript异步编程的4种方法</a></li>\\n</ul>\",\"htmlExcerpt\":\"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\\\"https://promisesaplus.com/\\\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\\n<h1>初步构建一个Promise</h1>\\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\\n<pre><code class=\\\"language-javascript\\\">// 例1\\nfunction getAsyncData() {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve('promise done!')\\n        }, 1000)\\n    })\\n}\\n\\ngetAsyncData().then(function(result) {\\n    console.log(result);\\n}).then(function() {\\n    console.log('done too!');\\n})\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"前端单元测试&Mocha指北\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":null,\"path\":\"/post/unit-test\"},\"excerpt\":\"…\",\"headings\":[{\"depth\":1,\"value\":\"什么是单元-测试?\"},{\"depth\":1,\"value\":\"为什么要写单元测试？\"},{\"depth\":1,\"value\":\"干了这杯 \\\"Mocha\\\"\"},{\"depth\":2,\"value\":\"举个例子\"},{\"depth\":1,\"value\":\"小结\"}],\"html\":\"<h1>什么是单元-测试?</h1>\\n<ul>\\n<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>\\n<li>而测试，就是测试啦。</li>\\n</ul>\\n<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>\\n<h1>为什么要写单元测试？</h1>\\n<p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>\\n<!--more-->\\n<h1>干了这杯 \\\"Mocha\\\"</h1>\\n<p>mocha是一个js测试框架，除此外，类似的测试框架还有Jasmine、Karma、Tape等，至于为什么要介绍Mocha？因为我只懂这一个。\\n上代码前还要普及一下两个概念</p>\\n<ul>\\n<li><a href=\\\"https://zh.wikipedia.org/wiki/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91\\\">BDD（Behavior Driven Development）</a>\\nBDD意为行为驱动开发，是一种敏捷软件开发技术，具体内容大家可以参考wikipedia的解释。</li>\\n<li><a href=\\\"https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)\\\">Assertion 断言</a>\\n断言，就是判断代码的执行结果与预期是否一致，不一致就抛出错误，说得简单点就是判断程序的真假。</li>\\n</ul>\\n<h2>举个例子</h2>\\n<pre><code class=\\\"language-javascript\\\">// add.js\\nfunction add(a, b) {\\n    return a + b\\n}\\nmodule.exports = add\\n</code></pre>\\n<p>通常测试脚本要与测试源码同名，比如add.js的测试脚本就是add.test.js</p>\\n<pre><code class=\\\"language-javascript\\\">// add.test.js\\nconst add = require('./add.js')\\nconst expect = require('chai').expect\\n\\ndescribe('加法函数测试', function() {\\n    it('1 + 1 等于 2', function() {\\n        expect(add(1, 1)).to.be.equal(2)\\n    })\\n    it('返回值是Number', function() {\\n        expect(add(1, 1)).to.be.a('number')\\n    })\\n})\\n</code></pre>\\n<p>上面代码块就是测试脚本，可独立运行，测试脚本中应该包括一个或多个<code>describe</code>块，每个<code>describe</code>块应包括多个<code>it</code>块。\\n<code>describe</code>是测试套件，这个方法需要传两个参数，第一个为测试套件的名称<code>('加法函数测试')</code>，第二个是执行函数。\\n<code>it</code>块是测试用例，表示一个单独的测试，是测试的最小单位，第一个参数是测试用例的名称('1 + 1 等于 2')，第二个是执行函数。</p>\\n<p>然后在terminal下执行<code>mocha add.test.js</code></p>\\n<pre><code class=\\\"language-terminal\\\">$ mocha add.test.js\\n\\n   加法函数测试\\n     √ 1 + 1 等于 2\\n     √ 返回值是Number\\n   2 passing (12ms)\\n</code></pre>\\n<p>如果我们改变一下<code>add.js</code></p>\\n<pre><code class=\\\"language-javascript\\\">// add.js\\nfunction add(a, b) {\\n    return a * b\\n}\\nmodule.exports = add\\n</code></pre>\\n<p>然后再执行一下<code>mocha add.test.js</code></p>\\n<pre><code class=\\\"language-terminal\\\">$ mocha add.test.js\\n\\n   加法函数测试\\n     √ 1 + 1 等于 2\\n     1) 返回值是Number\\n   1 passing (8ms)\\n   1 failing\\n\\n   1) 加法函数测试 返回值是Number:\\n       AssertionError: expected 2 to equal 3\\n       + expected - actual\\n\\n       -2\\n       +3\\n\\n       at Context.it(add.test.js:6:27)\\n</code></pre>\\n<p>这里也可以很明显看出哪个测试用例报错、还有报错的位置，这样在开发的时候开发人员就能很容易定位错误。</p>\\n<h1>小结</h1>\\n<p>从上面一个简单的例子可以看出，利用mocha实现自动化测试是很简单的。虽然前期开发需要花一点时间去写单元测试，但是后面提供的便利性足以将其弥补。</p>\",\"htmlExcerpt\":\"\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"使用nodejs写一个命令行程序\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":[\"nodejs\",\"bash\"],\"path\":\"/post/node-command-app\"},\"excerpt\":\"原文译自 Smashing Magazine  --  [How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/0…\",\"headings\":[{\"depth\":2,\"value\":\"“Hello World”\"},{\"depth\":2,\"value\":\"处理命令行参数\"},{\"depth\":2,\"value\":\"运行时输入参数\"},{\"depth\":2,\"value\":\"模拟发送邮件\"},{\"depth\":2,\"value\":\"变成shell命令\"}],\"html\":\"<blockquote>\\n<p>原文译自<a href=\\\"https://www.smashingmagazine.com/\\\">Smashing Magazine</a> -- <a href=\\\"https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/\\\">[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)</a></p>\\n</blockquote>\\n<p>相信很多前端都听说过或者使用过<a href=\\\"http://www.gulpjs.com.cn/\\\">Gulp</a>, <a href=\\\"https://cli.angular.io/\\\">Angular CLI</a>, <a href=\\\"https://cordova.apache.org/\\\">Cordova</a>, <a href=\\\"http://yeoman.io/\\\">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code>ng new &#x3C;project-name></code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>\\n<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href=\\\"https://github.com/sendgrid/sendgrid-nodejs\\\">SendGrid Api</a>模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令</p>\\n<!--more-->\\n<hr>\\n<h2>“Hello World”</h2>\\n<p>开始前，首先你得有node，如果没有，请自行安装下。node中自带npm，使用<a href=\\\"https://www.npmjs.com/\\\">npm</a>能安装许多开源的node模块。首先，使用npm创建一个node项目</p>\\n<pre><code class=\\\"language-shell\\\">$ npm init\\nname: broadcast\\nversion: 0.0.1\\ndescription: CLI utility to broadcast email\\nentry point: broadcast.js\\n</code></pre>\\n<p>除这些参数外，npm还提供了其他如Git repository等参数，可根据自身需求设置输入。执行完<code>npm init</code>后，会发现在同目录下生成了一个<code>package.json</code>文件，文件里面包含了上面命令输入的信息。配置内容信息可以在<a href=\\\"https://docs.npmjs.com/files/package.json\\\">package.json文档</a>中找到。</p>\\n<p>然后，还是从最简单的Hello World入手。首先在同目录下建一个<code>broadcast.js</code>文件</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\nconsole.log('Hello World!')\\n</code></pre>\\n<p>然后在terminal中执行</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast\\nHello World!\\n</code></pre>\\n<p>well done, 根据<a href=\\\"https://docs.npmjs.com/files/package.json\\\">package.json文档</a>，我们可以找到一个<code>dependencies</code>参数，在这参数中你可以找到所有这项目需要用到的第三方模块和它们的版本号，上面也有提及到，我们需要用到模块去开发这个工具。最后开发完成，<code>package.json</code>应该如下</p>\\n<pre><code class=\\\"language-json\\\">{\\n    \\\"name\\\": \\\"broadcast\\\",\\n    \\\"version\\\": \\\"0.0.1\\\",\\n    \\\"description\\\": \\\"CLI utility to broadcast emails\\\",\\n    \\\"main\\\": \\\"broadcast.js\\\",\\n    \\\"license\\\": \\\"MIT\\\",\\n    \\\"dependencies\\\": {\\n        \\\"chalk\\\": \\\"^1.1.3\\\",\\n        \\\"commander\\\": \\\"^2.9.0\\\",\\n        \\\"csv\\\": \\\"^1.1.0\\\",\\n        \\\"inquirer\\\": \\\"^2.0.0\\\"\\n    }\\n}\\n</code></pre>\\n<p>这几个模块 <a href=\\\"https://github.com/chalk/chalk\\\">Chalk</a>, <a href=\\\"https://github.com/tj/commander.js\\\">Commander</a>, <a href=\\\"https://github.com/sboudrias/Inquirer.js\\\">Inquirer</a>, <a href=\\\"http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/\\\">CSV</a>的具体用处跟其他参数，可以自行查看。</p>\\n<h2>处理命令行参数</h2>\\n<p>node原生也有读取命令行的函数<a href=\\\"https://nodejs.org/docs/latest/api/process.html\\\"><code>process.argv</code></a>，但是解析参数是个繁琐的工作，所以我们会使用<a href=\\\"https://github.com/tj/commander.js\\\">Commander</a>去替代这些工作。Commande的另外一个好处就是不用额外的去写一个<code>--help</code>函数，只要定义了其他参数，<code>--help</code>函数就会自动生成。首先安装一下Commander和其他package</p>\\n<pre><code class=\\\"language-shell\\\">$ npm install commander chalk csv inquirer --save\\n</code></pre>\\n<p>然后修改<code>broadcast.js</code></p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast\\nconst program = require('commander')\\n\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'list of customers in CSV file')\\n    .parse(process.argv)\\n\\nconsole.log(program.list)\\n</code></pre>\\n<p>从上面可以看出，处理一个参数是十分简单的。我们定义了一个<code>--list</code>的参数，现在我们就能通过<code>--list</code>参数获取到命令行传过来的值。在这程序中，list应该是接收一个csv的地址参数，然后打印在console中。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --list ./test.csv\\n./test.csv\\n</code></pre>\\n<p>从js中可以看到还有一个<code>version</code>参数，所以我们可以使用<code>--version</code>读取版本号。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --version\\n0.0.1\\n</code></pre>\\n<p>又或者能使用<code>--help</code>获取app能接收的参数</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --help\\n\\n  Usage: broadcast [options]\\n\\n  Options:\\n\\n    -h, --help                 output usage information\\n    -V, --version              output the version number\\n    -l, --list &#x3C;list>          list of customers in CSV file\\n</code></pre>\\n<p>现在我们已经能够接收到命令行传递过来的参数了，下面我们会利用接收到的CSV文件地址，并使用<a href=\\\"http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/\\\">CSV</a>模块处理CSV文件的内容。\\n我们会使用下面的比哦啊哥内容作为CSV文件的内容。使用CSV模块，会读取内容，并显示各列的内容。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>First name</th>\\n<th>Last name</th>\\n<th>Email</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Dwight</td>\\n<td>Schrute</td>\\n<td>dwight.schrute@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Jim</td>\\n<td>Halpert</td>\\n<td>jim.halpert@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Pam</td>\\n<td>Beesly</td>\\n<td>pam.beesly@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Ryan</td>\\n<td>Howard</td>\\n<td>ryan.howard@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Stanley</td>\\n<td>Hudson</td>\\n<td>stanley.hudson@dundermifflin.com</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>现在，更新下<code>broadcast.js</code>，使用CSV读取内容并打印在console</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\nconst program = require('commander')\\nconst csv = require('csv')\\nconst fs = require('fs')\\n\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'List of customers in CSV')\\n    .parse(process.argv)\\n\\nconst stream = fs.createReadStream(program.list)\\nstream\\n    .pipe(csv.parse({ delimiter : \\\",\\\" }))\\n    .on('data', function(data) {\\n         const firstname = data[0]\\n         const lastname = data[1]\\n         const email = data[2]\\n\\n         console.log(firstname, lastname, email)\\n    })\\n</code></pre>\\n<p>除csv模块外，还使用了node的<a href=\\\"https://nodejs.org/dist/latest-v7.x/docs/api/fs.html\\\">File System</a>模块读取文件内容，csv的<code>parse</code>方法把列数据解析为数组，然后在terminal中运行一下命令</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast.js --list ./test.csv\\nDwight Schrute dwight.schrute@dundermifflin.com\\nJim Halpert jim.halpert@dundermifflin.com\\nPam Beesly pam.beesly@dundermifflin.com\\nRyan Howard ryan.howard@dundermifflin.com\\nStanley Hudson stanley.hudson@dundermifflin.com\\n</code></pre>\\n<h2>运行时输入参数</h2>\\n<p>上面已经实现了获取命令行参数，但如果想在运行时候接收参数值的话我们就需要另外一个模块<a href=\\\"https://github.com/sboudrias/Inquirer.js\\\">inquirer.js</a>，通过这个模块，用户可以自定义多种参数类型，如文本，密码，单选或者多选列表等。</p>\\n<p>下面的demo会通过inquirer接收邮件发送人的名字，email还有邮件主题。</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\n...\\nconst inquirer = require('inquirer')\\nconst questions = [\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"sender.email\\\",\\n    message : \\\"Sender's email address - \\\"\\n  },\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"sender.name\\\",\\n    message : \\\"Sender's name - \\\"\\n  },\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"subject\\\",\\n    message : \\\"Subject - \\\"\\n  }\\n]\\n\\nprogram\\n  .version('0.0.1')\\n  .option('-l, --list [list]', 'List of customers in CSV')\\n  .parse(process.argv)\\n\\n// 储存CSV数据\\nconst contactList = []\\nconst stream = fs.createReadStream(program.list)\\n    .pipe(csv.parse({ delimiter : \\\",\\\" }))\\n\\nstream\\n  .on('error', function (err) {\\n    return console.error(err.message)\\n  })\\n  .on('data', function (data) {\\n    let name = data[0] + \\\" \\\" + data[1]\\n    let email = data[2]\\n    contactList.push({ name : name, email : email })\\n  })\\n  .on('end', function () {\\n    inquirer.prompt(questions).then(function (answers) {\\n      console.log(answers)\\n    })\\n  })\\n</code></pre>\\n<p>Inquire.js的<code>prompt</code>方法接受一个数组参数，数组里可以自定义运行时需要接受的问题参数，在这demo里面，我们想知道发送者的名字还要email还有邮件主题，所以定义了一个<code>questions</code>的数组来储存问题，从对象里面可以看到有一个<code>input</code>的参数，除此外还可以接受<code>password</code>等其他类型，具体可以查询一下<a href=\\\"https://github.com/SBoudrias/Inquirer.js/\\\">inquirer的文档</a>。此外，参数<code>name</code>保存input的key值。<code>prompt</code>方法会返还一个promise对象，promise中会返回一个<code>answer</code>变量，里面带有刚才输入的值。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast -l input/employees.csv\\n? Sender's email address -  kitssang_demo@163.com\\n? Sender's name -  kit\\n? Subject - Hello World\\n{ sender:\\n   { email: '  kitssang_demo@163.com',\\n     name: 'kit' },\\n  subject: 'Hello World' }\\n</code></pre>\\n<h2>模拟发送邮件</h2>\\n<p>由于原文使用的<code>sendgrid</code>没有跑通，所以只组装了一下数据模拟了发送邮件。原本的第五部分也在这里一起用上了。</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\n...\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'list of customers in CSV file')\\n    .parse(process.argv)\\n\\nconst sendEmail = function(to, from, subject) {\\n    const sender = chalk.green(`${from.name}(${from.email})`)\\n    const receiver = chalk.green(`${to.name}(${to.email})`)\\n    const theme = chalk.blue(subject)\\n\\n    console.log(`${sender} send a mail to ${receiver} and the subject of the email is ${theme}`)\\n}\\n\\n// 储存CSV数据\\nlet concatList = []\\nconst stream = fs.createReadStream(program.list)\\n  .pipe(csv.parse({\\n    delimiter: ','\\n  }))\\n  .on('data', function(data) {\\n    const name = data[0] + ' ' + data[1]\\n    const email = data[2]\\n\\n    concatList.push({\\n      name: name,\\n      email: email\\n    })\\n  })\\n  .on('end', function() {\\n    inquirer.prompt(questions).then((ans) => {\\n      for (let i = 0; i &#x3C; concatList.length; i++) {\\n        sendEmail(concatList[i], ans.sender, ans.subject)\\n      }\\n    }).catch((err) => {\\n      console.log(err)\\n    })\\n  })\\n</code></pre>\\n<p>由于没有异步请求，<code>async</code>模块没有用上，另外使用了<code>chalk</code>模块改变了console打印结果的颜色。</p>\\n<h2>变成shell命令</h2>\\n<p>至此，整个工具已经基本完成，但是如果想像一个普通的shell命令(不加<code>$ node xx</code>)执行，还需要做以下操作。首先，添加<a href=\\\"https://zh.wikipedia.org/wiki/Shebang\\\">shebang</a>在js的头部，让shell知道如何执行这个文件。</p>\\n<pre><code class=\\\"language-javascript\\\">#!/usr/bin/env node\\n\\n// broadcast.js\\nconst program = require(\\\"commander\\\")\\nconst inquirer = require(\\\"inquirer\\\")\\n...\\n</code></pre>\\n<p>然后再配置一下<code>package.json</code>使代码可运行</p>\\n<pre><code class=\\\"language-json\\\">…\\n  \\\"description\\\": \\\"CLI utility to broadcast emails\\\",\\n  \\\"main\\\": \\\"broadcast.js\\\",\\n  \\\"bin\\\" : {\\n    \\\"broadcast\\\" : \\\"./broadcast.js\\\"\\n  }\\n…\\n</code></pre>\\n<p>从代码可以看到加了一个<a href=\\\"https://docs.npmjs.com/files/package.json#bin\\\"><code>bin</code></a>的参数，这个参数可以使broadcast命令与broadcast.js建立连接。</p>\\n<p>最后一步，在全局安装一下依赖包。在项目目录运行一下下面的命令。</p>\\n<pre><code class=\\\"language-shell\\\">$ npm install -g\\n</code></pre>\\n<p>然后测试一下命令</p>\\n<pre><code class=\\\"language-shell\\\">$ broadcast --help\\n</code></pre>\\n<p>需要注意的是，在开发时候如果使用<code>commaner</code>默认给出的命令执行<code>broadcast</code>则在代码中所做的任何更改都是看不见的。假如输入<code>which broadcast</code>，你会发现地址不是你当前目录，所以这时应该要用<code>npm link</code>去查看命令的目录映射。</p>\",\"htmlExcerpt\":\"\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"React-todo demo\",\"date\":\"2016-03-02\",\"category\":[\"js framework\"],\"tags\":[\"React\",\"Webpack\",\"js框架\"],\"path\":\"/post/react-todo\"},\"excerpt\":\"好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。 小科普 什么是React? 按官方解释，框架属于MVC中的view…\",\"headings\":[{\"depth\":3,\"value\":\"小科普\"},{\"depth\":3,\"value\":\"Demo功能需求\"},{\"depth\":3,\"value\":\"开始\"},{\"depth\":4,\"value\":\"配置webpack\"},{\"depth\":4,\"value\":\"上代码\"},{\"depth\":4,\"value\":\"App生命 - state\"},{\"depth\":4,\"value\":\"其他组件\"},{\"depth\":3,\"value\":\"总结\"}],\"html\":\"<p>好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。</p>\\n<!--more-->\\n<h3>小科普</h3>\\n<p>什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！</p>\\n<h3>Demo功能需求</h3>\\n<ul>\\n<li>input输入内容，回车键或按钮增加一条todo</li>\\n<li>checkbox添加完成状态</li>\\n<li>移动到列表时显示删除</li>\\n<li>显示todo总数和已经完成数</li>\\n<li>list全选</li>\\n<li>清除已完成</li>\\n<li>添加动画效果</li>\\n</ul>\\n<h3>开始</h3>\\n<p>开始需要npm安装一下等下要用的packages，如果是checkout我的demo，就动动手指头，install一下，我的demo地址是<a href=\\\"https://github.com/kitwon/react-todo\\\">https://github.com/kitwon/react-todo</a></p>\\n<pre><code class=\\\"language-bash\\\">$npm install\\n</code></pre>\\n<h4>配置webpack</h4>\\n<p>所有东西安装完成之后首先就是配置<a href=\\\"http://webpack.github.io/docs/\\\">webpack</a></p>\\n<pre><code class=\\\"language-javascript\\\">var path = require('path');\\n\\nmodule.exports = {\\n    entry : \\\"./src/entry.js\\\",\\n    output : {\\n        path : path.join(__dirname, \\\"out\\\"),\\n        publicPath : \\\"./out/\\\",\\n        filename : \\\"bundle.js\\\"\\n    },\\n    externals : {\\n        react : \\\"React\\\"\\n    },\\n    module : {\\n        loaders : [\\n            { test : /\\\\.js$/, loader : \\\"jsx\\\",include: /src/ },\\n            { test : /\\\\.css$/, loader : \\\"style!css\\\" },\\n            { test : /\\\\.less$/, loader : \\\"style!css!less\\\" },\\n            { test : /\\\\.(jpg|png)$/, loader : \\\"url?limit=8192\\\" }\\n        ]\\n    }\\n}\\n</code></pre>\\n<p>从上面可以看到，webpack的入口文件是entry.js，打包输出的文件是bundle.js，external属性是告诉webpack，当API已经存在的时候，使用全局变量，并不作任何操作。</p>\\n<p>loader的话没啥，看文档就知道，各种编译打包。具体使用方法可以看官方文档。</p>\\n<h4>上代码</h4>\\n<pre><code class=\\\"language-javascript\\\">var React = require('React'),\\n    ReactDOM = require('react-dom');\\n\\nrequire('../less/app.less');\\n\\nvar AppFooter = require('./AppFooter'),\\n    AppHeader = require('./AppHeader'),\\n    ItemMain = require('./ItemMain');\\n\\n\\nvar App = React.createClass ({\\n    getInitialState : function() {\\n        return {\\n            todoItem : [],\\n            isAllChecked : false\\n        }\\n    },\\n    //添加todo\\n    addItem : function(item) {\\n        var todoList = this.state.todoItem.push(item);\\n        this.setState({isAllChecked : false});\\n        this.forceUpdate();\\n    },\\n     //更改todo状态\\n    changeTodoState : function(index, isDone, isAllChange) {\\n        // isAllChange = false;\\n        if(isAllChange) {\\n            this.setState({\\n                todoItem: this.state.todoItem.map(function(todo) {\\n                    todo.isDone = isDone;\\n                    return todo;\\n                }),\\n                isAllChecked : isDone\\n            })\\n        }else {\\n            this.state.todoItem[index].isDone = isDone;\\n            this.allChecked();\\n            this.forceUpdate();\\n        }\\n    },\\n    //删除todo\\n    deleteTodo : function(index) {\\n        var newTodo = this.state.todoItem.splice(index, 1);\\n        this.setState({todoList: newTodo});\\n    },\\n    //清楚已完成\\n    clearDone : function() {\\n        var doneList = this.state.todoItem.filter(function(item) {\\n            return item.isDone === false;\\n        })\\n        this.setState({todoItem: doneList, isAllChecked: false});\\n    },\\n    //全部完成\\n    allChecked : function() {\\n        var allCheck = this.state.todoItem.every(function(item) {\\n            return item.isDone === true;\\n        })\\n        if (allCheck) {\\n            this.setState({isAllChecked : true})\\n        };\\n    },\\n        render : function(){\\n            var props = {\\n                todoLength : this.state.todoItem.length || 0,\\n                doneLength : this.state.todoItem.filter(function(item) {\\n                    return item.isDone === true;\\n                }).length || 0\\n            };\\n                return (\\n                    &#x3C;div className=\\\"panel\\\">\\n                        &#x3C;header  className=\\\"mainHeader\\\">&#x3C;h2>Webpack + React TODO Demo&#x3C;/h2>&#x3C;/header>\\n                        &#x3C;AppHeader addItem={this.addItem}/>\\n                        &#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\\n                            &#x3C;AppFooter {...props} isAllChecked={this.state.isAllChecked} clearDone={this.clearDone} changeAllState={this.changeTodoState} />\\n                    &#x3C;/div>\\n                )\\n        }\\n})\\n\\nReactDOM.render(&#x3C;App/>, document.getElementById(\\\"app\\\"));  //渲染\\n</code></pre>\\n<p>从代码上面可以看到各种require，没加载commonjs、seajs或其他模块化工具，为什么能直接require呢，而且还有require less，没错，webpack就是那么暴力！js后面都会打包好一个文件，样式都会加载到html里面，做spa时候，和react简直绝配。</p>\\n<h4>App生命 - state</h4>\\n<p>React主流思想就是父组件控制state，然后通过props传递给子组建，所以简单来说界面就像状态机，只要更新state，然后根据新的state重新渲染界面，不需要操作dom，所以react高性能原因也是因为这个。\\n从最上代码就可以看出父组件中的定义的方法基本是整个todo的功能了，然后render方法即渲染html和组件。</p>\\n<pre><code class=\\\"language-javascript\\\">&#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\\n</code></pre>\\n<p>然后取一小段渲染组件代码（上面代码）就可发现，父组件向ItemMain这个组件传了4个属性，其中itemList为state，只要todoItem一更新，react就会重新渲染这个组件，其他三个为方法，方法更新也会重新渲染组件。</p>\\n<pre><code class=\\\"language-javascript\\\">// ItemMain.js\\nvar React = require('React');\\nvar Items = require('./Items');\\n\\nvar ItemMain = React.createClass({\\n    render : function() {\\n        var _this = this;\\n        return (\\n            &#x3C;section>\\n                &#x3C;ul className=\\\"itemList\\\">\\n                    {_this.props.itemList.map(function (todo, index) {\\n                        return (\\n                            &#x3C;Items {...todo} key={index} index={index} {..._this.props} />\\n                        )\\n                    &#x3C;!-- })} -->\\n                    &#x3C;!--这里不注释代码不高亮，比较奇葩，各位官人将就着看-->\\n                &#x3C;/ul>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = ItemMain;\\n</code></pre>\\n<p>看这里估计有点蒙，我自己看的时候也有点蒙，因为太久的代码了哈哈哈。\\n这个js只有一个循环Item的逻辑，首先看看<code>{...todo}</code>这个prop，这个是把itemList[i]中的<a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\\\">数组对象解构</a>，然后传到item里面，如果没有...这个字符，则需要</p>\\n<pre><code class=\\\"language-javascript\\\">    &#x3C;Items text={props.text} isDone={props.isDone} key={index} index={index} changeTodoState={proprs.changeTodoState} deleteTodo={props.deleteTodo} />\\n</code></pre>\\n<p>具体数据大家可以在代码里面console打印一下，这样印象会更深。</p>\\n<pre><code class=\\\"language-javascript\\\">// item.js\\nvar React = require('React');\\n\\nvar Items = React.createClass({\\n    handleChange : function() {\\n        var isDone = !this.props.isDone;\\n        this.props.changeTodoState(this.props.index, isDone);\\n    },\\n    handleDeleteTodo : function() {\\n        this.props.deleteTodo(this.props.index);\\n    },\\n    render : function() {\\n        var doneStyle = this.props.isDone ? {textDecoration: 'line-through'} : {textDecoration : 'none'};\\n        return (\\n            &#x3C;li key={this.props.key} onMouseOver={this.handlerMouseOver} onMouseOut={this.handlerMouseOut}>\\n                &#x3C;input type=\\\"checkbox\\\" checked={this.props.isDone} onChange={this.handleChange} />\\n                &#x3C;span style={doneStyle}>{this.props.text}&#x3C;/span>\\n                &#x3C;button className=\\\"btn btn-default delete-item\\\" onClick={this.handleDeleteTodo}>delete&#x3C;/button>\\n            &#x3C;/li>\\n        )\\n    }\\n})\\n\\nmodule.exports = Items;\\n</code></pre>\\n<p>这个就是js里面有两个方法，一个是改变状态，一个是删除当前todo，这这能发现，两个方法都是执行了又父组件传过来的方法，如下</p>\\n<pre><code class=\\\"language-javascript\\\">this.props.changeTodoState(this.props.index, isDone);\\n</code></pre>\\n<p>执行这个函数，state就会更新，react就会根据状态重新渲染组件</p>\\n<h4>其他组件</h4>\\n<pre><code class=\\\"language-javascript\\\">// AppHeader.js\\nvar React = require('React');\\n\\nvar AppHeader = React.createClass({\\n    getInitialState : function() {\\n        return {\\n            text : \\\"\\\"\\n        }\\n    },\\n    handlerKeyUp : function(event) {\\n        if(event.keyCode === 13) {\\n            var value = event.target.value;\\n            if(!value) return false;\\n\\n            var newTodoItem = {\\n                text : value,\\n                isDone : false\\n            }\\n\\n            event.target.value = \\\"\\\";\\n            this.setState({text: \\\"\\\"});\\n            this.props.addItem(newTodoItem);\\n        }\\n    },\\n    handleChange : function(event) {\\n        this.setState({text : event.target.value });\\n    },\\n    handlerClick : function(event) {\\n        var newTodoItem = {\\n            text : this.state.text,\\n            isDone : false\\n        }\\n        this.props.addItem(newTodoItem);\\n        this.setState({text: \\\"\\\"});\\n    },\\n    render : function() {\\n        return (\\n            &#x3C;section className=\\\"appHeader from-group\\\">\\n                &#x3C;input type=\\\"test\\\" className=\\\"form-control\\\" onKeyUp={this.handlerKeyUp} onChange={this.handleChange} placeholder=\\\"add one todo\\\" value={this.state.text}/>\\n                &#x3C;button className=\\\"btn btn-primary\\\" onClick={this.handlerClick}>add one&#x3C;/button>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = AppHeader;\\n</code></pre>\\n<pre><code class=\\\"language-javascript\\\">// AppHeader.js\\nvar React = require('React');\\n\\nvar AppFooter = React.createClass({\\n    handleClick : function() {\\n        this.props.clearDone();\\n    },\\n    handleAllState : function(event) {\\n        this.props.changeAllState(null, event.target.value, true);\\n    },\\n    render : function() {\\n        return (\\n            &#x3C;section className=\\\"appFooter\\\">\\n                &#x3C;div>\\n                    &#x3C;input type=\\\"checkbox\\\" checked={this.props.isAllChecked} onChange={this.handleAllState}/>\\n                    &#x3C;span>{this.props.doneLength}&#x3C;/span>已经完成 / &#x3C;span>{this.props.todoLength}&#x3C;/span>总数\\n                &#x3C;/div>\\n                &#x3C;button className=\\\"btn btn-default btn-tiny pull-right\\\" onClick={this.handleClick}>clean done&#x3C;/button>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = AppFooter;\\n</code></pre>\\n<p>Header Footer的方法都是大同小异，输入改变state，然后存起来，执行相应操作时候通过props的方法传给父组件，然后重新渲染界面。</p>\\n<h3>总结</h3>\\n<p>回头看代码，react的组件化相比现在的组件化思想真的先进很多。React通过父组件来控制状态，并通过props传递给子组件。因此我们能很容易看出我们的事件属于哪个组件管理，然后修改相应的方法，维护起来相当高效，相比现在的控制dom，每次修改按钮的方法，都需要先找到id或者class，然后绑定响应的方法，假如页面id或者class改变，页面逻辑又非常复杂的话，修改起来是相当麻烦的。\\nReact凭着出色的设计思想和性能，我相信不久就会成为主流的移动端开发方式，至于PC端，大天朝你懂的。</p>\",\"htmlExcerpt\":\"\\n\"}}],\"page\":3,\"pages\":3,\"total\":14,\"limit\":5,\"prev\":\"/blog/2\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-3-5ae3e6f8c0cde19a2702.js","module.exports = {\"pathContext\":{\"nodes\":[{\"node\":{\"frontmatter\":{\"title\":\"Promise的简单实现\",\"date\":\"2017-05-17\",\"category\":[\"前端\"],\"tags\":[\"javascript\"],\"path\":\"/post/js-promise\"},\"excerpt\":\"\\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\\n\\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\\n\\n\\n\\n# 初步构建一个Promise\\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\\n```javascript\\n// 例1\\nfunction getAsyncData() {\\n\\treturn new Promise(function(resolve, reject) {\\n\\t\\tsetTimeout(function() {\\n\\t\\t\\tresolve('promise done!')\\n\\t\\t}, 1000)\\n\\t})\\n}\\n\\ngetAsyncData().then(function(result) {\\n\\tconsole.log(result);\\n}).then(function() {\\n\\tconsole.log('done too!');\\n})\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"初步构建一个Promise\"},{\"depth\":1,\"value\":\"引入状态\"},{\"depth\":1,\"value\":\"串行promise\"},{\"depth\":1,\"value\":\"添加reject功能\"},{\"depth\":1,\"value\":\"总结\"},{\"depth\":2,\"value\":\"参考\"}],\"html\":\"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\\\"https://promisesaplus.com/\\\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\\n<h1>初步构建一个Promise</h1>\\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\\n<pre><code class=\\\"language-javascript\\\">// 例1\\nfunction getAsyncData() {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve('promise done!')\\n        }, 1000)\\n    })\\n}\\n\\ngetAsyncData().then(function(result) {\\n    console.log(result);\\n}).then(function() {\\n    console.log('done too!');\\n})\\n</code></pre>\\n<!-- more -->\\n<p><code>getAsyncData</code>函数中返回一个promise对象，然后通过<code>then</code>方法执行函数的回调，然后尝试实现一下这个基本的功能</p>\\n<pre><code class=\\\"language-javascript\\\">// promise.js\\nvar Primose = function(fn) {\\n    var callbacks = [];\\n\\n    this.done = function(onFulfilled) {\\n        this.callbacks.push(onFulfilled)\\n\\n        // 支持链式调用\\n        return this;\\n    }\\n\\n    function resolve(value) {\\n        // push到队列的最底端，保证链式代码执行完后再执行方法\\n        setTimeout(function() {\\n            while(callbacks[0]) {\\n                callbacks.shift()()\\n            }\\n        }, 0)\\n    }\\n\\n    fn(resolve)\\n}\\n</code></pre>\\n<p>到这里就完成了promise的基础功能，然后执行一下看下有没有达到预期情况:</p>\\n<pre><code class=\\\"language-bash\\\">$node promise\\npromise done!\\ndone too!\\n</code></pre>\\n<p>乍看一下，怎么有点像lazyman(js中比较有名的题目，可以自行百度一下) ，看来平时多读书还是有好处的（手动滑稽）v</p>\\n<h1>引入状态</h1>\\n<p>这里我们可以先看下<a href=\\\"https://promisesaplus.com/#requirements\\\">promise状态规范</a></p>\\n<p>promise必需在pending, fulfilled或者reject三个状态中的一个</p>\\n<ul>\\n<li>\\n<p>当promise在pending状态中</p>\\n<ul>\\n<li>可以变为fulfilled或者reject状态</li>\\n</ul>\\n</li>\\n<li>\\n<p>当promise在fulfilled中</p>\\n<ul>\\n<li>不能过渡为其他状态</li>\\n<li>必需返回一个值，并且不能改变</li>\\n</ul>\\n</li>\\n<li>\\n<p>当promise在reject中</p>\\n<ul>\\n<li>不能过渡为其他状态</li>\\n<li>必需返回一个失败原因，并且不能改变</li>\\n</ul>\\n</li>\\n</ul>\\n<p>从这里可以看出，我们需要添加一个<code>status</code>变量保存状态，并且随着代码执行更新状态。</p>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        value = null,\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled) {\\n        if(state === 'pending') {\\n            callbacks.push(onFulfilled);\\n            return this;\\n        }\\n\\n        onFulfilled(value);\\n        return this;\\n    }\\n\\n    function resolve(newValue) {\\n        state = 'fulfilled';\\n        value = newValue;\\n\\n        setTimeout(function() {\\n            while(callbacks[0]) {\\n                callbacks.shift()(value)\\n            }\\n        }, 0)\\n    }\\n\\n    fn(resolve)\\n}\\n</code></pre>\\n<h1>串行promise</h1>\\n<p>在执行promise的时候，经常会在<code>then</code>的方法里面执行另外一个promise，<em>串联执行promise应该是promise里面最有趣并且是最核心的功能了</em>。</p>\\n<p>串行promise指执行完一个异步函数达到fulfilled状态后，接着执行下一个promise，例如</p>\\n<pre><code class=\\\"language-javascript\\\">// 接着例1\\n\\ngetAsyncData()\\n    .then(getAsyncData2)\\n    .then(function(data) {\\n        console.log(data + 'done too!');\\n    })\\n\\nfunction getAsyncData2(result) {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve(result + 'next promise done!')\\n        }, 1000)\\n    })\\n}\\n</code></pre>\\n<p>要实现这个功能，首先，我们，之前的<code>then</code>方法是直接把<code>this</code>返回出去，所以实现链式调用，执行起来的时候也扛扛的，没毛病，但如果then中执行下一个promise，这时候按上面的代码，应该是直接就return一个promise出去的，走不了下一步，所以<code>then</code>方法应该需要处理一下，promise的执行方式应该要变为：</p>\\n<ol>\\n<li>执行代码，将所有方法push到<code>callbacks</code>数组里面</li>\\n<li>如果<code>then</code>中是一个promise，把剩下的<code>callbacks</code>提交到这个promise中执行</li>\\n<li>再循环第一步</li>\\n</ol>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        // value = null,\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled) {\\n        switch(state) {\\n            case 'pending':\\n                callbacks.push(onFulfilled)\\n                return this;\\n                break;\\n            case 'fulfilled':\\n                onFulfilled()\\n                return this;\\n                break;\\n        }\\n    }\\n\\n    function resolve(newValue) {\\n        var value = newValue;\\n        var temp = null;\\n\\n        setTimeout(function() {\\n            state = 'fulfilled';\\n            do {\\n                temp = callbacks.shift()(value)\\n                // 顺序执行数组，如果是resolve返回value\\n                // 如果是promise则把后面的then方法提交到下个promise中执行\\n                if(temp instanceof Promise) {\\n                    while(callbacks[0]) {\\n                        temp.then(callbacks.shift())\\n                    }\\n                    return;\\n                }else {\\n                    value = temp;\\n                }\\n            }while(callbacks[0])\\n        }, 0)\\n    }\\n    fn(resolve)\\n}\\n</code></pre>\\n<h1>添加reject功能</h1>\\n<p>因为不确定then方法中是否会添加reject的处理，所以选用了一个比较笨的方法，加一个<code>errDerrers</code>的数组，每次执行不管有没有方法<code>then</code>都<code>push</code>到数组里面，<code>resolve</code>一个方法就<code>shift</code>一个，跟成功的回调一样，当reject的时候，判断下当前的方法是不是一个可执行函数，如果是的话则执行。至于catch的方法按这个思路暂时没想到，后面想到再更新。修改的地方都有添加注释。</p>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        // value = null,\\n        error = null,\\n        errDeffers = [],\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled, rejected) {\\n        switch(state) {\\n            case 'pending':\\n                callbacks.push(onFulfilled);\\n                // 每次执行then都push一次\\n                errDeffers.push(rejected);\\n                return this;\\n                break;\\n            case 'fulfilled':\\n                onFulfilled()\\n                return this;\\n                break;\\n            // reject的话直接执行\\n            case 'rejected':\\n                rejected(error);\\n                return this;\\n                break;\\n        }\\n    }\\n\\n    this.catch = function(rejected) {\\n        if(errDeffer === null) {\\n            errDeffer = rejected;\\n            return;\\n        }\\n    }\\n\\n    function resolve(newValue) {\\n        var value = newValue;\\n        var temp = null;\\n\\n        setTimeout(function() {\\n            state = 'fulfilled';\\n            do {\\n                temp = callbacks.shift()(value);\\n                errDeffers.shift();\\n                // 顺序执行数组，如果是resolve返回value\\n                // 如果是promise则把后面的then方法提交到下个promise中执行\\n                if(temp instanceof Promise) {\\n\\n                    while(callbacks[0]) {\\n                        // 成功的时候也要更新一下errDeffers数组\\n                        temp.then(callbacks.shift(), errDeffers.shift())\\n                    }\\n\\n                    return;\\n                }else {\\n                    value = temp;\\n                }\\n            }while(callbacks[0])\\n        }, 0)\\n    }\\n\\n    // reject方法\\n    // 判断rejected是否一个函数，是的话执行，不是的话抛出一个错误\\n    // reject也要提交到栈的最底端执行\\n    function reject(err) {\\n        setTimeout(function() {\\n            state = 'rejected';\\n            error = err;\\n            var rejected = errDeffers.shift();\\n\\n            if(Object.prototype.toString.call(rejected) !== '[object Function]') {\\n                throw new Error('Uncaught promise error!');\\n                return;\\n            }\\n\\n            rejected(error);\\n        }, 0)\\n    }\\n\\n    fn(resolve, reject)\\n}\\n</code></pre>\\n<h1>总结</h1>\\n<p>找资料的时候看到<a href=\\\"http://tech.meituan.com/promise-insight.html\\\">美团技术团队博客的实现方式</a>采用了另外一种解决方式解决串行promise，后面接着研究下，有兴趣也可以自行看下。\\n实现promise应该有下面几个要点：</p>\\n<ol>\\n<li>函数的顺序执行</li>\\n<li>处理好状态（这部分感觉我的方法跟promiseA的状态要求有点偏差）</li>\\n<li>链式调用\\n这个例子只是根据promise的执行方式实现大概的功能，后面或许会根据promise规范去实现一个比较规范的demo。</li>\\n</ol>\\n<h2>参考</h2>\\n<ul>\\n<li><a href=\\\"https://promisesaplus.com/#requirements\\\">Promises/A+</a></li>\\n<li><a href=\\\"http://tech.meituan.com/promise-insight.html\\\">剖析 Promise 之基础篇</a></li>\\n<li><a href=\\\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\\\">Javascript异步编程的4种方法</a></li>\\n</ul>\",\"htmlExcerpt\":\"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\\\"https://promisesaplus.com/\\\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\\n<h1>初步构建一个Promise</h1>\\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\\n<pre><code class=\\\"language-javascript\\\">// 例1\\nfunction getAsyncData() {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve('promise done!')\\n        }, 1000)\\n    })\\n}\\n\\ngetAsyncData().then(function(result) {\\n    console.log(result);\\n}).then(function() {\\n    console.log('done too!');\\n})\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"前端单元测试&Mocha指北\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":null,\"path\":\"/post/unit-test\"},\"excerpt\":\"…\",\"headings\":[{\"depth\":1,\"value\":\"什么是单元-测试?\"},{\"depth\":1,\"value\":\"为什么要写单元测试？\"},{\"depth\":1,\"value\":\"干了这杯 \\\"Mocha\\\"\"},{\"depth\":2,\"value\":\"举个例子\"},{\"depth\":1,\"value\":\"小结\"}],\"html\":\"<h1>什么是单元-测试?</h1>\\n<ul>\\n<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>\\n<li>而测试，就是测试啦。</li>\\n</ul>\\n<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>\\n<h1>为什么要写单元测试？</h1>\\n<p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>\\n<!--more-->\\n<h1>干了这杯 \\\"Mocha\\\"</h1>\\n<p>mocha是一个js测试框架，除此外，类似的测试框架还有Jasmine、Karma、Tape等，至于为什么要介绍Mocha？因为我只懂这一个。\\n上代码前还要普及一下两个概念</p>\\n<ul>\\n<li><a href=\\\"https://zh.wikipedia.org/wiki/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91\\\">BDD（Behavior Driven Development）</a>\\nBDD意为行为驱动开发，是一种敏捷软件开发技术，具体内容大家可以参考wikipedia的解释。</li>\\n<li><a href=\\\"https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)\\\">Assertion 断言</a>\\n断言，就是判断代码的执行结果与预期是否一致，不一致就抛出错误，说得简单点就是判断程序的真假。</li>\\n</ul>\\n<h2>举个例子</h2>\\n<pre><code class=\\\"language-javascript\\\">// add.js\\nfunction add(a, b) {\\n    return a + b\\n}\\nmodule.exports = add\\n</code></pre>\\n<p>通常测试脚本要与测试源码同名，比如add.js的测试脚本就是add.test.js</p>\\n<pre><code class=\\\"language-javascript\\\">// add.test.js\\nconst add = require('./add.js')\\nconst expect = require('chai').expect\\n\\ndescribe('加法函数测试', function() {\\n    it('1 + 1 等于 2', function() {\\n        expect(add(1, 1)).to.be.equal(2)\\n    })\\n    it('返回值是Number', function() {\\n        expect(add(1, 1)).to.be.a('number')\\n    })\\n})\\n</code></pre>\\n<p>上面代码块就是测试脚本，可独立运行，测试脚本中应该包括一个或多个<code>describe</code>块，每个<code>describe</code>块应包括多个<code>it</code>块。\\n<code>describe</code>是测试套件，这个方法需要传两个参数，第一个为测试套件的名称<code>('加法函数测试')</code>，第二个是执行函数。\\n<code>it</code>块是测试用例，表示一个单独的测试，是测试的最小单位，第一个参数是测试用例的名称('1 + 1 等于 2')，第二个是执行函数。</p>\\n<p>然后在terminal下执行<code>mocha add.test.js</code></p>\\n<pre><code class=\\\"language-terminal\\\">$ mocha add.test.js\\n\\n   加法函数测试\\n     √ 1 + 1 等于 2\\n     √ 返回值是Number\\n   2 passing (12ms)\\n</code></pre>\\n<p>如果我们改变一下<code>add.js</code></p>\\n<pre><code class=\\\"language-javascript\\\">// add.js\\nfunction add(a, b) {\\n    return a * b\\n}\\nmodule.exports = add\\n</code></pre>\\n<p>然后再执行一下<code>mocha add.test.js</code></p>\\n<pre><code class=\\\"language-terminal\\\">$ mocha add.test.js\\n\\n   加法函数测试\\n     √ 1 + 1 等于 2\\n     1) 返回值是Number\\n   1 passing (8ms)\\n   1 failing\\n\\n   1) 加法函数测试 返回值是Number:\\n       AssertionError: expected 2 to equal 3\\n       + expected - actual\\n\\n       -2\\n       +3\\n\\n       at Context.it(add.test.js:6:27)\\n</code></pre>\\n<p>这里也可以很明显看出哪个测试用例报错、还有报错的位置，这样在开发的时候开发人员就能很容易定位错误。</p>\\n<h1>小结</h1>\\n<p>从上面一个简单的例子可以看出，利用mocha实现自动化测试是很简单的。虽然前期开发需要花一点时间去写单元测试，但是后面提供的便利性足以将其弥补。</p>\",\"htmlExcerpt\":\"\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"使用nodejs写一个命令行程序\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":[\"nodejs\",\"bash\"],\"path\":\"/post/node-command-app\"},\"excerpt\":\"原文译自 Smashing Magazine  --  [How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/0…\",\"headings\":[{\"depth\":2,\"value\":\"“Hello World”\"},{\"depth\":2,\"value\":\"处理命令行参数\"},{\"depth\":2,\"value\":\"运行时输入参数\"},{\"depth\":2,\"value\":\"模拟发送邮件\"},{\"depth\":2,\"value\":\"变成shell命令\"}],\"html\":\"<blockquote>\\n<p>原文译自<a href=\\\"https://www.smashingmagazine.com/\\\">Smashing Magazine</a> -- <a href=\\\"https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/\\\">[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)</a></p>\\n</blockquote>\\n<p>相信很多前端都听说过或者使用过<a href=\\\"http://www.gulpjs.com.cn/\\\">Gulp</a>, <a href=\\\"https://cli.angular.io/\\\">Angular CLI</a>, <a href=\\\"https://cordova.apache.org/\\\">Cordova</a>, <a href=\\\"http://yeoman.io/\\\">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code>ng new &#x3C;project-name></code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>\\n<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href=\\\"https://github.com/sendgrid/sendgrid-nodejs\\\">SendGrid Api</a>模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令</p>\\n<!--more-->\\n<hr>\\n<h2>“Hello World”</h2>\\n<p>开始前，首先你得有node，如果没有，请自行安装下。node中自带npm，使用<a href=\\\"https://www.npmjs.com/\\\">npm</a>能安装许多开源的node模块。首先，使用npm创建一个node项目</p>\\n<pre><code class=\\\"language-shell\\\">$ npm init\\nname: broadcast\\nversion: 0.0.1\\ndescription: CLI utility to broadcast email\\nentry point: broadcast.js\\n</code></pre>\\n<p>除这些参数外，npm还提供了其他如Git repository等参数，可根据自身需求设置输入。执行完<code>npm init</code>后，会发现在同目录下生成了一个<code>package.json</code>文件，文件里面包含了上面命令输入的信息。配置内容信息可以在<a href=\\\"https://docs.npmjs.com/files/package.json\\\">package.json文档</a>中找到。</p>\\n<p>然后，还是从最简单的Hello World入手。首先在同目录下建一个<code>broadcast.js</code>文件</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\nconsole.log('Hello World!')\\n</code></pre>\\n<p>然后在terminal中执行</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast\\nHello World!\\n</code></pre>\\n<p>well done, 根据<a href=\\\"https://docs.npmjs.com/files/package.json\\\">package.json文档</a>，我们可以找到一个<code>dependencies</code>参数，在这参数中你可以找到所有这项目需要用到的第三方模块和它们的版本号，上面也有提及到，我们需要用到模块去开发这个工具。最后开发完成，<code>package.json</code>应该如下</p>\\n<pre><code class=\\\"language-json\\\">{\\n    \\\"name\\\": \\\"broadcast\\\",\\n    \\\"version\\\": \\\"0.0.1\\\",\\n    \\\"description\\\": \\\"CLI utility to broadcast emails\\\",\\n    \\\"main\\\": \\\"broadcast.js\\\",\\n    \\\"license\\\": \\\"MIT\\\",\\n    \\\"dependencies\\\": {\\n        \\\"chalk\\\": \\\"^1.1.3\\\",\\n        \\\"commander\\\": \\\"^2.9.0\\\",\\n        \\\"csv\\\": \\\"^1.1.0\\\",\\n        \\\"inquirer\\\": \\\"^2.0.0\\\"\\n    }\\n}\\n</code></pre>\\n<p>这几个模块 <a href=\\\"https://github.com/chalk/chalk\\\">Chalk</a>, <a href=\\\"https://github.com/tj/commander.js\\\">Commander</a>, <a href=\\\"https://github.com/sboudrias/Inquirer.js\\\">Inquirer</a>, <a href=\\\"http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/\\\">CSV</a>的具体用处跟其他参数，可以自行查看。</p>\\n<h2>处理命令行参数</h2>\\n<p>node原生也有读取命令行的函数<a href=\\\"https://nodejs.org/docs/latest/api/process.html\\\"><code>process.argv</code></a>，但是解析参数是个繁琐的工作，所以我们会使用<a href=\\\"https://github.com/tj/commander.js\\\">Commander</a>去替代这些工作。Commande的另外一个好处就是不用额外的去写一个<code>--help</code>函数，只要定义了其他参数，<code>--help</code>函数就会自动生成。首先安装一下Commander和其他package</p>\\n<pre><code class=\\\"language-shell\\\">$ npm install commander chalk csv inquirer --save\\n</code></pre>\\n<p>然后修改<code>broadcast.js</code></p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast\\nconst program = require('commander')\\n\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'list of customers in CSV file')\\n    .parse(process.argv)\\n\\nconsole.log(program.list)\\n</code></pre>\\n<p>从上面可以看出，处理一个参数是十分简单的。我们定义了一个<code>--list</code>的参数，现在我们就能通过<code>--list</code>参数获取到命令行传过来的值。在这程序中，list应该是接收一个csv的地址参数，然后打印在console中。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --list ./test.csv\\n./test.csv\\n</code></pre>\\n<p>从js中可以看到还有一个<code>version</code>参数，所以我们可以使用<code>--version</code>读取版本号。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --version\\n0.0.1\\n</code></pre>\\n<p>又或者能使用<code>--help</code>获取app能接收的参数</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --help\\n\\n  Usage: broadcast [options]\\n\\n  Options:\\n\\n    -h, --help                 output usage information\\n    -V, --version              output the version number\\n    -l, --list &#x3C;list>          list of customers in CSV file\\n</code></pre>\\n<p>现在我们已经能够接收到命令行传递过来的参数了，下面我们会利用接收到的CSV文件地址，并使用<a href=\\\"http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/\\\">CSV</a>模块处理CSV文件的内容。\\n我们会使用下面的比哦啊哥内容作为CSV文件的内容。使用CSV模块，会读取内容，并显示各列的内容。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>First name</th>\\n<th>Last name</th>\\n<th>Email</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Dwight</td>\\n<td>Schrute</td>\\n<td>dwight.schrute@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Jim</td>\\n<td>Halpert</td>\\n<td>jim.halpert@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Pam</td>\\n<td>Beesly</td>\\n<td>pam.beesly@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Ryan</td>\\n<td>Howard</td>\\n<td>ryan.howard@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Stanley</td>\\n<td>Hudson</td>\\n<td>stanley.hudson@dundermifflin.com</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>现在，更新下<code>broadcast.js</code>，使用CSV读取内容并打印在console</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\nconst program = require('commander')\\nconst csv = require('csv')\\nconst fs = require('fs')\\n\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'List of customers in CSV')\\n    .parse(process.argv)\\n\\nconst stream = fs.createReadStream(program.list)\\nstream\\n    .pipe(csv.parse({ delimiter : \\\",\\\" }))\\n    .on('data', function(data) {\\n         const firstname = data[0]\\n         const lastname = data[1]\\n         const email = data[2]\\n\\n         console.log(firstname, lastname, email)\\n    })\\n</code></pre>\\n<p>除csv模块外，还使用了node的<a href=\\\"https://nodejs.org/dist/latest-v7.x/docs/api/fs.html\\\">File System</a>模块读取文件内容，csv的<code>parse</code>方法把列数据解析为数组，然后在terminal中运行一下命令</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast.js --list ./test.csv\\nDwight Schrute dwight.schrute@dundermifflin.com\\nJim Halpert jim.halpert@dundermifflin.com\\nPam Beesly pam.beesly@dundermifflin.com\\nRyan Howard ryan.howard@dundermifflin.com\\nStanley Hudson stanley.hudson@dundermifflin.com\\n</code></pre>\\n<h2>运行时输入参数</h2>\\n<p>上面已经实现了获取命令行参数，但如果想在运行时候接收参数值的话我们就需要另外一个模块<a href=\\\"https://github.com/sboudrias/Inquirer.js\\\">inquirer.js</a>，通过这个模块，用户可以自定义多种参数类型，如文本，密码，单选或者多选列表等。</p>\\n<p>下面的demo会通过inquirer接收邮件发送人的名字，email还有邮件主题。</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\n...\\nconst inquirer = require('inquirer')\\nconst questions = [\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"sender.email\\\",\\n    message : \\\"Sender's email address - \\\"\\n  },\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"sender.name\\\",\\n    message : \\\"Sender's name - \\\"\\n  },\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"subject\\\",\\n    message : \\\"Subject - \\\"\\n  }\\n]\\n\\nprogram\\n  .version('0.0.1')\\n  .option('-l, --list [list]', 'List of customers in CSV')\\n  .parse(process.argv)\\n\\n// 储存CSV数据\\nconst contactList = []\\nconst stream = fs.createReadStream(program.list)\\n    .pipe(csv.parse({ delimiter : \\\",\\\" }))\\n\\nstream\\n  .on('error', function (err) {\\n    return console.error(err.message)\\n  })\\n  .on('data', function (data) {\\n    let name = data[0] + \\\" \\\" + data[1]\\n    let email = data[2]\\n    contactList.push({ name : name, email : email })\\n  })\\n  .on('end', function () {\\n    inquirer.prompt(questions).then(function (answers) {\\n      console.log(answers)\\n    })\\n  })\\n</code></pre>\\n<p>Inquire.js的<code>prompt</code>方法接受一个数组参数，数组里可以自定义运行时需要接受的问题参数，在这demo里面，我们想知道发送者的名字还要email还有邮件主题，所以定义了一个<code>questions</code>的数组来储存问题，从对象里面可以看到有一个<code>input</code>的参数，除此外还可以接受<code>password</code>等其他类型，具体可以查询一下<a href=\\\"https://github.com/SBoudrias/Inquirer.js/\\\">inquirer的文档</a>。此外，参数<code>name</code>保存input的key值。<code>prompt</code>方法会返还一个promise对象，promise中会返回一个<code>answer</code>变量，里面带有刚才输入的值。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast -l input/employees.csv\\n? Sender's email address -  kitssang_demo@163.com\\n? Sender's name -  kit\\n? Subject - Hello World\\n{ sender:\\n   { email: '  kitssang_demo@163.com',\\n     name: 'kit' },\\n  subject: 'Hello World' }\\n</code></pre>\\n<h2>模拟发送邮件</h2>\\n<p>由于原文使用的<code>sendgrid</code>没有跑通，所以只组装了一下数据模拟了发送邮件。原本的第五部分也在这里一起用上了。</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\n...\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'list of customers in CSV file')\\n    .parse(process.argv)\\n\\nconst sendEmail = function(to, from, subject) {\\n    const sender = chalk.green(`${from.name}(${from.email})`)\\n    const receiver = chalk.green(`${to.name}(${to.email})`)\\n    const theme = chalk.blue(subject)\\n\\n    console.log(`${sender} send a mail to ${receiver} and the subject of the email is ${theme}`)\\n}\\n\\n// 储存CSV数据\\nlet concatList = []\\nconst stream = fs.createReadStream(program.list)\\n  .pipe(csv.parse({\\n    delimiter: ','\\n  }))\\n  .on('data', function(data) {\\n    const name = data[0] + ' ' + data[1]\\n    const email = data[2]\\n\\n    concatList.push({\\n      name: name,\\n      email: email\\n    })\\n  })\\n  .on('end', function() {\\n    inquirer.prompt(questions).then((ans) => {\\n      for (let i = 0; i &#x3C; concatList.length; i++) {\\n        sendEmail(concatList[i], ans.sender, ans.subject)\\n      }\\n    }).catch((err) => {\\n      console.log(err)\\n    })\\n  })\\n</code></pre>\\n<p>由于没有异步请求，<code>async</code>模块没有用上，另外使用了<code>chalk</code>模块改变了console打印结果的颜色。</p>\\n<h2>变成shell命令</h2>\\n<p>至此，整个工具已经基本完成，但是如果想像一个普通的shell命令(不加<code>$ node xx</code>)执行，还需要做以下操作。首先，添加<a href=\\\"https://zh.wikipedia.org/wiki/Shebang\\\">shebang</a>在js的头部，让shell知道如何执行这个文件。</p>\\n<pre><code class=\\\"language-javascript\\\">#!/usr/bin/env node\\n\\n// broadcast.js\\nconst program = require(\\\"commander\\\")\\nconst inquirer = require(\\\"inquirer\\\")\\n...\\n</code></pre>\\n<p>然后再配置一下<code>package.json</code>使代码可运行</p>\\n<pre><code class=\\\"language-json\\\">…\\n  \\\"description\\\": \\\"CLI utility to broadcast emails\\\",\\n  \\\"main\\\": \\\"broadcast.js\\\",\\n  \\\"bin\\\" : {\\n    \\\"broadcast\\\" : \\\"./broadcast.js\\\"\\n  }\\n…\\n</code></pre>\\n<p>从代码可以看到加了一个<a href=\\\"https://docs.npmjs.com/files/package.json#bin\\\"><code>bin</code></a>的参数，这个参数可以使broadcast命令与broadcast.js建立连接。</p>\\n<p>最后一步，在全局安装一下依赖包。在项目目录运行一下下面的命令。</p>\\n<pre><code class=\\\"language-shell\\\">$ npm install -g\\n</code></pre>\\n<p>然后测试一下命令</p>\\n<pre><code class=\\\"language-shell\\\">$ broadcast --help\\n</code></pre>\\n<p>需要注意的是，在开发时候如果使用<code>commaner</code>默认给出的命令执行<code>broadcast</code>则在代码中所做的任何更改都是看不见的。假如输入<code>which broadcast</code>，你会发现地址不是你当前目录，所以这时应该要用<code>npm link</code>去查看命令的目录映射。</p>\",\"htmlExcerpt\":\"\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"React-todo demo\",\"date\":\"2016-03-02\",\"category\":[\"js framework\"],\"tags\":[\"React\",\"Webpack\",\"js框架\"],\"path\":\"/post/react-todo\"},\"excerpt\":\"好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。 小科普 什么是React? 按官方解释，框架属于MVC中的view…\",\"headings\":[{\"depth\":3,\"value\":\"小科普\"},{\"depth\":3,\"value\":\"Demo功能需求\"},{\"depth\":3,\"value\":\"开始\"},{\"depth\":4,\"value\":\"配置webpack\"},{\"depth\":4,\"value\":\"上代码\"},{\"depth\":4,\"value\":\"App生命 - state\"},{\"depth\":4,\"value\":\"其他组件\"},{\"depth\":3,\"value\":\"总结\"}],\"html\":\"<p>好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。</p>\\n<!--more-->\\n<h3>小科普</h3>\\n<p>什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！</p>\\n<h3>Demo功能需求</h3>\\n<ul>\\n<li>input输入内容，回车键或按钮增加一条todo</li>\\n<li>checkbox添加完成状态</li>\\n<li>移动到列表时显示删除</li>\\n<li>显示todo总数和已经完成数</li>\\n<li>list全选</li>\\n<li>清除已完成</li>\\n<li>添加动画效果</li>\\n</ul>\\n<h3>开始</h3>\\n<p>开始需要npm安装一下等下要用的packages，如果是checkout我的demo，就动动手指头，install一下，我的demo地址是<a href=\\\"https://github.com/kitwon/react-todo\\\">https://github.com/kitwon/react-todo</a></p>\\n<pre><code class=\\\"language-bash\\\">$npm install\\n</code></pre>\\n<h4>配置webpack</h4>\\n<p>所有东西安装完成之后首先就是配置<a href=\\\"http://webpack.github.io/docs/\\\">webpack</a></p>\\n<pre><code class=\\\"language-javascript\\\">var path = require('path');\\n\\nmodule.exports = {\\n    entry : \\\"./src/entry.js\\\",\\n    output : {\\n        path : path.join(__dirname, \\\"out\\\"),\\n        publicPath : \\\"./out/\\\",\\n        filename : \\\"bundle.js\\\"\\n    },\\n    externals : {\\n        react : \\\"React\\\"\\n    },\\n    module : {\\n        loaders : [\\n            { test : /\\\\.js$/, loader : \\\"jsx\\\",include: /src/ },\\n            { test : /\\\\.css$/, loader : \\\"style!css\\\" },\\n            { test : /\\\\.less$/, loader : \\\"style!css!less\\\" },\\n            { test : /\\\\.(jpg|png)$/, loader : \\\"url?limit=8192\\\" }\\n        ]\\n    }\\n}\\n</code></pre>\\n<p>从上面可以看到，webpack的入口文件是entry.js，打包输出的文件是bundle.js，external属性是告诉webpack，当API已经存在的时候，使用全局变量，并不作任何操作。</p>\\n<p>loader的话没啥，看文档就知道，各种编译打包。具体使用方法可以看官方文档。</p>\\n<h4>上代码</h4>\\n<pre><code class=\\\"language-javascript\\\">var React = require('React'),\\n    ReactDOM = require('react-dom');\\n\\nrequire('../less/app.less');\\n\\nvar AppFooter = require('./AppFooter'),\\n    AppHeader = require('./AppHeader'),\\n    ItemMain = require('./ItemMain');\\n\\n\\nvar App = React.createClass ({\\n    getInitialState : function() {\\n        return {\\n            todoItem : [],\\n            isAllChecked : false\\n        }\\n    },\\n    //添加todo\\n    addItem : function(item) {\\n        var todoList = this.state.todoItem.push(item);\\n        this.setState({isAllChecked : false});\\n        this.forceUpdate();\\n    },\\n     //更改todo状态\\n    changeTodoState : function(index, isDone, isAllChange) {\\n        // isAllChange = false;\\n        if(isAllChange) {\\n            this.setState({\\n                todoItem: this.state.todoItem.map(function(todo) {\\n                    todo.isDone = isDone;\\n                    return todo;\\n                }),\\n                isAllChecked : isDone\\n            })\\n        }else {\\n            this.state.todoItem[index].isDone = isDone;\\n            this.allChecked();\\n            this.forceUpdate();\\n        }\\n    },\\n    //删除todo\\n    deleteTodo : function(index) {\\n        var newTodo = this.state.todoItem.splice(index, 1);\\n        this.setState({todoList: newTodo});\\n    },\\n    //清楚已完成\\n    clearDone : function() {\\n        var doneList = this.state.todoItem.filter(function(item) {\\n            return item.isDone === false;\\n        })\\n        this.setState({todoItem: doneList, isAllChecked: false});\\n    },\\n    //全部完成\\n    allChecked : function() {\\n        var allCheck = this.state.todoItem.every(function(item) {\\n            return item.isDone === true;\\n        })\\n        if (allCheck) {\\n            this.setState({isAllChecked : true})\\n        };\\n    },\\n        render : function(){\\n            var props = {\\n                todoLength : this.state.todoItem.length || 0,\\n                doneLength : this.state.todoItem.filter(function(item) {\\n                    return item.isDone === true;\\n                }).length || 0\\n            };\\n                return (\\n                    &#x3C;div className=\\\"panel\\\">\\n                        &#x3C;header  className=\\\"mainHeader\\\">&#x3C;h2>Webpack + React TODO Demo&#x3C;/h2>&#x3C;/header>\\n                        &#x3C;AppHeader addItem={this.addItem}/>\\n                        &#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\\n                            &#x3C;AppFooter {...props} isAllChecked={this.state.isAllChecked} clearDone={this.clearDone} changeAllState={this.changeTodoState} />\\n                    &#x3C;/div>\\n                )\\n        }\\n})\\n\\nReactDOM.render(&#x3C;App/>, document.getElementById(\\\"app\\\"));  //渲染\\n</code></pre>\\n<p>从代码上面可以看到各种require，没加载commonjs、seajs或其他模块化工具，为什么能直接require呢，而且还有require less，没错，webpack就是那么暴力！js后面都会打包好一个文件，样式都会加载到html里面，做spa时候，和react简直绝配。</p>\\n<h4>App生命 - state</h4>\\n<p>React主流思想就是父组件控制state，然后通过props传递给子组建，所以简单来说界面就像状态机，只要更新state，然后根据新的state重新渲染界面，不需要操作dom，所以react高性能原因也是因为这个。\\n从最上代码就可以看出父组件中的定义的方法基本是整个todo的功能了，然后render方法即渲染html和组件。</p>\\n<pre><code class=\\\"language-javascript\\\">&#x3C;ItemMain itemList={this.state.todoItem} changeTodoState={this.changeTodoState} deleteTodo={this.deleteTodo} />\\n</code></pre>\\n<p>然后取一小段渲染组件代码（上面代码）就可发现，父组件向ItemMain这个组件传了4个属性，其中itemList为state，只要todoItem一更新，react就会重新渲染这个组件，其他三个为方法，方法更新也会重新渲染组件。</p>\\n<pre><code class=\\\"language-javascript\\\">// ItemMain.js\\nvar React = require('React');\\nvar Items = require('./Items');\\n\\nvar ItemMain = React.createClass({\\n    render : function() {\\n        var _this = this;\\n        return (\\n            &#x3C;section>\\n                &#x3C;ul className=\\\"itemList\\\">\\n                    {_this.props.itemList.map(function (todo, index) {\\n                        return (\\n                            &#x3C;Items {...todo} key={index} index={index} {..._this.props} />\\n                        )\\n                    &#x3C;!-- })} -->\\n                    &#x3C;!--这里不注释代码不高亮，比较奇葩，各位官人将就着看-->\\n                &#x3C;/ul>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = ItemMain;\\n</code></pre>\\n<p>看这里估计有点蒙，我自己看的时候也有点蒙，因为太久的代码了哈哈哈。\\n这个js只有一个循环Item的逻辑，首先看看<code>{...todo}</code>这个prop，这个是把itemList[i]中的<a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\\\">数组对象解构</a>，然后传到item里面，如果没有...这个字符，则需要</p>\\n<pre><code class=\\\"language-javascript\\\">    &#x3C;Items text={props.text} isDone={props.isDone} key={index} index={index} changeTodoState={proprs.changeTodoState} deleteTodo={props.deleteTodo} />\\n</code></pre>\\n<p>具体数据大家可以在代码里面console打印一下，这样印象会更深。</p>\\n<pre><code class=\\\"language-javascript\\\">// item.js\\nvar React = require('React');\\n\\nvar Items = React.createClass({\\n    handleChange : function() {\\n        var isDone = !this.props.isDone;\\n        this.props.changeTodoState(this.props.index, isDone);\\n    },\\n    handleDeleteTodo : function() {\\n        this.props.deleteTodo(this.props.index);\\n    },\\n    render : function() {\\n        var doneStyle = this.props.isDone ? {textDecoration: 'line-through'} : {textDecoration : 'none'};\\n        return (\\n            &#x3C;li key={this.props.key} onMouseOver={this.handlerMouseOver} onMouseOut={this.handlerMouseOut}>\\n                &#x3C;input type=\\\"checkbox\\\" checked={this.props.isDone} onChange={this.handleChange} />\\n                &#x3C;span style={doneStyle}>{this.props.text}&#x3C;/span>\\n                &#x3C;button className=\\\"btn btn-default delete-item\\\" onClick={this.handleDeleteTodo}>delete&#x3C;/button>\\n            &#x3C;/li>\\n        )\\n    }\\n})\\n\\nmodule.exports = Items;\\n</code></pre>\\n<p>这个就是js里面有两个方法，一个是改变状态，一个是删除当前todo，这这能发现，两个方法都是执行了又父组件传过来的方法，如下</p>\\n<pre><code class=\\\"language-javascript\\\">this.props.changeTodoState(this.props.index, isDone);\\n</code></pre>\\n<p>执行这个函数，state就会更新，react就会根据状态重新渲染组件</p>\\n<h4>其他组件</h4>\\n<pre><code class=\\\"language-javascript\\\">// AppHeader.js\\nvar React = require('React');\\n\\nvar AppHeader = React.createClass({\\n    getInitialState : function() {\\n        return {\\n            text : \\\"\\\"\\n        }\\n    },\\n    handlerKeyUp : function(event) {\\n        if(event.keyCode === 13) {\\n            var value = event.target.value;\\n            if(!value) return false;\\n\\n            var newTodoItem = {\\n                text : value,\\n                isDone : false\\n            }\\n\\n            event.target.value = \\\"\\\";\\n            this.setState({text: \\\"\\\"});\\n            this.props.addItem(newTodoItem);\\n        }\\n    },\\n    handleChange : function(event) {\\n        this.setState({text : event.target.value });\\n    },\\n    handlerClick : function(event) {\\n        var newTodoItem = {\\n            text : this.state.text,\\n            isDone : false\\n        }\\n        this.props.addItem(newTodoItem);\\n        this.setState({text: \\\"\\\"});\\n    },\\n    render : function() {\\n        return (\\n            &#x3C;section className=\\\"appHeader from-group\\\">\\n                &#x3C;input type=\\\"test\\\" className=\\\"form-control\\\" onKeyUp={this.handlerKeyUp} onChange={this.handleChange} placeholder=\\\"add one todo\\\" value={this.state.text}/>\\n                &#x3C;button className=\\\"btn btn-primary\\\" onClick={this.handlerClick}>add one&#x3C;/button>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = AppHeader;\\n</code></pre>\\n<pre><code class=\\\"language-javascript\\\">// AppHeader.js\\nvar React = require('React');\\n\\nvar AppFooter = React.createClass({\\n    handleClick : function() {\\n        this.props.clearDone();\\n    },\\n    handleAllState : function(event) {\\n        this.props.changeAllState(null, event.target.value, true);\\n    },\\n    render : function() {\\n        return (\\n            &#x3C;section className=\\\"appFooter\\\">\\n                &#x3C;div>\\n                    &#x3C;input type=\\\"checkbox\\\" checked={this.props.isAllChecked} onChange={this.handleAllState}/>\\n                    &#x3C;span>{this.props.doneLength}&#x3C;/span>已经完成 / &#x3C;span>{this.props.todoLength}&#x3C;/span>总数\\n                &#x3C;/div>\\n                &#x3C;button className=\\\"btn btn-default btn-tiny pull-right\\\" onClick={this.handleClick}>clean done&#x3C;/button>\\n            &#x3C;/section>\\n        )\\n    }\\n})\\n\\nmodule.exports = AppFooter;\\n</code></pre>\\n<p>Header Footer的方法都是大同小异，输入改变state，然后存起来，执行相应操作时候通过props的方法传给父组件，然后重新渲染界面。</p>\\n<h3>总结</h3>\\n<p>回头看代码，react的组件化相比现在的组件化思想真的先进很多。React通过父组件来控制状态，并通过props传递给子组件。因此我们能很容易看出我们的事件属于哪个组件管理，然后修改相应的方法，维护起来相当高效，相比现在的控制dom，每次修改按钮的方法，都需要先找到id或者class，然后绑定响应的方法，假如页面id或者class改变，页面逻辑又非常复杂的话，修改起来是相当麻烦的。\\nReact凭着出色的设计思想和性能，我相信不久就会成为主流的移动端开发方式，至于PC端，大天朝你懂的。</p>\",\"htmlExcerpt\":\"\\n\"}}],\"page\":3,\"pages\":3,\"total\":14,\"limit\":5,\"prev\":\"/blog/2\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-3.json\n// module id = 284\n// module chunks = 173394108556902"],"sourceRoot":""}