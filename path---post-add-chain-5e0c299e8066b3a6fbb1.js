webpackJsonp([0x6cb247a9bfab],{288:function(n,e){n.exports={data:{markdownRemark:{html:'<h1>题目</h1>\n<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现</p>\n<pre><code class="language-javascript">function add(x) {\n    var fn = function(y) {\n        return add(x + y);\n    }\n\n    return fn;\n}\n\nconsole.log(add(1)(2)(3))\n</code></pre>\n<!-- more -->\n<h1>实现方法</h1>\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\n<pre><code class="language-javascript">function add(x) {\n    var fn = function(y) {\n        return add(x + y);\n    }\n\n    fn.toString = function() {\n        return x;\n    }\n\n    return fn;\n}\n\n\n// chrome  function 6\n// firefox function add/fn\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\nconsole.log(add(1)(2)(3))\n\nconsole.log(add(1)(2)(3).toString()) // 6\n</code></pre>\n<p>由此看出在不同客户端下返回的结果并不一样，并不是完美的结果，但是查阅了其他资料并没有其他十分好的解决办法，估计这道题的考查点是关于js深度的，比如原生对象里面的基本方法和<code>alert</code>, <code>console</code>会自动执行toString等方法。</p>\n<p>另外，<code>valueOf</code>和<code>toString</code>方法其实是差不多的，返回的结果基本都是相同的，但是试了一下定义了两个不同的方法，发现总是会返回valueOf的值先，所以觉得toString应该是应用于valueOf的结果。</p>',frontmatter:{date:"May 28, 2017",path:"/post/add-chain",title:"js实现add(1)(2)(3)"},headings:[{depth:1,value:"题目"},{depth:1,value:"实现方法"}]}},pathContext:{prev:{title:"深入学习javascript--作用域",date:"2017-05-31",category:null,tags:null,path:"/post/js-scope"},next:{title:"Promise的简单实现",date:"2017-05-17",category:["前端"],tags:["javascript"],path:"/post/js-promise"}}}}});
//# sourceMappingURL=path---post-add-chain-5e0c299e8066b3a6fbb1.js.map