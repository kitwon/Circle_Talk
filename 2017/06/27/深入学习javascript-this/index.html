<!DOCTYPE html><html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0,  user-scalable=0" name="viewport"><title>KIT</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/index.min.css"></head><body><nav class="nav-button-list"><div class="btn menu show-canvas"><span class="icon-bar"></span></div><div class="btn top btn-go-top"><i class="ion-arrow-up-c"></i><span class="scroll-percentage">0%</span></div></nav><div class="main-wrap"><div class="container"><div class="row"><div class="col-lg-3 side-bar-left"><div class="sidebar-content"><div class="main-side-bar"><div class="header"><p>爱好上班，特长加班</p><p>求职中</p><p>catslove28@163.com</p></div><nav class="side-bar-nav"><a href="/" class="item"><span>首页</span></a><a href="/archives" class="item m"><span>归档</span></a><a href="/tags" class="item last unopen"><span>标签</span></a></nav></div><div class="card directory-card"><div class="header">文章目录</div><div class="directory"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#关于this"><span class="nav-number">1.</span> <span class="nav-text">关于this</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this的指向"><span class="nav-number">2.</span> <span class="nav-text">this的指向</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#绑定规则"><span class="nav-number">3.</span> <span class="nav-text">绑定规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#默认绑定"><span class="nav-number">3.1.</span> <span class="nav-text">默认绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式绑定"><span class="nav-number">3.2.</span> <span class="nav-text">隐式绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式丢失"><span class="nav-number">3.2.1.</span> <span class="nav-text">隐式丢失</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#显式绑定"><span class="nav-number">3.3.</span> <span class="nav-text">显式绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬绑定"><span class="nav-number">3.4.</span> <span class="nav-text">硬绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new绑定"><span class="nav-number">3.5.</span> <span class="nav-text">new绑定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#绑定优先级"><span class="nav-number">4.</span> <span class="nav-text">绑定优先级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#绑定例外"><span class="nav-number">5.</span> <span class="nav-text">绑定例外</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#被忽略的this"><span class="nav-number">5.1.</span> <span class="nav-text">被忽略的this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#间接引用"><span class="nav-number">5.2.</span> <span class="nav-text">间接引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软绑定"><span class="nav-number">5.3.</span> <span class="nav-text">软绑定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#箭头函数"><span class="nav-number">6.</span> <span class="nav-text">箭头函数</span></a></li></ol></div></div></div></div><div class="col-lg-9 main-content"><div class="post-detail-wrap content-wrap"><main class="post post-detail"><div class="post-header"><div class="header">深入学习javascript - this</div><section class="info"><div class="item"><i class="ion-android-calendar"></i><span>发表于 2017年6月27日</span></div><div class="item"><i class="ion-android-folder-open"></i><span>分类于 <a href="/categories/javascript/">javascript</a></span></div></section></div><article data-spy="scroll" data-target="panel1" class="content"><h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><p><code>this</code>应该是javascript中一个比较复杂的机制了，在日常工作中我们可能有意无意都会使用到这个机制，但是<code>this</code>的工作机制真正了解的可能只有皮毛，通过学习这一机制，能够提高对js代码的理解和阅读能力，还有对js程序设计模式有着更深的理解。</p>
<h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1><p>this是运行时进行绑定的，而不是编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>
<p>通过分析调用位置，就能知道this到底引用的是什么。所以，寻找调用位置就能弄清上面的问题，通过一个例子，就能很好地理解这个问题：</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function baz() {
  // 当前调用栈是 baz
  // 当前调用位置是全局作用域

  console.log(&#39;baz&#39;);
  bar(); // bar的调用位置
}

function bar() {
  // 当前的调用栈是 baz -&gt; bar
  // 当前的调用位置是baz

  console.log(&#39;bar&#39;);
  foo();
}

function foo() {
  // 当前的调用栈是 baz -&gt; bar -&gt; foo
  // 当前的调用位置是bar

  console.log(&#39;foo&#39;);
}

baz();
</code></pre>
<a id="more"></a>
<h1 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h1><p>除了像上面分析代码，还有一个最简单的方式就是分析调用工具。找到调用位置后，就能根据下面的4条规则来判断this如何绑定。</p>
<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
  console.log(this.a);
}

var a = 2;

foo(); // 2
</code></pre>
<p>从上面代码可以知道，<code>foo</code>的调用位置在全局中，不带任何修饰地调用，因此只能使用<strong>默认绑定</strong>。</p>
<p>在这里要注意一个细节，如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定。</p>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function  foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo
}

obj.foo(); // 2
</code></pre>
<p>从上代码可以看出<code>obj</code>，调用位置会使用<code>obj</code>上下文来引用函数，因此，可以说函数被调用时候<code>obj</code>对象“包含”它。当函数引用有上下文对象时，<strong>隐式绑定</strong> 规则会把函数引用调用中的<code>this</code>绑定到这个对象中。所以<code>this.a</code>与<code>obj.a</code>在此时是一样的。</p>
<p>对象属性应用链中只有最顶层或者说最后一层会影响调用位置。如下:</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
  console.log(this.a);
}

var obj2 = {
  a: 42,
  foo: foo
}

var obj1 = {
  a: 2,
  obj2: obj2
}

obj1.obj2.foo(); // 42
</code></pre>
<h3 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h3><p><strong>隐式丢失</strong> 就是隐式绑定的函数丢失绑定对象，然后应用<strong>默认绑定</strong>，从而把<code>this</code>绑定到全局对象或者<code>undefined</code>中，取决于是否严格模式。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo
}

var bar = obj.foo; // 函数别名

var a = &#39;oops, global&#39;;

bar(); // opps, global
</code></pre>
<p>或者在传入回调函数的时候：</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
  console.log(this.a);
}

function doFoo(fn) {
  fn();
}

var obj = {
  a: 2,
  foo: foo
}

var a = &#39;oops, global&#39;;

doFoo(obj.foo); // opps, global
</code></pre>
<p>传入函数就是一种隐式赋值，所以结果和上一个例子也是一样的。</p>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>使用<code>call</code>和<code>apply</code>方法对对象进行强制调用函数。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
  console.log(this.a);
}

var obj = {
  a: 2
}

foo.call(obj); // 2
</code></pre>
<p><code>call</code>和<code>apply</code>在绑定的机制基本是一样的，就是传参不一样，<code>call</code>为单独的参数，<code>apply</code>为数组。</p>
<h2 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h2><p>硬绑定为显式绑定的一个变种，能够解决丢失绑定的问题，先思考下面代码：</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
  console.log(this.a);
}

var obj = {
  a: 2
}

var bar = function() {
  foo.call(obj);
}

bar();
setTimeout(bar, 100); // 2

// 硬绑定的bar不能再修改它的this
bar.call(window);
</code></pre>
<p>可以创建一个可以重复使用的硬绑定函数：</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

// 辅助绑定函数
function bind(fn, obj) {
  return function() {
    return fn.apply(obj, arguments);
  }
}

var obj = {
  a: 2
};

var bar = bind(foo, obj);

var b = bar(3); // 2 3
console.log(b); // 5
</code></pre>
<p>其实在ES5中已经提供了原生的<code>Fucntion.prototype.bind</code>的方法，可以直接使用：</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

var obj = {
  a: 2
}

var bar = foo.bind(obj);

var b = bar(3);
console.log(b);
</code></pre>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>JavaScript中的new并不想其他oo语言那样会实例化一个类，只是使用new操作符调用普通的函数，在这个调用也会对this进行绑定。<br>使用new调用函数时，会自动执行下面操作：</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个对象会被执行[[原型]]连接。</li>
<li>这个新对象会绑定到函数调用的this。</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<p>看下面代码：</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo(a) {
  this.a = a;
}

var bar = new foo(2);

console.log(bar.a);
</code></pre>
<p>像这样普通的new调用<code>foo(...)</code>时，会构造一个新的对象并把它绑定到<code>foo(..)</code>调用中的this上。这个就称为new绑定。</p>
<h1 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h1><p>绑定优先级按照下面的顺序来判断：</p>
<ol>
<li>函数是否在new中调用(new绑定)？如果是的话this绑定的是新创建的对象。<br><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="javascript">var bar = new foo();
</code></pre>
</li>
<li>函数是否通过call、apply(显示绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。<br><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="javascript">var bar = foo.call(obj2);
</code></pre>
</li>
<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是哪个上下文对象。<br><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="javascript">var bar = obj.foo();
</code></pre>
</li>
<li>若果都不是的话，适用默认绑定，严格模式下绑定到<code>undefined</code>，否则就绑到全局对象。<br><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="javascript">var bar = foo();
</code></pre>
</li>
</ol>
<h1 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h1><p>在某些场景下this的绑定用上面的规制是判断不了的，可能认为是其他绑定规则，实际引用的是<a href="#默认绑定">默认绑定</a>规则。</p>
<h2 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h2><p>如果把<code>null</code>或者<code>undefined</code>作为this的绑定对象传入call、apply或者bind中，这些值在调用时会被忽略，实际应用的是默认规则。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function fOO() {
  console.log(this.a);
}

var a = 2;

foo.call(null); // 2
</code></pre>
<p>这种情况虽然并不多见，但是使用apply展开数组或者适用<code>bind(...)</code>进行<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="external">柯里化</a>的时候会用到。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo(a, b) {
  console.log(&#39;a: &#39; + a + &#39;b: &#39; + b);
}

foo.apply(null, [2, 3]); // a: 2, b: 3

// 适用bind(..) 进行柯里化
var bar = foo.bind(nul, 2);
bar(3); // a: 2, b: 3
</code></pre>
<p><strong>注意：很多时候新建一个空对象<code>var n = Object.creat(null)</code>代替<code>null</code>更为安全。</strong></p>
<h2 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h2><p>间接引用上面介绍<a href="#隐式丢失">隐式丢失</a>的时候也有举过例子，调用间接引用的函数也会造成绑定例外。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
  console.log(this.a);
}

var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };

o.foo(); // 3
(p.foo = o.foo)(); // 2
</code></pre>
<h2 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h2><p>软绑定可以实现硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改this的能力。具体使用方式如下：</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
  console.log(&#39;name：&#39; + this.name);
}

var obj = { name: &#39;obj&#39; };
var obj2 = { name: &#39;obj2&#39; };
var obj3 = { name: &#39;obj3&#39; };

// 稍后实现softBind
var fooOBJ = foo.softBind(obj);

fooOBJ(); // name: obj

obj2.foo = foo.softBind(obj);
obj2.foo(); // name: obj2

fooOBJ.call(obj3); // name: obj3

setTimeout(obj2.foo, 10); // name: obj 应用了软绑定
</code></pre>
<p>可以看到，软绑定的<code>foo()</code>可以手动将this绑定到<code>obj2</code>或者<code>obj3</code>上，但如果应用默认绑定，则会将this绑定到obj中。</p>
<p><code>softBind</code>的实现方式如下:</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">if(!Function.prototype.softBind) {
  Function.prototype.softBind = function(obj) {
    var fn = this;
    var curried = [].slice.call(arguments, 1);
    var bound = function() {
      return fn.apply(!this || this === (window || global) ? obj: this);

      curried.concat.apply(curried, arguments)
    };

    bound.prototype = Object.create(fn.prototype);
    return bound;
  }
}
</code></pre>
<p>这个函数首先检查调用时候的this，如果this绑定到全局或者undefined中，那就把指定的默认对象<code>obj</code>绑定到this，否则不修改this。<strong>ES5中的bind()已经实现此部分功能</strong>。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>前面接受的<a href="#绑定优先级">四条规则</a>可以包含所有正常函数。但是ES6中的<strong>箭头函数</strong>则无法使用这些规则。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
  return (a) =&gt; {
    // this继承foo
    console.log(this.a);
  };
}

var obj1 = {
  a: 2
};

var obj2 = {
  a: 3
};

var bar = foo.call(obj1);
bar.call(obj2); // 2，不是3
</code></pre>
<p><code>foo()</code>内部的箭头函数会捕获调用<code>foo()</code>时的this。由于<code>foo()</code>的this绑定到<code>obj1</code>,<code>bar</code>的this也会绑定到<code>obj1</code>，箭头函数的绑定无法被修改。(new也不行)</p>
<p>在ES6出现之前我们经常写的一种模式与箭头函数是几乎相同的：</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function foo() {
    var self = this;
    setTimeout(function() {
        console.log(self.a);
    }, 100);
}

var obj = {
    a: 2
};

foo.call(obj); // 2
</code></pre>
<p><code>var self = this</code>和箭头函数从本质来说是想取代this的机制，如果代码中大多数使用<code>var self = this;</code>，那么应该完全使用词法作用域或箭头函数，抛弃this风格的代码。相反，如果使用this，则可以上方的绑定机制。</p>
</article></main><div class="page-footer"><div class="post-pagination"><a href="/2017/06/24/webpack2新特性&amp;迁移/">webpack2新特性&迁移  <i class="ion-arrow-right-c"></i></a></div></div></div></div></div></div><div class="container-fluid copyright"><div> <span>©   2015 - 2016</span><i class="icon ion-ios-nutrition"></i><span>Kit</span></div><div><span>power by </span><span><a href="//hexo.io">hexo.</a></span><span>Design By Kit.</span></div></div></div><script src="/js/vendor.min.js"></script><script src="/js/post.min.js"></script></body></html>