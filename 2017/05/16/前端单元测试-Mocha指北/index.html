<!DOCTYPE html><html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0,  user-scalable=0" name="viewport"><link rel="stylesheet" href="/css/index.min.css"></head><body><nav class="nav-button-list"><div class="btn menu show-canvas"><span class="icon-bar"></span></div><div class="btn top btn-go-top"><i class="ion-ios-arrow-up"></i></div></nav><div class="off-canvas-wrap"><div class="off-canvas-content"><main class="post-container"><div class="post"><header class="post-header"><h1 class="post-title">前端单元测试&Mocha指北</h1><section class="post-meta"><i class="ion-ios-clock-outline"></i><time class="post-date">May 16, 2017</time><span class="dot-sep">·</span><i class="ion-ios-pricetags-outline"></i></section></header><article data-spy="scroll" data-target="panel1" class="content"><h1 id="什么是单元-测试"><a href="#什么是单元-测试" class="headerlink" title="什么是单元-测试?"></a>什么是单元-测试?</h1><ul>
<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>
<li>而测试，就是测试啦。</li>
</ul>
<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>
<h1 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h1><p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。<br>又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>
<a id="more"></a>
<h1 id="干了这杯-“Mocha”"><a href="#干了这杯-“Mocha”" class="headerlink" title="干了这杯 “Mocha”"></a>干了这杯 “Mocha”</h1><p>mocha是一个js测试框架，除此外，类似的测试框架还有Jasmine、Karma、Tape等，至于为什么要介绍Mocha？因为我只懂这一个。<br>上代码前还要普及一下两个概念</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91" target="_blank" rel="external">BDD（Behavior Driven Development）</a><br>BDD意为行为驱动开发，是一种敏捷软件开发技术，具体内容大家可以参考wikipedia的解释。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F" target="_blank" rel="external">Assertion 断言</a>)<br>断言，就是判断代码的执行结果与预期是否一致，不一致就抛出错误，说得简单点就是判断程序的真假。</li>
</ul>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// add.js
function add(a, b) {
    return a + b
}
module.exports = add
</code></pre>
<p>通常测试脚本要与测试源码同名，比如add.js的测试脚本就是add.test.js</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// add.test.js
const add = require(&#39;./add.js&#39;)
const expect = require(&#39;chai&#39;).expect

describe(&#39;加法函数测试&#39;, function() {
    it(&#39;1 + 1 等于 2&#39;, function() {
        expect(add(1, 1)).to.be.equal(2)
    })
    it(&#39;返回值是Number&#39;, function() {
        expect(add(1, 1)).to.be.a(&#39;number&#39;)
    })
})
</code></pre>
<p>上面代码块就是测试脚本，可独立运行，测试脚本中应该包括一个或多个<code>describe</code>块，每个<code>describe</code>块应包括多个<code>it</code>块。<br><code>describe</code>是测试套件，这个方法需要传两个参数，第一个为测试套件的名称<code>(&#39;加法函数测试&#39;)</code>，第二个是执行函数。<br><code>it</code>块是测试用例，表示一个单独的测试，是测试的最小单位，第一个参数是测试用例的名称(‘1 + 1 等于 2’)，第二个是执行函数。</p>
<p>然后在terminal下执行<code>mocha add.test.js</code></p>
<p></p><p class="code-caption" data-lang="terminal" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="terminal">$ mocha add.test.js

   加法函数测试
     √ 1 + 1 等于 2
     √ 返回值是Number
   2 passing (12ms)
</code></pre>
<p>如果我们改变一下<code>add.js</code></p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// add.js
function add(a, b) {
    return a * b
}
module.exports = add
</code></pre>
<p>然后再执行一下<code>mocha add.test.js</code></p>
<p></p><p class="code-caption" data-lang="terminal" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="terminal">$ mocha add.test.js

   加法函数测试
     √ 1 + 1 等于 2
     1) 返回值是Number
   1 passing (8ms)
   1 failing

   1) 加法函数测试 返回值是Number:
       AssertionError: expected 2 to equal 3
       + expected - actual

       -2
       +3

       at Context.it(add.test.js:6:27)
</code></pre>
<p>这里也可以很明显看出哪个测试用例报错、还有报错的位置，这样在开发的时候开发人员就能很容易定位错误。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>从上面一个简单的例子可以看出，利用mocha实现自动化测试是很简单的。虽然前期开发需要花一点时间去写单元测试，但是后面提供的便利性足以将其弥补。</p>
</article></div></main><div class="page-footer"><div class="post-pagination"><a href="/2017/05/17/Promise的简单实现/"><i class="ion-arrow-left-c"></i>Promise的简单实现</a><a href="/2017/05/16/使用nodejs写一个命令行程序/">使用nodejs写一个命令行程序<i class="ion-arrow-right-c"></i></a></div></div><div class="cp"><div>©   2015 - 2016   Kit</div><div><span>power by </span><span><a href="//hexo.io">hexo.</a></span><span>Design By Kit.</span></div></div></div><div class="off-canvas"><div id="post-side-bar" class="post-side-bar"><div class="tab-btn"><button class="tab-item active">文章目录</button><button class="tab-item">站点导航</button></div><div class="tab-content"><div id="panel1" class="side-bar-panel active"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是单元-测试"><span class="nav-number">1.</span> <span class="nav-text">什么是单元-测试?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么要写单元测试？"><span class="nav-number">2.</span> <span class="nav-text">为什么要写单元测试？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#干了这杯-“Mocha”"><span class="nav-number">3.</span> <span class="nav-text">干了这杯 “Mocha”</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#举个例子"><span class="nav-number">3.1.</span> <span class="nav-text">举个例子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">4.</span> <span class="nav-text">小结</span></a></li></ol></div><div id="panel2" class="side-bar-panel"><ul class="post-side-list"><li><div class="head"><img src="/img/head.jpg" class="img-responsive"></div></li><li class="overview"><a><div>6</div><div>日志</div></a><a class="m"><div>3</div><div>分类</div></a><a><div>5</div><div>标签</div></a></li><li><a href="/Circle_Talk" class="item"><i class="ion-help-buoy"></i><span>Home</span></a><a href="/Circle_Talk/archives" class="item m"><i class="ion-nuclear"></i><span>Archives</span></a><a href="//github.com/kitwon" class="item"><i class="ion-social-github"></i><span>Github</span></a></li></ul></div></div></div></div></div><script src="/js/vendor.min.js"></script><script src="/js/post.min.js"></script></body></html>