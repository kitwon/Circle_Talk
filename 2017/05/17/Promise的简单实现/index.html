<!DOCTYPE html><html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0,  user-scalable=0" name="viewport"><title>KIT</title><link rel="stylesheet" href="/css/index.min.css"></head><body><nav class="nav-button-list"><div class="btn menu show-canvas"><span class="icon-bar"></span></div><div class="btn top btn-go-top"><i class="ion-ios-arrow-up"></i></div></nav><div class="off-canvas-wrap"><div class="off-canvas-content"><main class="post-container"><div class="post"><header class="post-header"><h1 class="post-title">Promise的简单实现</h1><section class="post-meta"><i class="ion-ios-clock-outline"></i><time class="post-date">May 17, 2017</time><span class="dot-sep">·</span><i class="ion-ios-pricetags-outline"></i></section></header><article data-spy="scroll" data-target="panel1" class="content"><p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href="https://promisesaplus.com/" target="_blank" rel="external">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>
<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>
<a id="more"></a>
<h1 id="初步构建一个Promise"><a href="#初步构建一个Promise" class="headerlink" title="初步构建一个Promise"></a>初步构建一个Promise</h1><p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// 例1
function getAsyncData() {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve(&#39;promise done!&#39;)
        }, 1000)
    })
}

getAsyncData().then(function(result) {
    console.log(result);
}).then(function() {
    console.log(&#39;done too!&#39;);
})
</code></pre>
<p><code>getAsyncData</code>函数中返回一个promise对象，然后通过<code>then</code>方法执行函数的回调，然后尝试实现一下这个基本的功能</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// promise.js
var Primose = function(fn) {
    var callbacks = [];

    this.done = function(onFulfilled) {
        this.callbacks.push(onFulfilled)

        // 支持链式调用
        return this;
    }

    function resolve(value) {
        // push到队列的最底端，保证链式代码执行完后再执行方法
        setTimeout(function() {
            while(callbacks[0]) {
                callbacks.shift()()
            }
        }, 0)
    }

    fn(resolve)
}
</code></pre>
<p>到这里就完成了promise的基础功能，然后执行一下看下有没有达到预期情况:</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">$node promise
promise done!
done too!
</code></pre>
<p>乍看一下，怎么有点像lazyman(js中比较有名的题目，可以自行百度一下) ，看来平时多读书还是有好处的（手动滑稽）v</p>
<h1 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h1><p>这里我们可以先看下<a href="https://promisesaplus.com/#requirements" target="_blank" rel="external">promise状态规范</a></p>
<p>promise必需在pending, fulfilled或者reject三个状态中的一个</p>
<ul>
<li>当promise在pending状态中<ul>
<li>可以变为fulfilled或者reject状态</li>
</ul>
</li>
<li>当promise在fulfilled中<ul>
<li>不能过渡为其他状态</li>
<li>必需返回一个值，并且不能改变</li>
</ul>
</li>
<li>当promise在reject中<ul>
<li>不能过渡为其他状态</li>
<li>必需返回一个失败原因，并且不能改变</li>
</ul>
</li>
</ul>
<p>从这里可以看出，我们需要添加一个<code>status</code>变量保存状态，并且随着代码执行更新状态。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">var Promise = function(fn) {
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];

    this.then = function(onFulfilled) {
        if(state === &#39;pending&#39;) {
            callbacks.push(onFulfilled);
            return this;
        }

        onFulfilled(value);
        return this;
    }

    function resolve(newValue) {
        state = &#39;fulfilled&#39;;
        value = newValue;

        setTimeout(function() {
            while(callbacks[0]) {
                callbacks.shift()(value)
            }
        }, 0)
    }

    fn(resolve)
}
</code></pre>
<h1 id="串行promise"><a href="#串行promise" class="headerlink" title="串行promise"></a>串行promise</h1><p>在执行promise的时候，经常会在<code>then</code>的方法里面执行另外一个promise，<em>串联执行promise应该是promise里面最有趣并且是最核心的功能了</em>。</p>
<p>串行promise指执行完一个异步函数达到fulfilled状态后，接着执行下一个promise，例如</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// 接着例1

getAsyncData()
    .then(getAsyncData2)
    .then(function(data) {
        console.log(data + &#39;done too!&#39;);
    })

function getAsyncData2(result) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve(result + &#39;next promise done!&#39;)
        }, 1000)
    })
}
</code></pre>
<p>要实现这个功能，首先，我们，之前的<code>then</code>方法是直接把<code>this</code>返回出去，所以实现链式调用，执行起来的时候也扛扛的，没毛病，但如果then中执行下一个promise，这时候按上面的代码，应该是直接就return一个promise出去的，走不了下一步，所以<code>then</code>方法应该需要处理一下，promise的执行方式应该要变为：</p>
<ol>
<li>执行代码，将所有方法push到<code>callbacks</code>数组里面</li>
<li>如果<code>then</code>中是一个promise，把剩下的<code>callbacks</code>提交到这个promise中执行</li>
<li>再循环第一步</li>
</ol>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">var Promise = function(fn) {
    var state = &#39;pending&#39;,
        // value = null,
        callbacks = [];

    this.then = function(onFulfilled) {
        switch(state) {
            case &#39;pending&#39;:
                callbacks.push(onFulfilled)
                return this;
                break;
            case &#39;fulfilled&#39;:
                onFulfilled()
                return this;
                break;
        }
    }

    function resolve(newValue) {
        var value = newValue;
        var temp = null;

        setTimeout(function() {
            state = &#39;fulfilled&#39;;
            do {
                temp = callbacks.shift()(value)
                // 顺序执行数组，如果是resolve返回value
                // 如果是promise则把后面的then方法提交到下个promise中执行
                if(temp instanceof Promise) {
                    while(callbacks[0]) {
                        temp.then(callbacks.shift())
                    }
                    return;
                }else {
                    value = temp;
                }
            }while(callbacks[0])
        }, 0)
    }
    fn(resolve)
}
</code></pre>
<h1 id="添加reject功能"><a href="#添加reject功能" class="headerlink" title="添加reject功能"></a>添加reject功能</h1><p>因为不确定then方法中是否会添加reject的处理，所以选用了一个比较笨的方法，加一个<code>errDerrers</code>的数组，每次执行不管有没有方法<code>then</code>都<code>push</code>到数组里面，<code>resolve</code>一个方法就<code>shift</code>一个，跟成功的回调一样，当reject的时候，判断下当前的方法是不是一个可执行函数，如果是的话则执行。至于catch的方法按这个思路暂时没想到，后面想到再更新。修改的地方都有添加注释。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">var Promise = function(fn) {
    var state = &#39;pending&#39;,
        // value = null,
        error = null,
        errDeffers = [],
        callbacks = [];

    this.then = function(onFulfilled, rejected) {
        switch(state) {
            case &#39;pending&#39;:
                callbacks.push(onFulfilled);
                // 每次执行then都push一次
                errDeffers.push(rejected);
                return this;
                break;
            case &#39;fulfilled&#39;:
                onFulfilled()
                return this;
                break;
            // reject的话直接执行
            case &#39;rejected&#39;:
                rejected(error);
                return this;
                break;
        }
    }

    this.catch = function(rejected) {
        if(errDeffer === null) {
            errDeffer = rejected;
            return;
        }
    }

    function resolve(newValue) {
        var value = newValue;
        var temp = null;

        setTimeout(function() {
            state = &#39;fulfilled&#39;;
            do {
                temp = callbacks.shift()(value);
                errDeffers.shift();
                // 顺序执行数组，如果是resolve返回value
                // 如果是promise则把后面的then方法提交到下个promise中执行
                if(temp instanceof Promise) {

                    while(callbacks[0]) {
                        // 成功的时候也要更新一下errDeffers数组
                        temp.then(callbacks.shift(), errDeffers.shift())
                    }

                    return;
                }else {
                    value = temp;
                }
            }while(callbacks[0])
        }, 0)
    }

    // reject方法
    // 判断rejected是否一个函数，是的话执行，不是的话抛出一个错误
    // reject也要提交到栈的最底端执行
    function reject(err) {
        setTimeout(function() {
            state = &#39;rejected&#39;;
            error = err;
            var rejected = errDeffers.shift();

            if(Object.prototype.toString.call(rejected) !== &#39;[object Function]&#39;) {
                throw new Error(&#39;Uncaught promise error!&#39;);
                return;
            }

            rejected(error);
        }, 0)
    }

    fn(resolve, reject)
}
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>找资料的时候看到<a href="http://tech.meituan.com/promise-insight.html" target="_blank" rel="external">美团技术团队博客的实现方式</a>采用了另外一种解决方式解决串行promise，后面接着研究下，有兴趣也可以自行看下。<br>实现promise应该有下面几个要点：</p>
<ol>
<li>函数的顺序执行</li>
<li>处理好状态（这部分感觉我的方法跟promiseA的状态要求有点偏差）</li>
<li>链式调用<br>这个例子只是根据promise的执行方式实现大概的功能，后面或许会根据promise规范去实现一个比较规范的demo。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://promisesaplus.com/#requirements" target="_blank" rel="external">Promises/A+</a></li>
<li><a href="http://tech.meituan.com/promise-insight.html" target="_blank" rel="external">剖析 Promise 之基础篇</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="external">Javascript异步编程的4种方法</a></li>
</ul>
</article></div></main><div class="page-footer"><div class="post-pagination"><a href="/2017/05/28/js实现add(1)(2)(3)/"><i class="ion-arrow-left-c"></i>js实现add(1)(2)(3)</a><a href="/2017/05/16/前端单元测试-Mocha指北/">前端单元测试&Mocha指北<i class="ion-arrow-right-c"></i></a></div></div><div class="cp"><div>©   2015 - 2016   Kit</div><div><span>power by </span><span><a href="//hexo.io">hexo.</a></span><span>Design By Kit.</span></div></div></div><div class="off-canvas"><div id="post-side-bar" class="post-side-bar"><div class="tab-btn"><button class="tab-item active">文章目录</button><button class="tab-item">站点导航</button></div><div class="tab-content"><div id="panel1" class="side-bar-panel active"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#初步构建一个Promise"><span class="nav-number">1.</span> <span class="nav-text">初步构建一个Promise</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#引入状态"><span class="nav-number">2.</span> <span class="nav-text">引入状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#串行promise"><span class="nav-number">3.</span> <span class="nav-text">串行promise</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#添加reject功能"><span class="nav-number">4.</span> <span class="nav-text">添加reject功能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">5.1.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div><div id="panel2" class="side-bar-panel"><ul class="post-side-list"><li><div class="head"><img src="/img/head.jpg" class="img-responsive"></div></li><li class="overview"><a><div>6</div><div>日志</div></a><a class="m unopen"><div>3</div><div>分类</div></a><a><div>5</div><div>标签</div></a></li><li><a href="/" class="item"><i class="ion-help-buoy"></i><span>Home</span></a><a href="/archives" class="item m"><i class="ion-nuclear"></i><span>Archives</span></a><a href="//github.com/kitwon" class="item"><i class="ion-social-github"></i><span>Github</span></a></li></ul></div></div></div></div></div><script src="/js/vendor.min.js"></script><script src="/js/post.min.js"></script></body></html>