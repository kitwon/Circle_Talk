{"version":3,"sources":["webpack:///path---blog-2-708bb766f7bd67577926.js","webpack:///./.cache/json/blog-2.json"],"names":["webpackJsonp","283","module","exports","pathContext","nodes","node","frontmatter","title","date","category","tags","path","excerpt","headings","depth","value","html","htmlExcerpt","page","pages","total","limit","prev","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAUC,MAAQC,aAAeC,MAAA,iBAAAC,KAAA,aAAAC,UAAA,QAAAC,MAAA,WAAAC,KAAA,kBAA4GC,QAAA,o8BAA47BC,WAAgCC,MAAA,EAAAC,MAAA,iBAAmCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,kBAAoCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,OAAuBC,KAAA,kmIAA4hHC,YAAA,8lCAA2rDZ,MAAQC,aAAeC,MAAA,oBAAAC,KAAA,aAAAC,SAAA,KAAAC,KAAA,KAAAC,KAAA,qBAAuGC,QAAA,0kBAA+jBC,WAAmCC,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,YAA8BD,MAAA,EAAAC,MAAA,OAAuBC,KAAA,gmJAAw8IC,YAAA,6wBAAg8BZ,MAAQC,aAAeC,MAAA,iBAAAC,KAAA,aAAAC,SAAA,KAAAC,KAAA,KAAAC,KAAA,wBAAuGC,QAAA,iUAAAC,WAAyVC,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,WAA6BD,MAAA,EAAAC,MAAA,QAA0BD,MAAA,EAAAC,MAAA,QAA0BD,MAAA,EAAAC,MAAA,OAAuBC,KAAA,g0LAAmrLC,YAAA,ydAA6nBZ,MAAQC,aAAeC,MAAA,sBAAAC,KAAA,aAAAC,SAAA,KAAAC,KAAA,KAAAC,KAAA,kBAAsGC,QAAA,6wBAAAC,WAAqyBC,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,WAA6BD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,iBAAmCD,MAAA,EAAAC,MAAA,OAAuBC,KAAA,i4NAAorNC,YAAA,k/BAA0vCZ,MAAQC,aAAeC,MAAA,mBAAAC,KAAA,aAAAC,UAAA,cAAAC,KAAA,KAAAC,KAAA,mBAA8GC,QAAA,wqBAAgmBC,YAAAG,KAAA,6mCAA60BC,YAAA;IAA2tCC,KAAA,EAAAC,MAAA,EAAAC,MAAA,GAAAC,MAAA,EAAAC,KAAA,UAAAC,KAAA","file":"path---blog-2-708bb766f7bd67577926.js","sourcesContent":["webpackJsonp([225156435109840],{\n\n/***/ 283:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"nodes\":[{\"node\":{\"frontmatter\":{\"title\":\"webpack2新特性&迁移\",\"date\":\"2017-06-24\",\"category\":[\"前端工具\"],\"tags\":[\"webpack\"],\"path\":\"/post/webpack2\"},\"excerpt\":\"\\nwebpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。\\n\\n# 从webpack1中迁移\\n官方已经给出了详细的[迁移指南](https://webpack.js.org/guides/migrating/)，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。\\n\\n## 配置文件\\n如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。\\n\\n### `module.loaders`变成`module.rules`\\n旧的`module.loader`被`module.rules`取代，后者允许配置`loader`更多选项，具体查看文档[module.rules](https://webpack.js.org/configuration/module/#module-rules)\\n\\n```javascript\\n// ...\\nmdoule: {\\n    rules: [\\n        {\\n            test: /\\\\.css$/,\\n            use: [\\n                { loader: 'style-loader' },\\n                {\\n                    loader: 'css-loader',\\n                    options: { module: true }\\n                }\\n            ]\\n        },\\n        {\\n            test: /\\\\.jsx$/,\\n            loader: 'babel-loader',\\n            options: {\\n                // ...\\n            }\\n        }\\n    ]\\n}\\n// ...\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"从webpack1中迁移\"},{\"depth\":2,\"value\":\"配置文件\"},{\"depth\":3,\"value\":\"变成\"},{\"depth\":3,\"value\":\"改动\"},{\"depth\":3,\"value\":null},{\"depth\":3,\"value\":\"CLI中配置使用自定义参数\"},{\"depth\":2,\"value\":\"主要变更\"},{\"depth\":3,\"value\":\"ES6模块\"},{\"depth\":1,\"value\":\"总结\"},{\"depth\":2,\"value\":\"参考\"}],\"html\":\"<p>webpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。</p>\\n<h1>从webpack1中迁移</h1>\\n<p>官方已经给出了详细的<a href=\\\"https://webpack.js.org/guides/migrating/\\\">迁移指南</a>，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。</p>\\n<h2>配置文件</h2>\\n<p>如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。</p>\\n<h3><code>module.loaders</code>变成<code>module.rules</code></h3>\\n<p>旧的<code>module.loader</code>被<code>module.rules</code>取代，后者允许配置<code>loader</code>更多选项，具体查看文档<a href=\\\"https://webpack.js.org/configuration/module/#module-rules\\\">module.rules</a></p>\\n<pre><code class=\\\"language-javascript\\\">// ...\\nmdoule: {\\n    rules: [\\n        {\\n            test: /\\\\.css$/,\\n            use: [\\n                { loader: 'style-loader' },\\n                {\\n                    loader: 'css-loader',\\n                    options: { module: true }\\n                }\\n            ]\\n        },\\n        {\\n            test: /\\\\.jsx$/,\\n            loader: 'babel-loader',\\n            options: {\\n                // ...\\n            }\\n        }\\n    ]\\n}\\n// ...\\n</code></pre>\\n<!-- more -->\\n<pre><code class=\\\"language-javascript\\\">// ...\\nmodule: {\\n    rules: {\\n        test: /\\\\.less$/,\\n        use: ['style-loader', 'css-loader', 'less-loader']\\n    }\\n}\\n// ...\\n</code></pre>\\n<p>除上面两项外还有</p>\\n<ul>\\n<li>现在指定loader的时候不能再省略<code>-loader</code>后缀。具体原因参阅<a href=\\\"https://github.com/webpack/webpack/issues/2986\\\">#2968</a></li>\\n<li><code>json-loader</code>不需再手动添加。</li>\\n<li>loader默认的resolve配置是相对于<code>context</code>配置项的。</li>\\n<li>取消了<code>module.preLoaders</code>以及<code>module.postLoaders</code>。</li>\\n</ul>\\n<h3><code>UglifyPlugin</code>改动</h3>\\n<ul>\\n<li><code>UglifyPlugin</code>的<code>sourceMap</code>现在的默认值的<code>false</code>而不是<code>true</code>。</li>\\n<li><code>UglifyJsPlugin</code>的<code>compress.warnings</code>配置项现在默认为<code>false</code>而不是<code>true</code>。</li>\\n</ul>\\n<h3><code>ExtractTextWebpackPlugin</code></h3>\\n<p>插件变化主要体现在语法上，又原来的单个参数传变成了对象，现在的配置方式如下</p>\\n<pre><code class=\\\"language-javascript\\\">// ExtractTextPlugin.extract\\nmodule: {\\n    rules: [\\n        test: /\\\\.css$/,\\n        loader: ExtractTextPlugin.extract({\\n            fallbackLoader: 'style-loader',\\n            loader: 'css-loader',\\n            publicPath: '/dist'\\n        })\\n    ]\\n}\\n\\n// new ExtractTextPlugin({options})\\nplugins: [\\n    new ExtractTextPlugin({\\n        filename: 'bundle.css',\\n        disabled: true,\\n        allChunks: true\\n    })\\n]\\n</code></pre>\\n<h3>CLI中配置使用自定义参数</h3>\\n<p>在webpack1中可以用<code>process.argv</code>获取自定义参数，但是在webpack2中这行为被禁止了，替代地提供了一个接口<code>env</code>去获取自定义参数</p>\\n<pre><code class=\\\"language-javascript\\\">module.export = function(env) {\\n    var customStuff = env.customStuff;\\n\\n    // ...\\n    return config;\\n};\\n</code></pre>\\n<h2>主要变更</h2>\\n<h3>ES6模块</h3>\\n<p>webpack2现在增加对ES6的模块化的原生支持，意味着现在能够直接识别<code>import</code>和<code>export</code>了，不需要先转成CommonJS模块的格式。\\n支持原生<code>import</code>带来的影响就是支持异步加载模块，webpack1使用异步模块的时候如下</p>\\n<pre><code class=\\\"language-javascript\\\">require.ensure(['a'], function(a) {\\n    a.doSomething()\\n}, 'chunkName')\\n</code></pre>\\n<p>webpack2的<code>import</code>会返回一个<code>promise</code>对象</p>\\n<pre><code class=\\\"language-javascript\\\">import('a').then(function(a) {\\n    a.doSomething()\\n})\\n</code></pre>\\n<p>而且现在<strong>chunk加载失败能被Promise捕捉到</strong>，那就意味着我们能够在组件加载失败的时候采取相应的操作。</p>\\n<p>另外现在<code>import</code>还支持动态表达式。</p>\\n<pre><code class=\\\"language-javascript\\\">function route(path, query) {\\n    return import('/routes/${path}/route').then(route => new route.Route(query);\\n    })\\n}\\n</code></pre>\\n<h1>总结</h1>\\n<p>用着<em>vim-mode</em>，写完这篇已经完全头皮发麻了，完全熟悉估计不知道还要多久呢。回正题，·从官方文档来看，改动的地方的确不多，迁移成本应该是比较低的，至于要不要迁移我觉得还是见仁见智吧，如果新版的优点好处大于迁移的成本的话各位应该可以放心去改动你的配置文件了。总的来说webpack2有以下几个优点</p>\\n<ul>\\n<li>编译速度提高</li>\\n<li>编译文件大小相对减少了</li>\\n<li>支持promise</li>\\n<li>能捕捉到chunk加载失败</li>\\n</ul>\\n<h2>参考</h2>\\n<ul>\\n<li><a href=\\\"https://webpack.js.org/guides/migrating/\\\">Migrating from v1 to v2</a></li>\\n<li><a href=\\\"http://www.tuicool.com/articles/aieAnan\\\">升级到 webpack2</a></li>\\n<li><a href=\\\"http://imweb.io/topic/58666d57b3ce6d8e3f9f99b0\\\">webpack2 的 tree-shaking 好用吗？</a></li>\\n</ul>\",\"htmlExcerpt\":\"<p>webpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。</p>\\n<h1>从webpack1中迁移</h1>\\n<p>官方已经给出了详细的<a href=\\\"https://webpack.js.org/guides/migrating/\\\">迁移指南</a>，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。</p>\\n<h2>配置文件</h2>\\n<p>如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。</p>\\n<h3><code>module.loaders</code>变成<code>module.rules</code></h3>\\n<p>旧的<code>module.loader</code>被<code>module.rules</code>取代，后者允许配置<code>loader</code>更多选项，具体查看文档<a href=\\\"https://webpack.js.org/configuration/module/#module-rules\\\">module.rules</a></p>\\n<pre><code class=\\\"language-javascript\\\">// ...\\nmdoule: {\\n    rules: [\\n        {\\n            test: /\\\\.css$/,\\n            use: [\\n                { loader: 'style-loader' },\\n                {\\n                    loader: 'css-loader',\\n                    options: { module: true }\\n                }\\n            ]\\n        },\\n        {\\n            test: /\\\\.jsx$/,\\n            loader: 'babel-loader',\\n            options: {\\n                // ...\\n            }\\n        }\\n    ]\\n}\\n// ...\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"深入学习javascript-闭包\",\"date\":\"2017-06-14\",\"category\":null,\"tags\":null,\"path\":\"/post/js-closures\"},\"excerpt\":\"\\n# 什么是闭包\\n记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。\\n\\n> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）\\n\\n然后看个例子\\n```javascript\\nfunction foo() {\\n\\tvar a = 2;\\n\\n\\tfuntion bar() {\\n\\t\\tconsole.log(a);\\n\\t}\\n\\n\\tbar();\\n}\\n\\nfoo();\\n```\\n如果按上面第一条的定义，这里一定是生成了闭包，但是**确切的说并不是**，这里最准确的说是`bar`对`a`的引用方式是词法作用域的查找规则，而这些只是**闭包**的一部分。然后再看清晰闭包的例子\\n\\n```javascript\\nfucntion foo() {\\n\\tvar a = 2;\\n\\n\\tfunction bar() {\\n\\t\\tconsole.log(a)\\n\\t}\\n\\n\\treturn bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"什么是闭包\"},{\"depth\":1,\"value\":\"闭包与变量\"},{\"depth\":1,\"value\":\"模块\"},{\"depth\":2,\"value\":\"现代的模块机制\"},{\"depth\":1,\"value\":\"总结\"}],\"html\":\"<h1>什么是闭包</h1>\\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\\n<blockquote>\\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）</p>\\n</blockquote>\\n<p>然后看个例子</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    funtion bar() {\\n        console.log(a);\\n    }\\n\\n    bar();\\n}\\n\\nfoo();\\n</code></pre>\\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\\n<pre><code class=\\\"language-javascript\\\">fucntion foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a)\\n    }\\n\\n    return bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n</code></pre>\\n<!-- more -->\\n<p>在这例子中，<code>bar</code>也是在<code>foo</code>的作用域内，但是不是直接执行，而是作为返回值返回。\\n<code>foo()</code>执行后，返回值<code>bar</code>赋值给<code>baz</code>并执行<code>baz()</code>，在这里，<code>bar()</code>显然可以正常执行，它在自己定义的词法作用域<strong>以外</strong>的地方。</p>\\n<p>在<code>foo()</code>执行之后，按js的垃圾回收机制，应该会对其进行回收，而闭包的神奇之处就是可以阻止这事情发生，因此<code>baz()</code>在执行的时候依然可以访问<code>a</code>。在此一看，原来平时写的大多数代码都是闭包啊。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a);\\n    }\\n\\n    baz(bar);\\n}\\n\\nfunction baz(fn) {\\n    fn &#x26;&#x26; fn(); // 这里也是闭包\\n}\\n</code></pre>\\n<h1>闭包与变量</h1>\\n<p>要说明闭包，for循环也是一个很好的例子</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 1; i &#x3C;= 10; i++) {\\n    setTimeout(function timer() {\\n        console.log(i)\\n    }, i * 1000)\\n}\\n</code></pre>\\n<p>正常情况下，我们会预期的认为这段会每秒输出1～10，但实际，这段代码会<strong>每秒输出10次11</strong>。</p>\\n<p>首先<strong>11</strong>是那里来的，这个循环应该是在<code>i=11</code>的时候符合终止条件，所以代码输出的是循环结束时<strong>i</strong>的最终值。</p>\\n<p>细想一下，答案其实显而易见，<strong>setTimeout</strong>会推到栈底部执行，所以会在循环结束后才开始执行，所以每次都是输出<strong>11</strong>。但是什么问题造成这样的结果呢。</p>\\n<p>虽然<strong>setTimeout</strong>都是在每个迭代时候分别定义的，但是根据作用域原理，其实几个函数都是都是<strong>保存在一个封闭的作用域中</strong>，因此它们引用都是同一个<strong>来自全局的i</strong>。</p>\\n<p>所以解决方法也很简单，我们需要每次循环都新建一个作用域，然后把迭代的值传入作用域中，所以我们可以用<strong>IIFE</strong>（上一篇作用域有介绍，IIFE是一个匿名函数，每次调用都会创建作用域）来解决</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 1; i &#x3C;= 10; i++) {\\n    (function(j) {\\n        setTimeout(function timer() {\\n            console.log(j)\\n        }, j * 1000)\\n    })(i)\\n}\\n\\n// 换成ES6中的let也可以\\nfor(let i = 1; i &#x3C;= 10; i++) {\\n    setTimeout(function timer() {\\n        console.log(i)\\n    }, i * 1000)\\n}\\n</code></pre>\\n<h1>模块</h1>\\n<p>闭包除了平时实现的回调功能外，还可以实现另外一个强大的功能，<strong>模块</strong>。\\n旧的模块实现方式，如jQuery就可以使用闭包实现</p>\\n<pre><code class=\\\"language-javascript\\\">var $ = jQuery = (function Module(id) {\\n    var a = 2;\\n\\n    function doSomething() {\\n        console.log(a);\\n    }\\n\\n    function identify1() {\\n        console.log(id);\\n    }\\n\\n    function identify2() {\\n        console.log(id.toUpperCase());\\n    }\\n\\n    function change() {\\n        public.identify = identify2;\\n    }\\n\\n    var public = {\\n        doSomething: doSomething,\\n        identify: identify1,\\n        change: change\\n    }\\n\\n    return public;\\n})('hello')\\n\\n$.doSomething() // 2\\n$.identify() // hello\\n$.change()\\n$.identify() // HELLO\\n</code></pre>\\n<p>如果不用单例的话不用<strong>IIFE</strong>即可，通过在模块内保留对公共API的引用，可以从<strong>内部</strong>对模块实例进行修改，包括添加，删除，修改属性或者方法。</p>\\n<h2>现代的模块机制</h2>\\n<p>现在大部分的模块加载器本质上都是将这种模块定义封装进API中，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var Module = (function Manager() {\\n    var modules = {};\\n\\n    function define(name, deps, impl) {\\n        for(var i = 0; i &#x3C; deps.length; i++) {\\n            // 在modules中寻找名字为deps[i]的模块\\n            deps[i] = modules[deps[i]];\\n        }\\n        // 将依赖的模块作为arguments传入module中\\n        modules[name] = impl.apply(impl, deps);\\n    }\\n\\n    function require(name) {\\n        return modules[name];\\n    }\\n\\n    return {\\n        define: define,\\n        require: require\\n    }\\n})()\\n</code></pre>\\n<p>这段代码核心在<code>module[name] = impl.apply(impl, deps)</code>中，模块都按名字保存在<code>modules</code>变量中，每次都能根据获取相关模块。下面看看使用方式。</p>\\n<pre><code class=\\\"language-javascript\\\">Module.define('foo', [], function() {\\n    function hello(who) {\\n        return 'Hello ' + who;\\n    }\\n\\n    return {\\n        hello: hello\\n    }\\n})\\n\\nModule.define('bar', ['foo'], function(foo) {\\n    function awsome() {\\n        return foo.hello('kit').toUpperCase();\\n    }\\n\\n    return {\\n        awsome: awsome\\n    }\\n})\\n\\nvar foo = Module.require('foo'),\\n    bar = Module.require('bar');\\n\\nfoo.hello('kit'); // Hello kit\\nbar.awsome() // HELLO KIT\\n</code></pre>\\n<h1>总结</h1>\\n<p>从上面可以知道，平时写的js大部分代码都使用了闭包，通过了解闭包和作用域的运行方式，能够减少平时使用的出现的错误。也能通过闭包，使用js实现模块化等其他更多的功能。</p>\",\"htmlExcerpt\":\"<h1>什么是闭包</h1>\\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\\n<blockquote>\\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）</p>\\n</blockquote>\\n<p>然后看个例子</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    funtion bar() {\\n        console.log(a);\\n    }\\n\\n    bar();\\n}\\n\\nfoo();\\n</code></pre>\\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\\n<pre><code class=\\\"language-javascript\\\">fucntion foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a)\\n    }\\n\\n    return bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"用python写一个简单爬虫\",\"date\":\"2017-06-11\",\"category\":null,\"tags\":null,\"path\":\"/post/python-crawler\"},\"excerpt\":\"\\n之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。\\n\\n# 主要需求\\n这个demo中爬虫有3个主要模块，**URL管理器**、**下载器**、**解析器**\\n* URL管理器主要处理爬取的URL的状态。\\n* 下载器会通过**URL管理器**传送过来有效URL进行下载。\\n* 解析器会将**下载器**下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给**URL管理器**进行重复操作。\\n\\n## 入口程序\\n`spider_main`文件为程序入口，处理整个爬虫的运行逻辑\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"主要需求\"},{\"depth\":2,\"value\":\"入口程序\"},{\"depth\":2,\"value\":\"url管理器\"},{\"depth\":2,\"value\":\"下载器\"},{\"depth\":2,\"value\":\"解析器\"},{\"depth\":1,\"value\":\"总结\"}],\"html\":\"<p>之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。</p>\\n<h1>主要需求</h1>\\n<p>这个demo中爬虫有3个主要模块，<strong>URL管理器</strong>、<strong>下载器</strong>、<strong>解析器</strong></p>\\n<ul>\\n<li>URL管理器主要处理爬取的URL的状态。</li>\\n<li>下载器会通过<strong>URL管理器</strong>传送过来有效URL进行下载。</li>\\n<li>解析器会将<strong>下载器</strong>下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给<strong>URL管理器</strong>进行重复操作。</li>\\n</ul>\\n<h2>入口程序</h2>\\n<p><code>spider_main</code>文件为程序入口，处理整个爬虫的运行逻辑</p>\\n<!-- more -->\\n<pre><code class=\\\"language-python\\\">import url_manager, html_downloader, html_outputer, html_parser\\nimport sys\\n\\nclass SpiderMain(object):\\n    def __init__(self):\\n        self.urls = url_manager.UrlManager()\\n        self.downloder = html_downloader.HtmlDownloader()\\n        self.parser = html_parser.HtmlParser()\\n        self.outputer = html_outputer.HtmlOutputer()\\n\\n    def crawl(self, root_url):\\n        count = 1\\n        # 初始化原始的爬取地址\\n        self.urls.add_new_ursl(root_url)\\n\\n        while self.urls.has_new_url():\\n            try:\\n                new_url = self.urls.get_new_url()\\n                print 'crawl %d : %s' % (count, new_url)\\n                html_cont = self.downloder.download(new_url)\\n                new_urls, new_data = self.parser.parse(new_url, html_cont)\\n\\n                self.urls.add_new_urls(new_urls)\\n                self.outputer.collect_data(new_data)\\n\\n                # 爬取的数据到1000条时跳出循环\\n                if count == 1000:\\n                    break\\n\\n                count = count + 1\\n            except:\\n                # 使用sys抛出其他函数错误\\n                info=sys.exc_info()\\n                print info[0],\\\":\\\",info[1]\\n\\n                print 'crawl failed'\\n\\n        # 将爬取的数据组装\\n        self.outputer.output_html()\\n\\nif __name__ == '__main__':\\n    root_url = 'http://baike.baidu.com/item/Python'\\n    obj_spider = SpiderMain()\\n    obj_spider.crawl(root_url)\\n</code></pre>\\n<h2>url管理器</h2>\\n<pre><code class=\\\"language-python\\\"># url_manager.py\\nclass UrlManager(object):\\n    def __init__(self):\\n        self.new_urls = set()\\n        self.old_urls = set()\\n\\n    # 添加一条新的url\\n    def add_new_url(self, url):\\n        if url is None:\\n            return\\n\\n        if url not in self.new_urls and url not in self.old_urls:\\n            self.new_urls.add(url)\\n\\n    # 添加多条url\\n    def add_new_urls(self, urls):\\n        if urls is None and len(urls) == 0:\\n            return\\n\\n        for url in urls:\\n            self.add_new_url(url)\\n\\n    # 是否有代爬取地址\\n    def has_new_url(self):\\n        return len(self.new_urls) != 0\\n\\n    # 返回一条新的url\\n    def get_new_url(self):\\n        new_url = self.new_urls.pop()\\n        self.old_urls.add(new_url)\\n        return new_url\\n</code></pre>\\n<h2>下载器</h2>\\n<p>下载器使用自带的<a href=\\\"https://docs.python.org/2/library/urllib2.html\\\">urllib2</a>库处理请求</p>\\n<pre><code class=\\\"language-python\\\"># html_downloader.py\\nimport urllib2\\n\\nclass HtmlDownloader(object):\\n    def download(self, url):\\n        if url is None:\\n            return\\n\\n        # 这里设置一下超时，不然网络会使程序运行出现停止\\n        response = urllib2.urlopen(url, timeout = 5)\\n\\n        # 请求失败时候跳出程序\\n        if response.getcode() != 200:\\n            return None\\n\\n        return response.read()\\n</code></pre>\\n<h2>解析器</h2>\\n<p>解析器分为两部分，一个解析，一个输出，首先看看解析模块。</p>\\n<p>解析html我们使用了<a href=\\\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\\\">beautifulsoup</a>，解析后可以使用库提供的方法做DOM操作，获取有用的信息</p>\\n<pre><code class=\\\"language-python\\\"># html_parser.py\\nfrom bs4 import BeautifulSoup\\nimport re\\nimport urlparse\\n\\nclass HtmlParser(object):\\n    def _get_new_urls(self, page_url, soup):\\n        new_urls = set()\\n\\n        # 获取a标签中所有匹配的url地址\\n        links = soup.find_all('a', href=re.compile(r'/item/'))\\n        for link in links:\\n            new_url = link['href']\\n            new_full_url = urlparse.urljoin(page_url, new_url)\\n            new_urls.add(new_full_url)\\n\\n        return new_urls\\n\\n    def _get_new_data(self, page_url, soup):\\n        res_data = {}\\n\\n        # 获取页面相关内容\\n        res_data['url'] = page_url\\n\\n        # &#x3C;dd class=\\\"lemmaWgt-lemmaTitle-title\\\"> &#x3C;h1>Python&#x3C;/h1>\\n        title_node = soup.find('dd', class_='lemmaWgt-lemmaTitle-title').find('h1')\\n        res_data['title'] = title_node.get_text()\\n\\n        # &#x3C;div class=\\\"lemma-summary\\\" label-module=\\\"lemmaSummary\\\">\\n        summary_node = soup.find('div', class_='lemma-summary')\\n        res_data['summary'] = summary_node.get_text()\\n\\n        return res_data\\n\\n    def parse(self, page_url, html_cont):\\n        if page_url is None or html_cont is None:\\n            return\\n\\n        soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8')\\n        new_urls = self._get_new_urls(page_url, soup)\\n        new_data = self._get_new_data(page_url, soup)\\n\\n        return new_urls, new_data\\n</code></pre>\\n<pre><code class=\\\"language-python\\\"># html_outputer.py\\nclass HtmlOutputer(object):\\n    def __init__(self):\\n        self.datas = []\\n\\n    # 获取到的页面内容对象push到数组中\\n    def collect_data(self, data):\\n        if data is None:\\n            return\\n\\n        self.datas.append(data)\\n\\n    # 将数组循环拼接，写入html文件中\\n    def output_html(self):\\n        fout = open('output.html', 'w')\\n\\n        fout.write('&#x3C;html>')\\n        fout.write('&#x3C;body>')\\n        fout.write('&#x3C;table>')\\n\\n        for data in self.datas:\\n            fout.write('&#x3C;tr>')\\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['url'])\\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['title'].encode('utf-8'))\\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['summary'].encode('utf-8'))\\n            fout.write('&#x3C;/tr>')\\n\\n        fout.write('&#x3C;/html>')\\n        fout.write('&#x3C;/body>')\\n        fout.write('&#x3C;/table>')\\n</code></pre>\\n<h1>总结</h1>\\n<p>短短几行代码就实现了一个简单的爬虫，足以体现python的简单易用。学习python主要是想了解一下机器学习，后面会看一些书籍和资料，应该会再记录，但是后面估计会先写完深度学习javascript系列先。</p>\",\"htmlExcerpt\":\"<p>之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。</p>\\n<h1>主要需求</h1>\\n<p>这个demo中爬虫有3个主要模块，<strong>URL管理器</strong>、<strong>下载器</strong>、<strong>解析器</strong></p>\\n<ul>\\n<li>URL管理器主要处理爬取的URL的状态。</li>\\n<li>下载器会通过<strong>URL管理器</strong>传送过来有效URL进行下载。</li>\\n<li>解析器会将<strong>下载器</strong>下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给<strong>URL管理器</strong>进行重复操作。</li>\\n</ul>\\n<h2>入口程序</h2>\\n<p><code>spider_main</code>文件为程序入口，处理整个爬虫的运行逻辑</p>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"深入学习javascript--作用域\",\"date\":\"2017-05-31\",\"category\":null,\"tags\":null,\"path\":\"/post/js-scope\"},\"excerpt\":\"\\n# 前言\\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\\n\\n# 作用域是什么\\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\\n\\n\\n\\n## 理解作用域执行过程\\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\\n\\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\\n\\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"前言\"},{\"depth\":1,\"value\":\"作用域是什么\"},{\"depth\":2,\"value\":\"理解作用域执行过程\"},{\"depth\":3,\"value\":\"LSH和RSH查询\"},{\"depth\":2,\"value\":\"提升\"},{\"depth\":3,\"value\":\"函数优先\"},{\"depth\":2,\"value\":\"作用域嵌套\"},{\"depth\":1,\"value\":\"函数作用域\"},{\"depth\":1,\"value\":\"块作用域\"},{\"depth\":2,\"value\":\"延长作用域链(块作用域)\"},{\"depth\":1,\"value\":\"总结\"}],\"html\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。</p>\\n<ol>\\n<li>遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。</li>\\n<li>接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</li>\\n</ol>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n<!-- more -->\\n<h3>LSH和RSH查询</h3>\\n<p>定义一个变量<code>var a = 2</code>，或者执行一个简单的函数<code>console.log(2)</code>中，会同时或者单独出现<strong>LSH</strong>或者<strong>RSH</strong>查询。其实在作用域执行过程中，第一步就是LSH查询，第二步就是RSH查询，简单点来说</p>\\n<ul>\\n<li>LSH查询就是找到变量的容器本身</li>\\n<li>RSH查询就是找到容器的原值</li>\\n</ul>\\n<pre><code class=\\\"language-javascript\\\">// var a就是LSH\\n// a = 2就是RSH\\nvar a = 2;\\n\\n// 这里的a其实就是做了一个RSH查询\\nconsole.log(a)\\n</code></pre>\\n<p>为什么需要理解这两个概念呢，因为在变量没有声明的情况下，这两种查询的行为是不一样的。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    console.log(a + b);\\n    b = a;\\n}\\n\\nfoo(2);\\n</code></pre>\\n<p>在第一次对b做RSH查询时候是无法找到该变量，所以引擎在这时候就会报出一个<code>ReferenceError</code>的错误。第二个b也还没有声明，但是引擎并没有报错，因为这里先做了LSH查询，所以可以知道，LSH查询如果未找到变量，会在全局中定义一个变量b（非严格模式下），再做RSH查询。引擎还有一个<code>TypeError</code>的错误，在试图对一个非函数类型的值执行函数调用，或者引用<code>null</code>, <code>undefined</code>类型值中的属性时候，就会报这个错误。</p>\\n<h2>提升</h2>\\n<p>很多时候都会认为javascript代码是由上到下一行一行执行的，但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p>\\n<pre><code class=\\\"language-javascript\\\">a = 2;\\n\\nvar a;\\n\\nconsole.log(a);  // 2\\n</code></pre>\\n<p>还有另外一段</p>\\n<pre><code class=\\\"language-javascript\\\">console.log(a); // undefined\\n\\nvar a = 2;\\n</code></pre>\\n<p>当js执行一个<code>var a = 2</code>的时候，这里并不是我们看到的一个声明，而是<code>var a</code>, <code>a = 2</code>两个声明，<code>var a</code>会在编译阶段执行，<code>a = 2</code>则会在执行阶段执行。所以第二段代码就很容易解释通了，代码执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var a;\\n\\nconsole.log(a);\\n\\na = 2;\\n</code></pre>\\n<p>而这个函数声明自动移动到顶部，就叫做<strong>提升</strong>。</p>\\n<p>提升操作会出现在<strong>每个作用域</strong>中，看以下代码</p>\\n<pre><code class=\\\"language-javascript\\\">foo();\\n\\nfunction foo() {\\n    console.log(a);\\n    var a = 2;\\n}\\n</code></pre>\\n<p>实际执行如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a;\\n    console.log(a);\\n    a = 2;\\n}\\n\\nfoo();\\n</code></pre>\\n<p>可以看到，函数声明会被提升到最顶部，但是函数表达式却不会被提升</p>\\n<pre><code>foo(); // TypeError\\nbar(); // ReferenceError\\n\\nvar foo = function bar() {\\n    ...\\n}\\n</code></pre>\\n<p>在这里要注意，把foo分配到具名函数下，但是具名函数下也无法在所在作用域中运行。上面函数的执行方式应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var foo;\\n\\nfoo(); // TypeError\\n\\nbar(); // ReferenceError\\n\\nfoo = function() {\\n    var bar = ... self ...\\n}\\n</code></pre>\\n<h3>函数优先</h3>\\n<p>从上面可以知道定义变量和声明函数都会触发提升，但是如果在重复声明的代码下，会出现什么情况呢</p>\\n<pre><code class=\\\"language-javascript\\\">foo(); // 1\\n\\nvar foo;\\n\\nfunction foo() {\\n    console.log(1);\\n}\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>这里会出现<strong>1</strong>而不是<strong>2</strong>！因为函数会首先被提升，再到变量，所以执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    console.log(1);\\n}\\n\\nfoo();\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>在一个普通的块( { ... } 的代码)，函数也会提升，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var a = true;\\n\\nif(a) {\\n    function foo() {\\n        ...\\n    }\\n}else {\\n    function bar() {\\n        ...\\n    }\\n}\\n</code></pre>\\n<p>这里的<code>foo</code>和<code>bar</code>都不会按判断来声明函数，所以在判断声明函数并不可靠。</p>\\n<h2>作用域嵌套</h2>\\n<p>当一个块或者函数嵌套在另一个块或者函数中，就称为作用域嵌套。在当前作用域没有找到某个变量时，<strong>引擎</strong>就会在外层的作用域继续查找，直到找到该变量，或者抵达最外层（全局）作用域为止。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    // b在函数中尚未定义，所以在上一个作用域中查找\\n    // 在全局中找到变量b，赋值\\n    console.log(a + b);\\n}\\n\\nvar b = 2;\\n\\nfoo(2); // 4\\n</code></pre>\\n<h1>函数作用域</h1>\\n<p>每个函数都有自己的执行环境，或者说函数有自己作用域。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而函数执行之后，栈将其环境弹出，把控制权返回之前的执行环境。函数作用域内的变量访问正是又这个执行机制控制着。而通过这一机制，能实现隐藏作用域中变量或者函数，规避同名标识符之间的冲突。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    function bar(a) {\\n        // i会从for块中找到变量容器，然后执行赋值\\n        i = 3;\\n        console.log(a + i);\\n    }\\n\\n    for(var i = 0; i &#x3C;= 10; i++) {\\n        // 执行bar后会给i重新赋值3，满足i&#x3C;=10，函数死循环\\n        bar(i * 2);\\n    }\\n}\\n</code></pre>\\n<p>这时候只需要在bar内部修改<code>i = 3</code>为<code>var i = 3</code>，将i变为<code>bar</code>中的本地变量即可。除了新建一个函数去隐藏变量，还能通过匿名函数的特性去实现隐藏变量，社区中也称为<strong>IIFE</strong>。</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function() {\\n    var a = 3;\\n    console.log(a); // 3\\n})()\\n\\nconsole.log(a); // 2\\n</code></pre>\\n<p>还能当作函数调用传参</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function(global) {\\n    var a = 3;\\n\\n    console.log(a); // 3\\n    console.log(global.a); // 2\\n})(window)\\n</code></pre>\\n<p>通过隐藏变量活着函数，能实现<strong>全局命名空间</strong>或者<strong>JS模块化</strong>(后面会讨论到)。</p>\\n<h1>块作用域</h1>\\n<p>在JS中块作用域并不常见，但是某些代码却经常会被误以为是块作用域，所以很容易造成理解上的错误，例如下面的常用代码</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nif(true) {\\n    var foo = 'bar';\\n}\\n\\nconsole.log(i, foo); // 10 bar\\n</code></pre>\\n<p>上面代码的<code>i</code>和<code>foo</code>其实都在外部作用域中定义的，而不是在代码块中定义的变量，所以平时在这些代码中定义变量应该是距离使用的地方越近越好。</p>\\n<h2>延长作用域链(块作用域)</h2>\\n<ul>\\n<li>\\n<p>with语句。with从对象中创建出来的对象只在with声明中有效。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\nvar qs = \\\"?bar=true\\\";\\n\\nwith(location) {\\n    // href实际是location.href，只能在with内部使用\\n    var url = href + qs;\\n}\\n\\nreturn url;\\n}\\n</code></pre>\\n</li>\\n<li>\\n<p>try/catch中的catch分句会创造一个块作用域，声明的错误对象变量仅在catch内部有效。</p>\\n<pre><code class=\\\"language-javascript\\\">try {\\nundefined(); // 强制执行一个错误操作\\n} catch(err) {\\nconsole.log(err);\\n}\\n</code></pre>\\n</li>\\n</ul>\\n<p>console.log(err); // ReferenceError</p>\\n<pre><code>## let/const\\n在ES6中，引入了let和const，提供了除var以外的另一种声明变量的方式。用let/const声明的变量会绑定在所在的所用域中（通常是{ ... }内部，换句话说，let/const能劫持所在作用域。\\n```javascript\\n// 修改下上面的循环例子\\nfor(let i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nconsole.log(i); // ReferenceError\\n</code></pre>\\n<p>const在使用方法上跟len是一样，只是创建的值是固定的（常量）。后面任何修改值的操作都会报错。<strong>(注：const实际保证的并不是常量不能改变，而是变量的内存地址不能改变，所以对于复杂的类型object，也只能保证对象的指针地址是固定的，但是对象内部的数据结构则不能固定)</strong></p>\\n<pre><code class=\\\"language-javascript\\\">const foo = {};\\n\\nfoo.bar = 'bar';\\nconsole.log(foo.bar); // bar\\n\\nfoo = {}; // TypeError\\n</code></pre>\\n<h1>总结</h1>\\n<p>通过学习js中的作用域运行方式，了解变量在执行环境的声明周期，以及哪部分代码能访问其中的变量。能为后面学习<strong>闭包</strong>还有实现模块化打下基础。以下是关于作用域的几点总结：</p>\\n<ul>\\n<li>函数局部环境不仅有访问函数作用域的变量的权限，而且还有权访问其包含(父)环境的变量。</li>\\n<li>除全局、函数作用域外，还有比较少用的块作用域。</li>\\n</ul>\",\"htmlExcerpt\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</p>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"js实现add(1)(2)(3)\",\"date\":\"2017-05-28\",\"category\":[\"javascript\"],\"tags\":null,\"path\":\"/post/add-chain\"},\"excerpt\":\"\\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现\\n```javascript\\nfunction add(x) {\\n\\tvar fn = function(y) {\\n\\t\\treturn add(x + y);\\n\\t}\\n\\n\\treturn fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n```\\n\\n这样写是可以实现调用方式，但是怎么`return x`呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了`object`的`valueOf`和`toString`的方法。然后再跑了一遍。\\n```javascript\\nfunction add(x) {\\n\\tvar fn = function(y) {\\n\\t\\treturn add(x + y);\\n\\t}\\n\\n\\tfn.toString = function() {\\n\\t\\treturn x;\\n\\t}\\n\\n\\treturn fn;\\n}\\n\\n\\n// chrome  function 6\\n// firefox function add/fn\\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\\nconsole.log(add(1)(2)(3))\\n\\nconsole.log(add(1)(2)(3).toString()) // 6\\n```\\n\\n\",\"headings\":[],\"html\":\"<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    return fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n</code></pre>\\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    fn.toString = function() {\\n        return x;\\n    }\\n\\n    return fn;\\n}\\n\\n\\n// chrome  function 6\\n// firefox function add/fn\\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\\nconsole.log(add(1)(2)(3))\\n\\nconsole.log(add(1)(2)(3).toString()) // 6\\n</code></pre>\\n<!-- more -->\\n<p>由此看出在不同客户端下返回的结果并不一样，并不是完美的结果，但是查阅了其他资料并没有其他十分好的解决办法，估计这道题的考查点是关于js深度的，比如原生对象里面的基本方法和<code>alert</code>, <code>console</code>会自动执行toString等方法。</p>\\n<p>另外，<code>valueOf</code>和<code>toString</code>方法其实是差不多的，返回的结果基本都是相同的，但是试了一下定义了两个不同的方法，发现总是会返回valueOf的值先，所以觉得toString应该是应用于valueOf的结果。</p>\",\"htmlExcerpt\":\"<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    return fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n</code></pre>\\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    fn.toString = function() {\\n        return x;\\n    }\\n\\n    return fn;\\n}\\n\\n\\n// chrome  function 6\\n// firefox function add/fn\\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\\nconsole.log(add(1)(2)(3))\\n\\nconsole.log(add(1)(2)(3).toString()) // 6\\n</code></pre>\\n\"}}],\"page\":2,\"pages\":3,\"total\":14,\"limit\":5,\"prev\":\"/blog/1\",\"next\":\"/blog/3\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-2-708bb766f7bd67577926.js","module.exports = {\"pathContext\":{\"nodes\":[{\"node\":{\"frontmatter\":{\"title\":\"webpack2新特性&迁移\",\"date\":\"2017-06-24\",\"category\":[\"前端工具\"],\"tags\":[\"webpack\"],\"path\":\"/post/webpack2\"},\"excerpt\":\"\\nwebpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。\\n\\n# 从webpack1中迁移\\n官方已经给出了详细的[迁移指南](https://webpack.js.org/guides/migrating/)，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。\\n\\n## 配置文件\\n如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。\\n\\n### `module.loaders`变成`module.rules`\\n旧的`module.loader`被`module.rules`取代，后者允许配置`loader`更多选项，具体查看文档[module.rules](https://webpack.js.org/configuration/module/#module-rules)\\n\\n```javascript\\n// ...\\nmdoule: {\\n    rules: [\\n        {\\n            test: /\\\\.css$/,\\n            use: [\\n                { loader: 'style-loader' },\\n                {\\n                    loader: 'css-loader',\\n                    options: { module: true }\\n                }\\n            ]\\n        },\\n        {\\n            test: /\\\\.jsx$/,\\n            loader: 'babel-loader',\\n            options: {\\n                // ...\\n            }\\n        }\\n    ]\\n}\\n// ...\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"从webpack1中迁移\"},{\"depth\":2,\"value\":\"配置文件\"},{\"depth\":3,\"value\":\"变成\"},{\"depth\":3,\"value\":\"改动\"},{\"depth\":3,\"value\":null},{\"depth\":3,\"value\":\"CLI中配置使用自定义参数\"},{\"depth\":2,\"value\":\"主要变更\"},{\"depth\":3,\"value\":\"ES6模块\"},{\"depth\":1,\"value\":\"总结\"},{\"depth\":2,\"value\":\"参考\"}],\"html\":\"<p>webpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。</p>\\n<h1>从webpack1中迁移</h1>\\n<p>官方已经给出了详细的<a href=\\\"https://webpack.js.org/guides/migrating/\\\">迁移指南</a>，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。</p>\\n<h2>配置文件</h2>\\n<p>如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。</p>\\n<h3><code>module.loaders</code>变成<code>module.rules</code></h3>\\n<p>旧的<code>module.loader</code>被<code>module.rules</code>取代，后者允许配置<code>loader</code>更多选项，具体查看文档<a href=\\\"https://webpack.js.org/configuration/module/#module-rules\\\">module.rules</a></p>\\n<pre><code class=\\\"language-javascript\\\">// ...\\nmdoule: {\\n    rules: [\\n        {\\n            test: /\\\\.css$/,\\n            use: [\\n                { loader: 'style-loader' },\\n                {\\n                    loader: 'css-loader',\\n                    options: { module: true }\\n                }\\n            ]\\n        },\\n        {\\n            test: /\\\\.jsx$/,\\n            loader: 'babel-loader',\\n            options: {\\n                // ...\\n            }\\n        }\\n    ]\\n}\\n// ...\\n</code></pre>\\n<!-- more -->\\n<pre><code class=\\\"language-javascript\\\">// ...\\nmodule: {\\n    rules: {\\n        test: /\\\\.less$/,\\n        use: ['style-loader', 'css-loader', 'less-loader']\\n    }\\n}\\n// ...\\n</code></pre>\\n<p>除上面两项外还有</p>\\n<ul>\\n<li>现在指定loader的时候不能再省略<code>-loader</code>后缀。具体原因参阅<a href=\\\"https://github.com/webpack/webpack/issues/2986\\\">#2968</a></li>\\n<li><code>json-loader</code>不需再手动添加。</li>\\n<li>loader默认的resolve配置是相对于<code>context</code>配置项的。</li>\\n<li>取消了<code>module.preLoaders</code>以及<code>module.postLoaders</code>。</li>\\n</ul>\\n<h3><code>UglifyPlugin</code>改动</h3>\\n<ul>\\n<li><code>UglifyPlugin</code>的<code>sourceMap</code>现在的默认值的<code>false</code>而不是<code>true</code>。</li>\\n<li><code>UglifyJsPlugin</code>的<code>compress.warnings</code>配置项现在默认为<code>false</code>而不是<code>true</code>。</li>\\n</ul>\\n<h3><code>ExtractTextWebpackPlugin</code></h3>\\n<p>插件变化主要体现在语法上，又原来的单个参数传变成了对象，现在的配置方式如下</p>\\n<pre><code class=\\\"language-javascript\\\">// ExtractTextPlugin.extract\\nmodule: {\\n    rules: [\\n        test: /\\\\.css$/,\\n        loader: ExtractTextPlugin.extract({\\n            fallbackLoader: 'style-loader',\\n            loader: 'css-loader',\\n            publicPath: '/dist'\\n        })\\n    ]\\n}\\n\\n// new ExtractTextPlugin({options})\\nplugins: [\\n    new ExtractTextPlugin({\\n        filename: 'bundle.css',\\n        disabled: true,\\n        allChunks: true\\n    })\\n]\\n</code></pre>\\n<h3>CLI中配置使用自定义参数</h3>\\n<p>在webpack1中可以用<code>process.argv</code>获取自定义参数，但是在webpack2中这行为被禁止了，替代地提供了一个接口<code>env</code>去获取自定义参数</p>\\n<pre><code class=\\\"language-javascript\\\">module.export = function(env) {\\n    var customStuff = env.customStuff;\\n\\n    // ...\\n    return config;\\n};\\n</code></pre>\\n<h2>主要变更</h2>\\n<h3>ES6模块</h3>\\n<p>webpack2现在增加对ES6的模块化的原生支持，意味着现在能够直接识别<code>import</code>和<code>export</code>了，不需要先转成CommonJS模块的格式。\\n支持原生<code>import</code>带来的影响就是支持异步加载模块，webpack1使用异步模块的时候如下</p>\\n<pre><code class=\\\"language-javascript\\\">require.ensure(['a'], function(a) {\\n    a.doSomething()\\n}, 'chunkName')\\n</code></pre>\\n<p>webpack2的<code>import</code>会返回一个<code>promise</code>对象</p>\\n<pre><code class=\\\"language-javascript\\\">import('a').then(function(a) {\\n    a.doSomething()\\n})\\n</code></pre>\\n<p>而且现在<strong>chunk加载失败能被Promise捕捉到</strong>，那就意味着我们能够在组件加载失败的时候采取相应的操作。</p>\\n<p>另外现在<code>import</code>还支持动态表达式。</p>\\n<pre><code class=\\\"language-javascript\\\">function route(path, query) {\\n    return import('/routes/${path}/route').then(route => new route.Route(query);\\n    })\\n}\\n</code></pre>\\n<h1>总结</h1>\\n<p>用着<em>vim-mode</em>，写完这篇已经完全头皮发麻了，完全熟悉估计不知道还要多久呢。回正题，·从官方文档来看，改动的地方的确不多，迁移成本应该是比较低的，至于要不要迁移我觉得还是见仁见智吧，如果新版的优点好处大于迁移的成本的话各位应该可以放心去改动你的配置文件了。总的来说webpack2有以下几个优点</p>\\n<ul>\\n<li>编译速度提高</li>\\n<li>编译文件大小相对减少了</li>\\n<li>支持promise</li>\\n<li>能捕捉到chunk加载失败</li>\\n</ul>\\n<h2>参考</h2>\\n<ul>\\n<li><a href=\\\"https://webpack.js.org/guides/migrating/\\\">Migrating from v1 to v2</a></li>\\n<li><a href=\\\"http://www.tuicool.com/articles/aieAnan\\\">升级到 webpack2</a></li>\\n<li><a href=\\\"http://imweb.io/topic/58666d57b3ce6d8e3f9f99b0\\\">webpack2 的 tree-shaking 好用吗？</a></li>\\n</ul>\",\"htmlExcerpt\":\"<p>webpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。</p>\\n<h1>从webpack1中迁移</h1>\\n<p>官方已经给出了详细的<a href=\\\"https://webpack.js.org/guides/migrating/\\\">迁移指南</a>，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。</p>\\n<h2>配置文件</h2>\\n<p>如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。</p>\\n<h3><code>module.loaders</code>变成<code>module.rules</code></h3>\\n<p>旧的<code>module.loader</code>被<code>module.rules</code>取代，后者允许配置<code>loader</code>更多选项，具体查看文档<a href=\\\"https://webpack.js.org/configuration/module/#module-rules\\\">module.rules</a></p>\\n<pre><code class=\\\"language-javascript\\\">// ...\\nmdoule: {\\n    rules: [\\n        {\\n            test: /\\\\.css$/,\\n            use: [\\n                { loader: 'style-loader' },\\n                {\\n                    loader: 'css-loader',\\n                    options: { module: true }\\n                }\\n            ]\\n        },\\n        {\\n            test: /\\\\.jsx$/,\\n            loader: 'babel-loader',\\n            options: {\\n                // ...\\n            }\\n        }\\n    ]\\n}\\n// ...\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"深入学习javascript-闭包\",\"date\":\"2017-06-14\",\"category\":null,\"tags\":null,\"path\":\"/post/js-closures\"},\"excerpt\":\"\\n# 什么是闭包\\n记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。\\n\\n> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）\\n\\n然后看个例子\\n```javascript\\nfunction foo() {\\n\\tvar a = 2;\\n\\n\\tfuntion bar() {\\n\\t\\tconsole.log(a);\\n\\t}\\n\\n\\tbar();\\n}\\n\\nfoo();\\n```\\n如果按上面第一条的定义，这里一定是生成了闭包，但是**确切的说并不是**，这里最准确的说是`bar`对`a`的引用方式是词法作用域的查找规则，而这些只是**闭包**的一部分。然后再看清晰闭包的例子\\n\\n```javascript\\nfucntion foo() {\\n\\tvar a = 2;\\n\\n\\tfunction bar() {\\n\\t\\tconsole.log(a)\\n\\t}\\n\\n\\treturn bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"什么是闭包\"},{\"depth\":1,\"value\":\"闭包与变量\"},{\"depth\":1,\"value\":\"模块\"},{\"depth\":2,\"value\":\"现代的模块机制\"},{\"depth\":1,\"value\":\"总结\"}],\"html\":\"<h1>什么是闭包</h1>\\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\\n<blockquote>\\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）</p>\\n</blockquote>\\n<p>然后看个例子</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    funtion bar() {\\n        console.log(a);\\n    }\\n\\n    bar();\\n}\\n\\nfoo();\\n</code></pre>\\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\\n<pre><code class=\\\"language-javascript\\\">fucntion foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a)\\n    }\\n\\n    return bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n</code></pre>\\n<!-- more -->\\n<p>在这例子中，<code>bar</code>也是在<code>foo</code>的作用域内，但是不是直接执行，而是作为返回值返回。\\n<code>foo()</code>执行后，返回值<code>bar</code>赋值给<code>baz</code>并执行<code>baz()</code>，在这里，<code>bar()</code>显然可以正常执行，它在自己定义的词法作用域<strong>以外</strong>的地方。</p>\\n<p>在<code>foo()</code>执行之后，按js的垃圾回收机制，应该会对其进行回收，而闭包的神奇之处就是可以阻止这事情发生，因此<code>baz()</code>在执行的时候依然可以访问<code>a</code>。在此一看，原来平时写的大多数代码都是闭包啊。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a);\\n    }\\n\\n    baz(bar);\\n}\\n\\nfunction baz(fn) {\\n    fn &#x26;&#x26; fn(); // 这里也是闭包\\n}\\n</code></pre>\\n<h1>闭包与变量</h1>\\n<p>要说明闭包，for循环也是一个很好的例子</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 1; i &#x3C;= 10; i++) {\\n    setTimeout(function timer() {\\n        console.log(i)\\n    }, i * 1000)\\n}\\n</code></pre>\\n<p>正常情况下，我们会预期的认为这段会每秒输出1～10，但实际，这段代码会<strong>每秒输出10次11</strong>。</p>\\n<p>首先<strong>11</strong>是那里来的，这个循环应该是在<code>i=11</code>的时候符合终止条件，所以代码输出的是循环结束时<strong>i</strong>的最终值。</p>\\n<p>细想一下，答案其实显而易见，<strong>setTimeout</strong>会推到栈底部执行，所以会在循环结束后才开始执行，所以每次都是输出<strong>11</strong>。但是什么问题造成这样的结果呢。</p>\\n<p>虽然<strong>setTimeout</strong>都是在每个迭代时候分别定义的，但是根据作用域原理，其实几个函数都是都是<strong>保存在一个封闭的作用域中</strong>，因此它们引用都是同一个<strong>来自全局的i</strong>。</p>\\n<p>所以解决方法也很简单，我们需要每次循环都新建一个作用域，然后把迭代的值传入作用域中，所以我们可以用<strong>IIFE</strong>（上一篇作用域有介绍，IIFE是一个匿名函数，每次调用都会创建作用域）来解决</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 1; i &#x3C;= 10; i++) {\\n    (function(j) {\\n        setTimeout(function timer() {\\n            console.log(j)\\n        }, j * 1000)\\n    })(i)\\n}\\n\\n// 换成ES6中的let也可以\\nfor(let i = 1; i &#x3C;= 10; i++) {\\n    setTimeout(function timer() {\\n        console.log(i)\\n    }, i * 1000)\\n}\\n</code></pre>\\n<h1>模块</h1>\\n<p>闭包除了平时实现的回调功能外，还可以实现另外一个强大的功能，<strong>模块</strong>。\\n旧的模块实现方式，如jQuery就可以使用闭包实现</p>\\n<pre><code class=\\\"language-javascript\\\">var $ = jQuery = (function Module(id) {\\n    var a = 2;\\n\\n    function doSomething() {\\n        console.log(a);\\n    }\\n\\n    function identify1() {\\n        console.log(id);\\n    }\\n\\n    function identify2() {\\n        console.log(id.toUpperCase());\\n    }\\n\\n    function change() {\\n        public.identify = identify2;\\n    }\\n\\n    var public = {\\n        doSomething: doSomething,\\n        identify: identify1,\\n        change: change\\n    }\\n\\n    return public;\\n})('hello')\\n\\n$.doSomething() // 2\\n$.identify() // hello\\n$.change()\\n$.identify() // HELLO\\n</code></pre>\\n<p>如果不用单例的话不用<strong>IIFE</strong>即可，通过在模块内保留对公共API的引用，可以从<strong>内部</strong>对模块实例进行修改，包括添加，删除，修改属性或者方法。</p>\\n<h2>现代的模块机制</h2>\\n<p>现在大部分的模块加载器本质上都是将这种模块定义封装进API中，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var Module = (function Manager() {\\n    var modules = {};\\n\\n    function define(name, deps, impl) {\\n        for(var i = 0; i &#x3C; deps.length; i++) {\\n            // 在modules中寻找名字为deps[i]的模块\\n            deps[i] = modules[deps[i]];\\n        }\\n        // 将依赖的模块作为arguments传入module中\\n        modules[name] = impl.apply(impl, deps);\\n    }\\n\\n    function require(name) {\\n        return modules[name];\\n    }\\n\\n    return {\\n        define: define,\\n        require: require\\n    }\\n})()\\n</code></pre>\\n<p>这段代码核心在<code>module[name] = impl.apply(impl, deps)</code>中，模块都按名字保存在<code>modules</code>变量中，每次都能根据获取相关模块。下面看看使用方式。</p>\\n<pre><code class=\\\"language-javascript\\\">Module.define('foo', [], function() {\\n    function hello(who) {\\n        return 'Hello ' + who;\\n    }\\n\\n    return {\\n        hello: hello\\n    }\\n})\\n\\nModule.define('bar', ['foo'], function(foo) {\\n    function awsome() {\\n        return foo.hello('kit').toUpperCase();\\n    }\\n\\n    return {\\n        awsome: awsome\\n    }\\n})\\n\\nvar foo = Module.require('foo'),\\n    bar = Module.require('bar');\\n\\nfoo.hello('kit'); // Hello kit\\nbar.awsome() // HELLO KIT\\n</code></pre>\\n<h1>总结</h1>\\n<p>从上面可以知道，平时写的js大部分代码都使用了闭包，通过了解闭包和作用域的运行方式，能够减少平时使用的出现的错误。也能通过闭包，使用js实现模块化等其他更多的功能。</p>\",\"htmlExcerpt\":\"<h1>什么是闭包</h1>\\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\\n<blockquote>\\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）</p>\\n</blockquote>\\n<p>然后看个例子</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a = 2;\\n\\n    funtion bar() {\\n        console.log(a);\\n    }\\n\\n    bar();\\n}\\n\\nfoo();\\n</code></pre>\\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\\n<pre><code class=\\\"language-javascript\\\">fucntion foo() {\\n    var a = 2;\\n\\n    function bar() {\\n        console.log(a)\\n    }\\n\\n    return bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"用python写一个简单爬虫\",\"date\":\"2017-06-11\",\"category\":null,\"tags\":null,\"path\":\"/post/python-crawler\"},\"excerpt\":\"\\n之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。\\n\\n# 主要需求\\n这个demo中爬虫有3个主要模块，**URL管理器**、**下载器**、**解析器**\\n* URL管理器主要处理爬取的URL的状态。\\n* 下载器会通过**URL管理器**传送过来有效URL进行下载。\\n* 解析器会将**下载器**下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给**URL管理器**进行重复操作。\\n\\n## 入口程序\\n`spider_main`文件为程序入口，处理整个爬虫的运行逻辑\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"主要需求\"},{\"depth\":2,\"value\":\"入口程序\"},{\"depth\":2,\"value\":\"url管理器\"},{\"depth\":2,\"value\":\"下载器\"},{\"depth\":2,\"value\":\"解析器\"},{\"depth\":1,\"value\":\"总结\"}],\"html\":\"<p>之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。</p>\\n<h1>主要需求</h1>\\n<p>这个demo中爬虫有3个主要模块，<strong>URL管理器</strong>、<strong>下载器</strong>、<strong>解析器</strong></p>\\n<ul>\\n<li>URL管理器主要处理爬取的URL的状态。</li>\\n<li>下载器会通过<strong>URL管理器</strong>传送过来有效URL进行下载。</li>\\n<li>解析器会将<strong>下载器</strong>下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给<strong>URL管理器</strong>进行重复操作。</li>\\n</ul>\\n<h2>入口程序</h2>\\n<p><code>spider_main</code>文件为程序入口，处理整个爬虫的运行逻辑</p>\\n<!-- more -->\\n<pre><code class=\\\"language-python\\\">import url_manager, html_downloader, html_outputer, html_parser\\nimport sys\\n\\nclass SpiderMain(object):\\n    def __init__(self):\\n        self.urls = url_manager.UrlManager()\\n        self.downloder = html_downloader.HtmlDownloader()\\n        self.parser = html_parser.HtmlParser()\\n        self.outputer = html_outputer.HtmlOutputer()\\n\\n    def crawl(self, root_url):\\n        count = 1\\n        # 初始化原始的爬取地址\\n        self.urls.add_new_ursl(root_url)\\n\\n        while self.urls.has_new_url():\\n            try:\\n                new_url = self.urls.get_new_url()\\n                print 'crawl %d : %s' % (count, new_url)\\n                html_cont = self.downloder.download(new_url)\\n                new_urls, new_data = self.parser.parse(new_url, html_cont)\\n\\n                self.urls.add_new_urls(new_urls)\\n                self.outputer.collect_data(new_data)\\n\\n                # 爬取的数据到1000条时跳出循环\\n                if count == 1000:\\n                    break\\n\\n                count = count + 1\\n            except:\\n                # 使用sys抛出其他函数错误\\n                info=sys.exc_info()\\n                print info[0],\\\":\\\",info[1]\\n\\n                print 'crawl failed'\\n\\n        # 将爬取的数据组装\\n        self.outputer.output_html()\\n\\nif __name__ == '__main__':\\n    root_url = 'http://baike.baidu.com/item/Python'\\n    obj_spider = SpiderMain()\\n    obj_spider.crawl(root_url)\\n</code></pre>\\n<h2>url管理器</h2>\\n<pre><code class=\\\"language-python\\\"># url_manager.py\\nclass UrlManager(object):\\n    def __init__(self):\\n        self.new_urls = set()\\n        self.old_urls = set()\\n\\n    # 添加一条新的url\\n    def add_new_url(self, url):\\n        if url is None:\\n            return\\n\\n        if url not in self.new_urls and url not in self.old_urls:\\n            self.new_urls.add(url)\\n\\n    # 添加多条url\\n    def add_new_urls(self, urls):\\n        if urls is None and len(urls) == 0:\\n            return\\n\\n        for url in urls:\\n            self.add_new_url(url)\\n\\n    # 是否有代爬取地址\\n    def has_new_url(self):\\n        return len(self.new_urls) != 0\\n\\n    # 返回一条新的url\\n    def get_new_url(self):\\n        new_url = self.new_urls.pop()\\n        self.old_urls.add(new_url)\\n        return new_url\\n</code></pre>\\n<h2>下载器</h2>\\n<p>下载器使用自带的<a href=\\\"https://docs.python.org/2/library/urllib2.html\\\">urllib2</a>库处理请求</p>\\n<pre><code class=\\\"language-python\\\"># html_downloader.py\\nimport urllib2\\n\\nclass HtmlDownloader(object):\\n    def download(self, url):\\n        if url is None:\\n            return\\n\\n        # 这里设置一下超时，不然网络会使程序运行出现停止\\n        response = urllib2.urlopen(url, timeout = 5)\\n\\n        # 请求失败时候跳出程序\\n        if response.getcode() != 200:\\n            return None\\n\\n        return response.read()\\n</code></pre>\\n<h2>解析器</h2>\\n<p>解析器分为两部分，一个解析，一个输出，首先看看解析模块。</p>\\n<p>解析html我们使用了<a href=\\\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\\\">beautifulsoup</a>，解析后可以使用库提供的方法做DOM操作，获取有用的信息</p>\\n<pre><code class=\\\"language-python\\\"># html_parser.py\\nfrom bs4 import BeautifulSoup\\nimport re\\nimport urlparse\\n\\nclass HtmlParser(object):\\n    def _get_new_urls(self, page_url, soup):\\n        new_urls = set()\\n\\n        # 获取a标签中所有匹配的url地址\\n        links = soup.find_all('a', href=re.compile(r'/item/'))\\n        for link in links:\\n            new_url = link['href']\\n            new_full_url = urlparse.urljoin(page_url, new_url)\\n            new_urls.add(new_full_url)\\n\\n        return new_urls\\n\\n    def _get_new_data(self, page_url, soup):\\n        res_data = {}\\n\\n        # 获取页面相关内容\\n        res_data['url'] = page_url\\n\\n        # &#x3C;dd class=\\\"lemmaWgt-lemmaTitle-title\\\"> &#x3C;h1>Python&#x3C;/h1>\\n        title_node = soup.find('dd', class_='lemmaWgt-lemmaTitle-title').find('h1')\\n        res_data['title'] = title_node.get_text()\\n\\n        # &#x3C;div class=\\\"lemma-summary\\\" label-module=\\\"lemmaSummary\\\">\\n        summary_node = soup.find('div', class_='lemma-summary')\\n        res_data['summary'] = summary_node.get_text()\\n\\n        return res_data\\n\\n    def parse(self, page_url, html_cont):\\n        if page_url is None or html_cont is None:\\n            return\\n\\n        soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8')\\n        new_urls = self._get_new_urls(page_url, soup)\\n        new_data = self._get_new_data(page_url, soup)\\n\\n        return new_urls, new_data\\n</code></pre>\\n<pre><code class=\\\"language-python\\\"># html_outputer.py\\nclass HtmlOutputer(object):\\n    def __init__(self):\\n        self.datas = []\\n\\n    # 获取到的页面内容对象push到数组中\\n    def collect_data(self, data):\\n        if data is None:\\n            return\\n\\n        self.datas.append(data)\\n\\n    # 将数组循环拼接，写入html文件中\\n    def output_html(self):\\n        fout = open('output.html', 'w')\\n\\n        fout.write('&#x3C;html>')\\n        fout.write('&#x3C;body>')\\n        fout.write('&#x3C;table>')\\n\\n        for data in self.datas:\\n            fout.write('&#x3C;tr>')\\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['url'])\\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['title'].encode('utf-8'))\\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['summary'].encode('utf-8'))\\n            fout.write('&#x3C;/tr>')\\n\\n        fout.write('&#x3C;/html>')\\n        fout.write('&#x3C;/body>')\\n        fout.write('&#x3C;/table>')\\n</code></pre>\\n<h1>总结</h1>\\n<p>短短几行代码就实现了一个简单的爬虫，足以体现python的简单易用。学习python主要是想了解一下机器学习，后面会看一些书籍和资料，应该会再记录，但是后面估计会先写完深度学习javascript系列先。</p>\",\"htmlExcerpt\":\"<p>之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。</p>\\n<h1>主要需求</h1>\\n<p>这个demo中爬虫有3个主要模块，<strong>URL管理器</strong>、<strong>下载器</strong>、<strong>解析器</strong></p>\\n<ul>\\n<li>URL管理器主要处理爬取的URL的状态。</li>\\n<li>下载器会通过<strong>URL管理器</strong>传送过来有效URL进行下载。</li>\\n<li>解析器会将<strong>下载器</strong>下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给<strong>URL管理器</strong>进行重复操作。</li>\\n</ul>\\n<h2>入口程序</h2>\\n<p><code>spider_main</code>文件为程序入口，处理整个爬虫的运行逻辑</p>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"深入学习javascript--作用域\",\"date\":\"2017-05-31\",\"category\":null,\"tags\":null,\"path\":\"/post/js-scope\"},\"excerpt\":\"\\n# 前言\\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\\n\\n# 作用域是什么\\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\\n\\n\\n\\n## 理解作用域执行过程\\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\\n\\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\\n\\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"前言\"},{\"depth\":1,\"value\":\"作用域是什么\"},{\"depth\":2,\"value\":\"理解作用域执行过程\"},{\"depth\":3,\"value\":\"LSH和RSH查询\"},{\"depth\":2,\"value\":\"提升\"},{\"depth\":3,\"value\":\"函数优先\"},{\"depth\":2,\"value\":\"作用域嵌套\"},{\"depth\":1,\"value\":\"函数作用域\"},{\"depth\":1,\"value\":\"块作用域\"},{\"depth\":2,\"value\":\"延长作用域链(块作用域)\"},{\"depth\":1,\"value\":\"总结\"}],\"html\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。</p>\\n<ol>\\n<li>遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。</li>\\n<li>接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</li>\\n</ol>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n<!-- more -->\\n<h3>LSH和RSH查询</h3>\\n<p>定义一个变量<code>var a = 2</code>，或者执行一个简单的函数<code>console.log(2)</code>中，会同时或者单独出现<strong>LSH</strong>或者<strong>RSH</strong>查询。其实在作用域执行过程中，第一步就是LSH查询，第二步就是RSH查询，简单点来说</p>\\n<ul>\\n<li>LSH查询就是找到变量的容器本身</li>\\n<li>RSH查询就是找到容器的原值</li>\\n</ul>\\n<pre><code class=\\\"language-javascript\\\">// var a就是LSH\\n// a = 2就是RSH\\nvar a = 2;\\n\\n// 这里的a其实就是做了一个RSH查询\\nconsole.log(a)\\n</code></pre>\\n<p>为什么需要理解这两个概念呢，因为在变量没有声明的情况下，这两种查询的行为是不一样的。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    console.log(a + b);\\n    b = a;\\n}\\n\\nfoo(2);\\n</code></pre>\\n<p>在第一次对b做RSH查询时候是无法找到该变量，所以引擎在这时候就会报出一个<code>ReferenceError</code>的错误。第二个b也还没有声明，但是引擎并没有报错，因为这里先做了LSH查询，所以可以知道，LSH查询如果未找到变量，会在全局中定义一个变量b（非严格模式下），再做RSH查询。引擎还有一个<code>TypeError</code>的错误，在试图对一个非函数类型的值执行函数调用，或者引用<code>null</code>, <code>undefined</code>类型值中的属性时候，就会报这个错误。</p>\\n<h2>提升</h2>\\n<p>很多时候都会认为javascript代码是由上到下一行一行执行的，但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p>\\n<pre><code class=\\\"language-javascript\\\">a = 2;\\n\\nvar a;\\n\\nconsole.log(a);  // 2\\n</code></pre>\\n<p>还有另外一段</p>\\n<pre><code class=\\\"language-javascript\\\">console.log(a); // undefined\\n\\nvar a = 2;\\n</code></pre>\\n<p>当js执行一个<code>var a = 2</code>的时候，这里并不是我们看到的一个声明，而是<code>var a</code>, <code>a = 2</code>两个声明，<code>var a</code>会在编译阶段执行，<code>a = 2</code>则会在执行阶段执行。所以第二段代码就很容易解释通了，代码执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var a;\\n\\nconsole.log(a);\\n\\na = 2;\\n</code></pre>\\n<p>而这个函数声明自动移动到顶部，就叫做<strong>提升</strong>。</p>\\n<p>提升操作会出现在<strong>每个作用域</strong>中，看以下代码</p>\\n<pre><code class=\\\"language-javascript\\\">foo();\\n\\nfunction foo() {\\n    console.log(a);\\n    var a = 2;\\n}\\n</code></pre>\\n<p>实际执行如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a;\\n    console.log(a);\\n    a = 2;\\n}\\n\\nfoo();\\n</code></pre>\\n<p>可以看到，函数声明会被提升到最顶部，但是函数表达式却不会被提升</p>\\n<pre><code>foo(); // TypeError\\nbar(); // ReferenceError\\n\\nvar foo = function bar() {\\n    ...\\n}\\n</code></pre>\\n<p>在这里要注意，把foo分配到具名函数下，但是具名函数下也无法在所在作用域中运行。上面函数的执行方式应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var foo;\\n\\nfoo(); // TypeError\\n\\nbar(); // ReferenceError\\n\\nfoo = function() {\\n    var bar = ... self ...\\n}\\n</code></pre>\\n<h3>函数优先</h3>\\n<p>从上面可以知道定义变量和声明函数都会触发提升，但是如果在重复声明的代码下，会出现什么情况呢</p>\\n<pre><code class=\\\"language-javascript\\\">foo(); // 1\\n\\nvar foo;\\n\\nfunction foo() {\\n    console.log(1);\\n}\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>这里会出现<strong>1</strong>而不是<strong>2</strong>！因为函数会首先被提升，再到变量，所以执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    console.log(1);\\n}\\n\\nfoo();\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>在一个普通的块( { ... } 的代码)，函数也会提升，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var a = true;\\n\\nif(a) {\\n    function foo() {\\n        ...\\n    }\\n}else {\\n    function bar() {\\n        ...\\n    }\\n}\\n</code></pre>\\n<p>这里的<code>foo</code>和<code>bar</code>都不会按判断来声明函数，所以在判断声明函数并不可靠。</p>\\n<h2>作用域嵌套</h2>\\n<p>当一个块或者函数嵌套在另一个块或者函数中，就称为作用域嵌套。在当前作用域没有找到某个变量时，<strong>引擎</strong>就会在外层的作用域继续查找，直到找到该变量，或者抵达最外层（全局）作用域为止。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    // b在函数中尚未定义，所以在上一个作用域中查找\\n    // 在全局中找到变量b，赋值\\n    console.log(a + b);\\n}\\n\\nvar b = 2;\\n\\nfoo(2); // 4\\n</code></pre>\\n<h1>函数作用域</h1>\\n<p>每个函数都有自己的执行环境，或者说函数有自己作用域。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而函数执行之后，栈将其环境弹出，把控制权返回之前的执行环境。函数作用域内的变量访问正是又这个执行机制控制着。而通过这一机制，能实现隐藏作用域中变量或者函数，规避同名标识符之间的冲突。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    function bar(a) {\\n        // i会从for块中找到变量容器，然后执行赋值\\n        i = 3;\\n        console.log(a + i);\\n    }\\n\\n    for(var i = 0; i &#x3C;= 10; i++) {\\n        // 执行bar后会给i重新赋值3，满足i&#x3C;=10，函数死循环\\n        bar(i * 2);\\n    }\\n}\\n</code></pre>\\n<p>这时候只需要在bar内部修改<code>i = 3</code>为<code>var i = 3</code>，将i变为<code>bar</code>中的本地变量即可。除了新建一个函数去隐藏变量，还能通过匿名函数的特性去实现隐藏变量，社区中也称为<strong>IIFE</strong>。</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function() {\\n    var a = 3;\\n    console.log(a); // 3\\n})()\\n\\nconsole.log(a); // 2\\n</code></pre>\\n<p>还能当作函数调用传参</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function(global) {\\n    var a = 3;\\n\\n    console.log(a); // 3\\n    console.log(global.a); // 2\\n})(window)\\n</code></pre>\\n<p>通过隐藏变量活着函数，能实现<strong>全局命名空间</strong>或者<strong>JS模块化</strong>(后面会讨论到)。</p>\\n<h1>块作用域</h1>\\n<p>在JS中块作用域并不常见，但是某些代码却经常会被误以为是块作用域，所以很容易造成理解上的错误，例如下面的常用代码</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nif(true) {\\n    var foo = 'bar';\\n}\\n\\nconsole.log(i, foo); // 10 bar\\n</code></pre>\\n<p>上面代码的<code>i</code>和<code>foo</code>其实都在外部作用域中定义的，而不是在代码块中定义的变量，所以平时在这些代码中定义变量应该是距离使用的地方越近越好。</p>\\n<h2>延长作用域链(块作用域)</h2>\\n<ul>\\n<li>\\n<p>with语句。with从对象中创建出来的对象只在with声明中有效。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\nvar qs = \\\"?bar=true\\\";\\n\\nwith(location) {\\n    // href实际是location.href，只能在with内部使用\\n    var url = href + qs;\\n}\\n\\nreturn url;\\n}\\n</code></pre>\\n</li>\\n<li>\\n<p>try/catch中的catch分句会创造一个块作用域，声明的错误对象变量仅在catch内部有效。</p>\\n<pre><code class=\\\"language-javascript\\\">try {\\nundefined(); // 强制执行一个错误操作\\n} catch(err) {\\nconsole.log(err);\\n}\\n</code></pre>\\n</li>\\n</ul>\\n<p>console.log(err); // ReferenceError</p>\\n<pre><code>## let/const\\n在ES6中，引入了let和const，提供了除var以外的另一种声明变量的方式。用let/const声明的变量会绑定在所在的所用域中（通常是{ ... }内部，换句话说，let/const能劫持所在作用域。\\n```javascript\\n// 修改下上面的循环例子\\nfor(let i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nconsole.log(i); // ReferenceError\\n</code></pre>\\n<p>const在使用方法上跟len是一样，只是创建的值是固定的（常量）。后面任何修改值的操作都会报错。<strong>(注：const实际保证的并不是常量不能改变，而是变量的内存地址不能改变，所以对于复杂的类型object，也只能保证对象的指针地址是固定的，但是对象内部的数据结构则不能固定)</strong></p>\\n<pre><code class=\\\"language-javascript\\\">const foo = {};\\n\\nfoo.bar = 'bar';\\nconsole.log(foo.bar); // bar\\n\\nfoo = {}; // TypeError\\n</code></pre>\\n<h1>总结</h1>\\n<p>通过学习js中的作用域运行方式，了解变量在执行环境的声明周期，以及哪部分代码能访问其中的变量。能为后面学习<strong>闭包</strong>还有实现模块化打下基础。以下是关于作用域的几点总结：</p>\\n<ul>\\n<li>函数局部环境不仅有访问函数作用域的变量的权限，而且还有权访问其包含(父)环境的变量。</li>\\n<li>除全局、函数作用域外，还有比较少用的块作用域。</li>\\n</ul>\",\"htmlExcerpt\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</p>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"js实现add(1)(2)(3)\",\"date\":\"2017-05-28\",\"category\":[\"javascript\"],\"tags\":null,\"path\":\"/post/add-chain\"},\"excerpt\":\"\\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现\\n```javascript\\nfunction add(x) {\\n\\tvar fn = function(y) {\\n\\t\\treturn add(x + y);\\n\\t}\\n\\n\\treturn fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n```\\n\\n这样写是可以实现调用方式，但是怎么`return x`呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了`object`的`valueOf`和`toString`的方法。然后再跑了一遍。\\n```javascript\\nfunction add(x) {\\n\\tvar fn = function(y) {\\n\\t\\treturn add(x + y);\\n\\t}\\n\\n\\tfn.toString = function() {\\n\\t\\treturn x;\\n\\t}\\n\\n\\treturn fn;\\n}\\n\\n\\n// chrome  function 6\\n// firefox function add/fn\\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\\nconsole.log(add(1)(2)(3))\\n\\nconsole.log(add(1)(2)(3).toString()) // 6\\n```\\n\\n\",\"headings\":[],\"html\":\"<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    return fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n</code></pre>\\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    fn.toString = function() {\\n        return x;\\n    }\\n\\n    return fn;\\n}\\n\\n\\n// chrome  function 6\\n// firefox function add/fn\\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\\nconsole.log(add(1)(2)(3))\\n\\nconsole.log(add(1)(2)(3).toString()) // 6\\n</code></pre>\\n<!-- more -->\\n<p>由此看出在不同客户端下返回的结果并不一样，并不是完美的结果，但是查阅了其他资料并没有其他十分好的解决办法，估计这道题的考查点是关于js深度的，比如原生对象里面的基本方法和<code>alert</code>, <code>console</code>会自动执行toString等方法。</p>\\n<p>另外，<code>valueOf</code>和<code>toString</code>方法其实是差不多的，返回的结果基本都是相同的，但是试了一下定义了两个不同的方法，发现总是会返回valueOf的值先，所以觉得toString应该是应用于valueOf的结果。</p>\",\"htmlExcerpt\":\"<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    return fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n</code></pre>\\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    fn.toString = function() {\\n        return x;\\n    }\\n\\n    return fn;\\n}\\n\\n\\n// chrome  function 6\\n// firefox function add/fn\\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\\nconsole.log(add(1)(2)(3))\\n\\nconsole.log(add(1)(2)(3).toString()) // 6\\n</code></pre>\\n\"}}],\"page\":2,\"pages\":3,\"total\":14,\"limit\":5,\"prev\":\"/blog/1\",\"next\":\"/blog/3\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-2.json\n// module id = 283\n// module chunks = 225156435109840"],"sourceRoot":""}