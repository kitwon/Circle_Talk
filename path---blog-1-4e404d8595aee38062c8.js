webpackJsonp([0xa1ae2709718c],{284:function(n,s){n.exports={data:{allMarkdownRemark:{edges:[{node:{excerpt:"\n作为一个程序员，想必每个都有自己的编码风格。有风格虽好，但这问题令很多项目管理者头疼，不一样的代码风格及缩进，必会降低代码可读性，从而间接降低效率。但是这个问题都难不到我们伟大的程序员，很多如eslint，prettier等库的出现帮我们去解决问题。很多cli在生成初始项目时都会给我们加上eslint、csslint等，这不就能解决我们的问题了吗？too young too simple，每保存一次就弹出一个错误，还是一大堆英文，估计大部分人心里就默默一句what the fuck is that了，从而就导致我们嘴上虽很强硬的说着要规范我们的代码风格，身体却很诚实地默默把各种lint的配置关掉🤷🏼‍。\n所以在这篇文章里，会给大家提供一些好用的方法，使各位重拾定规范时候的激情。\n\n# something useful\n1. 使用`eslint --fix`格式化文件\n**eslint**虽好，但是对规范还没适应的同学却是一个难题，每写一遍都弹个黑白屏出来，特别英文不好的，估计半天都不知道哪里出问题，这样子下来估计半天没写几行代码。这时候其实我们可以贴心地把配置项注释掉，只有提交前跑一下`eslint --fix`这个命令就好了，大部分代码都会根据规范格式化掉。\n\n",frontmatter:{title:"使用pre-commit实现提交前验证或自动部署代码",date:"2018-03-29",category:["tools"],path:"/post/pre-commit-hook"}}},{node:{excerpt:"\n> 原文译自[10 Tips for Javascript Debugging Like a PRO with Console](https://medium.com/appsflyer/10-tips-for-javascript-debugging-like-a-pro-with-console-7140027eb5f6) - Yotam Kadishay\n\n在日常开发里，我们经常需要使用`console`调试我们的代码，但是使用仅仅是用来打印参数数据。在这篇文章中，将会介绍如何一些`console`的高级用法去更好的做调试工作和定位问题。\n\n我们都知道`console`的几个常用的方法\n\n```javascript\nconsole.log('hello world'); // 打印信息或者数据\nconsole.info(‘Something happened…’); // 和console log一样\nconsole.warn(‘Something strange happened…’); // 打印警告信息\nconsole.error(‘Something horrible happened…’); // 打印错误信息\n```\n\n除这些简单的使用外，下面几个`console`的用法希望能帮助你更好的调试你的应用。\n\n",frontmatter:{title:"10个console的高级使用方法",date:"2018-03-19",category:["javascript"],path:"/post/10tips-for-console"}}},{node:{excerpt:"\n这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。\n\n# 项目构建\n项目创建是使用vue-cli创建的，模版则是使用我自己维护的[vue-mpa](https://github.com/kitwon/vue-mpa)多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。\n\n",frontmatter:{title:"年底项目复盘",date:"2018-01-23",category:["工作"],path:"/post/2017-review"}}},{node:{excerpt:"\n> 这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。\n\n----\n\n> 现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的[render performance](https://developers.google.com/web/fundamentals/performance/rendering/)对前端渲染优化有了一个新的认识。\n\n# 几个重要概念\n## 60fps与设备刷新率\n目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。\n\n其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\n\n",frontmatter:{title:"构建60fps-web-app",date:"2017-09-13",category:["前端"],path:"/post/60fps-web-app"}}},{node:{excerpt:"\n在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下[jest](http://facebook.github.io/jest/)，这是一个[Facebook OpenSource](https://code.facebook.com/projects/)的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持**快照测试**(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。\n\n# 配置\n首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析'.vue'文件的)。\n```bash\n$ npm install jest jest-vue-preprocessor --save-dev\n\n# or use yarn\n$ yarn add jest jest-vue-preprocessor --save\n```\n\n",frontmatter:{title:"在vue项目中使用jest进行单元测试",date:"2017-08-18",category:["前端工具"],path:"/post/vue-jest-test"}}},{node:{excerpt:"\n# 类理论\n类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。\n\n类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。**汽车**可以被看作**交通工具中的一种**，所以在软件开发时可以定义一个`Vehicle`类，`Vehicle`中包含推进器（引擎）、载人能力等方法。定义`Car`时，只要声明它继承或者拓展`Vehicle`这个基础定义就行了，其他交通工具如船、飞机也可以继承`Vehicle`。**这就是类的实例化与继承**。\n\n类的另外一个核心概念是**多态**，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。\n\njavascript中也有类中的`new`和`instanceof`，还有ES6中的`class`关键字，但这些并不是说明js中有**类**的。javascript中只是为了满足类的设计需求而提供一些类似的语法。\n\n## js中实现类复制(混入)\njavascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。\n\n",frontmatter:{title:"深入学习javascript-类",date:"2017-07-20",category:null,path:"/post/js-class"}}},{node:{excerpt:"\n# 关于this\n\n`this`应该是javascript中一个比较复杂的机制了，在日常工作中我们可能有意无意都会使用到这个机制，但是`this`的工作机制真正了解的可能只有皮毛，通过学习这一机制，能够提高对js代码的理解和阅读能力，还有对js程序设计模式有着更深的理解。\n\n# this的指向\nthis是运行时进行绑定的，而不是编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n\n通过分析调用位置，就能知道this到底引用的是什么。所以，寻找调用位置就能弄清上面的问题，通过一个例子，就能很好地理解这个问题：\n```javascript\nfunction baz() {\n  // 当前调用栈是 baz\n  // 当前调用位置是全局作用域\n\n  console.log('baz');\n  bar(); // bar的调用位置\n}\n\nfunction bar() {\n  // 当前的调用栈是 baz -> bar\n  // 当前的调用位置是baz\n\n  console.log('bar');\n  foo();\n}\n\nfunction foo() {\n  // 当前的调用栈是 baz -> bar -> foo\n  // 当前的调用位置是bar\n\n  console.log('foo');\n}\n\nbaz();\n```\n\n",frontmatter:{title:"深入学习javascript - this",date:"2017-06-27",category:null,path:"/post/js-this"}}},{node:{excerpt:"\nwebpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。\n\n# 从webpack1中迁移\n官方已经给出了详细的[迁移指南](https://webpack.js.org/guides/migrating/)，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。\n\n## 配置文件\n如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。\n\n### `module.loaders`变成`module.rules`\n旧的`module.loader`被`module.rules`取代，后者允许配置`loader`更多选项，具体查看文档[module.rules](https://webpack.js.org/configuration/module/#module-rules)\n\n```javascript\n// ...\nmdoule: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [\n                { loader: 'style-loader' },\n                {\n                    loader: 'css-loader',\n                    options: { module: true }\n                }\n            ]\n        },\n        {\n            test: /\\.jsx$/,\n            loader: 'babel-loader',\n            options: {\n                // ...\n            }\n        }\n    ]\n}\n// ...\n```\n\n",frontmatter:{title:"webpack2新特性&迁移",date:"2017-06-24",category:["前端工具"],path:"/post/webpack2"}}},{node:{excerpt:"\n# 什么是闭包\n记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。\n\n> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\n--- 你不知道的javascript（上卷）\n\n然后看个例子\n```javascript\nfunction foo() {\n\tvar a = 2;\n\n\tfuntion bar() {\n\t\tconsole.log(a);\n\t}\n\n\tbar();\n}\n\nfoo();\n```\n如果按上面第一条的定义，这里一定是生成了闭包，但是**确切的说并不是**，这里最准确的说是`bar`对`a`的引用方式是词法作用域的查找规则，而这些只是**闭包**的一部分。然后再看清晰闭包的例子\n\n```javascript\nfucntion foo() {\n\tvar a = 2;\n\n\tfunction bar() {\n\t\tconsole.log(a)\n\t}\n\n\treturn bar;\n}\n\nvar baz = foo()；\n\nbaz(); // 这就是闭包效果\n```\n\n",frontmatter:{title:"深入学习javascript-闭包",date:"2017-06-14",category:null,path:"/post/js-closures"}}},{node:{excerpt:"\n之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。\n\n# 主要需求\n这个demo中爬虫有3个主要模块，**URL管理器**、**下载器**、**解析器**\n* URL管理器主要处理爬取的URL的状态。\n* 下载器会通过**URL管理器**传送过来有效URL进行下载。\n* 解析器会将**下载器**下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给**URL管理器**进行重复操作。\n\n## 入口程序\n`spider_main`文件为程序入口，处理整个爬虫的运行逻辑\n\n",frontmatter:{title:"用python写一个简单爬虫",date:"2017-06-11",category:null,path:"/post/python-crawler"}}},{node:{excerpt:"\n# 前言\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\n\n# 作用域是什么\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\n\n\n\n## 理解作用域执行过程\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\n\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\n\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\n\n",frontmatter:{title:"深入学习javascript--作用域",date:"2017-05-31",category:null,path:"/post/js-scope"}}},{node:{excerpt:"\n# 题目\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现\n\n```javascript\nfunction add(x) {\n\tvar fn = function(y) {\n\t\treturn add(x + y);\n\t}\n\n\treturn fn;\n}\n\nconsole.log(add(1)(2)(3))\n```\n\n",frontmatter:{title:"js实现add(1)(2)(3)",date:"2017-05-28",category:["javascript"],path:"/post/add-chain"}}},{node:{excerpt:"\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\n\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\n\n\n\n# 初步构建一个Promise\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\n```javascript\n// 例1\nfunction getAsyncData() {\n\treturn new Promise(function(resolve, reject) {\n\t\tsetTimeout(function() {\n\t\t\tresolve('promise done!')\n\t\t}, 1000)\n\t})\n}\n\ngetAsyncData().then(function(result) {\n\tconsole.log(result);\n}).then(function() {\n\tconsole.log('done too!');\n})\n```\n\n",frontmatter:{title:"Promise的简单实现",date:"2017-05-17",category:["前端"],path:"/post/js-promise"}}},{node:{excerpt:"\n# 什么是单元-测试?\n- 单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。\n- 而测试，就是测试啦。\n\n所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。\n\n# 为什么要写单元测试？\n单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。\n\n",frontmatter:{title:"前端单元测试&Mocha指北",date:"2017-05-16",category:["前端"],path:"/post/unit-test"}}},{node:{excerpt:'\n> 原文译自[Smashing Magazine](https://www.smashingmagazine.com/) -- [[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)\n\n相信很多前端都听说过或者使用过[Gulp](http://www.gulpjs.com.cn/), [Angular CLI](https://cli.angular.io/), [Cordova](https://cordova.apache.org/), [Yeoman](http://yeoman.io/)或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用`ng new <project-name>`后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。\n\n在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用[SendGrid Api](https://github.com/sendgrid/sendgrid-nodejs)模拟发送）\n文章目录：\n1."Hello World"\n2.处理命令行参数\n3.运行时输入参数\n4.模拟发送邮件\n5.改变输出内容样式\n6.变成shell命令\n\n',frontmatter:{title:"使用nodejs写一个命令行程序",date:"2017-05-16",category:["前端"],path:"/post/node-command-app"}}},{node:{excerpt:"\n好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。\n\n### 小科普\n什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！\n\n",frontmatter:{title:"React-todo demo",date:"2016-03-02",category:["js framework"],path:"/post/react-todo"}}}]}},pathContext:{edgesLen:16,tagsLen:14,categoryLen:6,nodes:[{node:{frontmatter:{title:"使用pre-commit实现提交前验证或自动部署代码",date:"2018-03-29",category:["tools"],tags:["自动化","前端工具"],path:"/post/pre-commit-hook"},excerpt:"\n作为一个程序员，想必每个都有自己的编码风格。有风格虽好，但这问题令很多项目管理者头疼，不一样的代码风格及缩进，必会降低代码可读性，从而间接降低效率。但是这个问题都难不到我们伟大的程序员，很多如eslint，prettier等库的出现帮我们去解决问题。很多cli在生成初始项目时都会给我们加上eslint、csslint等，这不就能解决我们的问题了吗？too young too simple，每保存一次就弹出一个错误，还是一大堆英文，估计大部分人心里就默默一句what the fuck is that了，从而就导致我们嘴上虽很强硬的说着要规范我们的代码风格，身体却很诚实地默默把各种lint的配置关掉🤷🏼‍。\n所以在这篇文章里，会给大家提供一些好用的方法，使各位重拾定规范时候的激情。\n\n# something useful\n1. 使用`eslint --fix`格式化文件\n**eslint**虽好，但是对规范还没适应的同学却是一个难题，每写一遍都弹个黑白屏出来，特别英文不好的，估计半天都不知道哪里出问题，这样子下来估计半天没写几行代码。这时候其实我们可以贴心地把配置项注释掉，只有提交前跑一下`eslint --fix`这个命令就好了，大部分代码都会根据规范格式化掉。\n\n",headings:[{depth:1,value:"something useful"},{depth:1,value:"Pre-commit hook"},{depth:2,value:"husky + lint-stage"},{depth:2,value:"集成prettier和Jest"},{depth:1,value:"Last"},{depth:2,value:"相关文档"}],html:'<p>作为一个程序员，想必每个都有自己的编码风格。有风格虽好，但这问题令很多项目管理者头疼，不一样的代码风格及缩进，必会降低代码可读性，从而间接降低效率。但是这个问题都难不到我们伟大的程序员，很多如eslint，prettier等库的出现帮我们去解决问题。很多cli在生成初始项目时都会给我们加上eslint、csslint等，这不就能解决我们的问题了吗？too young too simple，每保存一次就弹出一个错误，还是一大堆英文，估计大部分人心里就默默一句what the fuck is that了，从而就导致我们嘴上虽很强硬的说着要规范我们的代码风格，身体却很诚实地默默把各种lint的配置关掉🤷🏼‍。\n所以在这篇文章里，会给大家提供一些好用的方法，使各位重拾定规范时候的激情。</p>\n<h1>something useful</h1>\n<ol>\n<li>使用<code class="language-text">eslint --fix</code>格式化文件\n<strong>eslint</strong>虽好，但是对规范还没适应的同学却是一个难题，每写一遍都弹个黑白屏出来，特别英文不好的，估计半天都不知道哪里出问题，这样子下来估计半天没写几行代码。这时候其实我们可以贴心地把配置项注释掉，只有提交前跑一下<code class="language-text">eslint --fix</code>这个命令就好了，大部分代码都会根据规范格式化掉。</li>\n</ol>\n<!-- more -->\n<ol start="2">\n<li>\n<p>使用各种编辑器、IDE插件\n上方方法虽好，但是我们还是要从源头上解决问题，培养每个人的代码风格以及习惯，这时候插件就能帮住我们在写代码的时候及时发现，也不用看到一大片错误了。</p>\n</li>\n<li>\n<p>使用<strong>prettier</strong>格式化代码\nPrettier可以帮助我们做一些代码格式化的工作，如代码缩进，双引号变单引号等一些代码格式化工作，但是有些配置项与eslint是重复的，下面会介绍到如何解决。具体配置项可以查看<a href="https://prettier.io/docs/en/install.html">官网文档</a>。</p>\n</li>\n</ol>\n<p>虽然有很多方法提醒我们注意代码质量，但是有时候这并不能阻止我们把有linting error的代码提交到仓库上。有时候没有什么大问题，但是如果是使用YUI压缩或者其他代码检查工具导致发布失败，我们将会需要用大量地时间去找到n个人提交的代码中的1个不显眼的语法错误。</p>\n<h1>Pre-commit hook</h1>\n<p>所以，什么是<strong>pre-commit hook</strong>？其实Git给我门提供了很多钩子，比如pre-commit这个，就是提交前，还有提交后，其他钩子可自行查<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">Git - Git 钩子</a>。(SVN暂时无能为力，不过Google中有提供解决方案，但是看过一下实现起来颇麻烦的，大家有兴趣可以自行查找一下)</p>\n<h2>husky + lint-stage</h2>\n<p>假设你的项目中已经有了eslint和使用vue，然后我们需要安装两个package</p>\n<div class="gatsby-highlight">\n      <pre class="language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> husky lint-stage --save-dev\n\n<span class="token comment"># or use yarn</span>\n$ yarn add husky lint-stage -D\n</code></pre>\n      </div>\n<p><strong>1.</strong>    然后在<code class="language-text">package.json</code>文件中添加如下配置</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token comment">// package.json</span>\n<span class="token punctuation">{</span>\n<span class="token comment">// ...</span>\n  <span class="token string">"script"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"lint"</span><span class="token punctuation">:</span> <span class="token string">"eslint --ext .js,.vue"</span><span class="token punctuation">,</span>\n    <span class="token string">"precommit"</span><span class="token punctuation">:</span> <span class="token string">"lint-staged"</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token string">"lint-staged"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"*.{js|vue}"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token string">"npm run lint"</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p><strong>2.</strong>    然后随便找个文件删掉两个缩进空格，然后跑下提交命令<code class="language-text">git commit -am &#39;test precommit&#39;</code>，此时应该可以看到下图的运行及报错。</p>\n<p>⚠️ 这里的错误大家可以看到是preiiter抛出的，是因为我的配置文件已经集成了prettier，如何集成下方有介绍。\n<img src="http://kiit-1253813979.file.myqcloud.com/pre-commit-hook/lint-error.jpg" alt="pre-commit-error"></p>\n<p>如果想使用eslint自动修复错误，可以修改成如下配置</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token comment">// package.json</span>\n<span class="token punctuation">{</span>\n<span class="token comment">// ...</span>\n  <span class="token string">"script"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"lint"</span><span class="token punctuation">:</span> <span class="token string">"eslint --fix --ext .js,.vue"</span><span class="token punctuation">,</span>\n    <span class="token string">"precommit"</span><span class="token punctuation">:</span> <span class="token string">"lint-staged"</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token string">"lint-staged"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"*.{js|vue}"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token string">"npm run lint"</span><span class="token punctuation">,</span>\n      <span class="token string">"git add"</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>这样修正好的文件就会重新跑一遍add命令，我们只需重按一下⬆️键重新跑一下命令提交即可，perfect。</p>\n<h2>集成prettier和Jest</h2>\n<p><strong>1.</strong>    prettier虽然和eslint有很多共同配置，但是prettier还可以对<code class="language-text">vue template</code>和样式文件做验证和格式化，更多配置方式可以查看<a href="https://prettier.io/docs/en/index.html">文档</a>，下面只介绍快速集成eslint和prettier的方式。首先我们需要安装<code class="language-text">eslint-plugin-prettier</code>和<code class="language-text">eslint-config-prettier</code></p>\n<div class="gatsby-highlight">\n      <pre class="language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> eslint-plugin-prettier eslint-config-prettier --save-dev\n</code></pre>\n      </div>\n<p>然后修改我们的<code class="language-text">.eslintrc.js</code></p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>\n  <span class="token string">"extends"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"plugin:prettier/recommended"</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>然后重新执行上方配置的第二部就可以看到结果了。</p>\n<p><strong>2.</strong>    集成Jest做unit test。为什么这里也会抽出单独讲呢，理论上我们只需在配置中加段<code class="language-text">npm run unit</code>就行了，但是运行时候会发现Jest会提升没有找到测试文件的情况。此时我们需要修改我们的npm script，给jest cli添加一个<code class="language-text">--findRelatedTests</code>的参数。官网对这参数的解释是<strong>Useful for pre-commit hook integration to run the minimal amount of tests necessary.</strong> ，看起来是为pre-commit提供的特殊命令，but why🤷🏼‍</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token string">"script"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"unit"</span><span class="token punctuation">:</span> <span class="token string">"jest --config test/jest.conf.js --findRelatedTests"</span><span class="token punctuation">,</span>\n    <span class="token string">"lint"</span><span class="token punctuation">:</span> <span class="token string">"eslint --fix --ext .js,.vue"</span><span class="token punctuation">,</span>\n    <span class="token string">"precommit"</span><span class="token punctuation">:</span> <span class="token string">"lint-staged"</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token string">"lint-staged"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"*.{js|vue}"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token string">"npm run lint"</span><span class="token punctuation">,</span>\n      <span class="token string">"git add"</span><span class="token punctuation">,</span>\n      <span class="token string">"npm run unit"</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<h1>Last</h1>\n<p>参照上面几步，便很容易的实现提交前验证，想整合打包等功能也十分简单，只需要在<code class="language-text">lint-stage</code>中添加<code class="language-text">npm run *</code>或者集成其他命令。我们也可以看到lint-stage可以通过<code class="language-text">glob</code>的语法区分文件类型执行对应的script，大家可以自由发挥实现一下自动部署。</p>\n<h2>相关文档</h2>\n<ul>\n<li><a href="https://prettier.io/docs/en/eslint.html">prettier- Integrating with ESLint</a></li>\n<li><a href="https://github.com/typicode/husky/tree/master">Husky</a></li>\n<li><a href="https://www.npmjs.com/package/lint-staged">lint-stage</a></li>\n<li><a href="https://facebook.github.io/jest/docs/en/cli.html#findrelatedtests-spaceseparatedlistofsourcefiles">Jest Cli Options</a></li>\n</ul>',htmlExcerpt:"<p>作为一个程序员，想必每个都有自己的编码风格。有风格虽好，但这问题令很多项目管理者头疼，不一样的代码风格及缩进，必会降低代码可读性，从而间接降低效率。但是这个问题都难不到我们伟大的程序员，很多如eslint，prettier等库的出现帮我们去解决问题。很多cli在生成初始项目时都会给我们加上eslint、csslint等，这不就能解决我们的问题了吗？too young too simple，每保存一次就弹出一个错误，还是一大堆英文，估计大部分人心里就默默一句what the fuck is that了，从而就导致我们嘴上虽很强硬的说着要规范我们的代码风格，身体却很诚实地默默把各种lint的配置关掉🤷🏼‍。\n所以在这篇文章里，会给大家提供一些好用的方法，使各位重拾定规范时候的激情。</p>\n<h1>something useful</h1>\n<ol>\n<li>使用<code>eslint --fix</code>格式化文件\n<strong>eslint</strong>虽好，但是对规范还没适应的同学却是一个难题，每写一遍都弹个黑白屏出来，特别英文不好的，估计半天都不知道哪里出问题，这样子下来估计半天没写几行代码。这时候其实我们可以贴心地把配置项注释掉，只有提交前跑一下<code>eslint --fix</code>这个命令就好了，大部分代码都会根据规范格式化掉。</li>\n</ol>\n"}},{node:{frontmatter:{title:"10个console的高级使用方法",date:"2018-03-19",category:["javascript"],tags:null,path:"/post/10tips-for-console"},excerpt:"\n> 原文译自[10 Tips for Javascript Debugging Like a PRO with Console](https://medium.com/appsflyer/10-tips-for-javascript-debugging-like-a-pro-with-console-7140027eb5f6) - Yotam Kadishay\n\n在日常开发里，我们经常需要使用`console`调试我们的代码，但是使用仅仅是用来打印参数数据。在这篇文章中，将会介绍如何一些`console`的高级用法去更好的做调试工作和定位问题。\n\n我们都知道`console`的几个常用的方法\n\n```javascript\nconsole.log('hello world'); // 打印信息或者数据\nconsole.info(‘Something happened…’); // 和console log一样\nconsole.warn(‘Something strange happened…’); // 打印警告信息\nconsole.error(‘Something horrible happened…’); // 打印错误信息\n```\n\n除这些简单的使用外，下面几个`console`的用法希望能帮助你更好的调试你的应用。\n\n",headings:[{depth:1,value:"Tip #1 console.trace()"},{depth:1,value:"Tip #2 console.time() && console.timeEnd()"},{depth:1,value:"Tip #3 console.memory()"},{depth:1,value:"Tip #4 console.profile(‘profileName’) & console.profileEnd(‘profileName’)"},{depth:1,value:'Tip #5 console.count("STUFF I COUNT")'},{depth:1,value:"Tip #6 console.assert(false, “Log me!”)"},{depth:1,value:"Tip  #7 console.group(‘group’) & console.groupEnd(‘group’)"},{depth:1,value:"Tip #8 字符串替换"},{depth:1,value:"Tip #9 console.clear()"},{depth:1,value:"Tip #10 console.table()"}],html:'<blockquote>\n<p>原文译自<a href="https://medium.com/appsflyer/10-tips-for-javascript-debugging-like-a-pro-with-console-7140027eb5f6">10 Tips for Javascript Debugging Like a PRO with Console</a> - Yotam Kadishay</p>\n</blockquote>\n<p>在日常开发里，我们经常需要使用<code class="language-text">console</code>调试我们的代码，但是使用仅仅是用来打印参数数据。在这篇文章中，将会介绍如何一些<code class="language-text">console</code>的高级用法去更好的做调试工作和定位问题。</p>\n<p>我们都知道<code class="language-text">console</code>的几个常用的方法</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'hello world\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印信息或者数据</span>\nconsole<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>‘Something happened…’<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 和console log一样</span>\nconsole<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>‘Something strange happened…’<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印警告信息</span>\nconsole<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>‘Something horrible happened…’<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印错误信息</span>\n</code></pre>\n      </div>\n<p>除这些简单的使用外，下面几个<code class="language-text">console</code>的用法希望能帮助你更好的调试你的应用。</p>\n<!-- more -->\n<h1>Tip #1 console.trace()</h1>\n<p>如果你想知道日志的函数执行位置，使用<code class="language-text">console.trace()</code>可以打印栈堆跟踪信息。</p>\n<p><img src="http://kiit-1253813979.file.myqcloud.com/10tips-for-console/trace.png" alt="trace"></p>\n<h1>Tip #2 console.time() &#x26;&#x26; console.timeEnd()</h1>\n<p>如果你想知道某段程序的执行时间，可以使用<code class="language-text">console.time()</code>和<code class="language-text">console.timeEnd()</code>打印时间间隔。</p>\n<p><img src="http://kiit-1253813979.file.myqcloud.com/10tips-for-console/time.png" alt="time"></p>\n<h1>Tip #3 console.memory()</h1>\n<p>如果遇到一个相当棘手的性能问题，或者在寻找一个内存泄露的位置，可以尝试使用<code class="language-text">console.memory(// property, not a function)</code>查看栈大小信息。\n<img src="http://kiit-1253813979.file.myqcloud.com/10tips-for-console/memory.png" alt="memory"></p>\n<h1>Tip #4 console.profile(‘profileName’) &#x26; console.profileEnd(‘profileName’)</h1>\n<p>这个不是标准里面的方法，但是浏览器支持比较广泛。你可以使用这两个方法让浏览器的性能面板记录start至end的性能数据。使用这两个函数，能够更精准地定位你想要获取的数据。</p>\n<h1>Tip #5 console.count("STUFF I COUNT")</h1>\n<p>在一些经常重复调用的代码中，使用<code class="language-text">console.count()</code>可以记录该函数的执行次数。\n<img src="http://kiit-1253813979.file.myqcloud.com/10tips-for-console/count.png" alt="count"></p>\n<h1>Tip #6 console.assert(false, “Log me!”)</h1>\n<p>当需要条件判断打印日志时候，可以使用<code class="language-text">console.assert(condition, msg)</code>代替if-else。当<code class="language-text">condition</code> 为false的时候就会打印出信息。\n⚠️在Node.js中使用会抛出断言错误。</p>\n<p><img src="http://kiit-1253813979.file.myqcloud.com/10tips-for-console/assert.png" alt="assert"></p>\n<h1>Tip  #7 console.group(‘group’) &#x26; console.groupEnd(‘group’)</h1>\n<p>在一些写很多<code class="language-text">console.log()</code>的情况下，你可能需要将日志分组。这时候就可以使用<code class="language-text">console.group(name)</code> 去将日志分组，使用这个函数后，日志就会按层级打印。使用<code class="language-text">console.groupEnd()</code>就能结束掉当前分组，在同级重新新建一个分组。</p>\n<p><img src="http://kiit-1253813979.file.myqcloud.com/10tips-for-console/group.png" alt="group"></p>\n<h1>Tip #8 字符串替换</h1>\n<p>使用<code class="language-text">console</code>的时候可以使用字符串替换去合并变量，引用类型有下面几个<strong>(%s = string, %i = integer, %o = object, %f = float)</strong></p>\n<p><img src="http://kiit-1253813979.file.myqcloud.com/10tips-for-console/substitutions.png" alt="substitutions"></p>\n<h1>Tip #9 console.clear()</h1>\n<p>当代码里面很多<code class="language-text">console</code>的时候，你可能会需要<code class="language-text">console.clear()</code>清理一下前面的log</p>\n<p><img src="http://kiit-1253813979.file.myqcloud.com/10tips-for-console/clear.png" alt="clear"></p>\n<h1>Tip #10 console.table()</h1>\n<p>好东西留到最后。使用<code class="language-text">console.table()</code>，可以把对象打印成一个好看的表格。</p>\n<p><img src="http://kiit-1253813979.file.myqcloud.com/10tips-for-console/table.png" alt="table"></p>\n<p>希望这几个能让你平时的调试工作能更高效和有趣。</p>',htmlExcerpt:'<blockquote>\n<p>原文译自<a href="https://medium.com/appsflyer/10-tips-for-javascript-debugging-like-a-pro-with-console-7140027eb5f6">10 Tips for Javascript Debugging Like a PRO with Console</a> - Yotam Kadishay</p>\n</blockquote>\n<p>在日常开发里，我们经常需要使用<code>console</code>调试我们的代码，但是使用仅仅是用来打印参数数据。在这篇文章中，将会介绍如何一些<code>console</code>的高级用法去更好的做调试工作和定位问题。</p>\n<p>我们都知道<code>console</code>的几个常用的方法</p>\n<pre><code class="language-javascript">console.log(\'hello world\'); // 打印信息或者数据\nconsole.info(‘Something happened…’); // 和console log一样\nconsole.warn(‘Something strange happened…’); // 打印警告信息\nconsole.error(‘Something horrible happened…’); // 打印错误信息\n</code></pre>\n<p>除这些简单的使用外，下面几个<code>console</code>的用法希望能帮助你更好的调试你的应用。</p>\n'}},{node:{frontmatter:{title:"年底项目复盘",date:"2018-01-23",category:["工作"],tags:["work","vue","webpack"],path:"/post/2017-review"},excerpt:"\n这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。\n\n# 项目构建\n项目创建是使用vue-cli创建的，模版则是使用我自己维护的[vue-mpa](https://github.com/kitwon/vue-mpa)多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。\n\n",headings:[{depth:1,value:"项目构建"},{depth:2,value:"代码分割"},{depth:2,value:"代码风格及限制"},{depth:1,value:"开发阶段"},{depth:2,value:"组件化"},{depth:2,value:"动态接口地址"},{depth:2,value:"测试"},{depth:1,value:"SSR"},{depth:1,value:"总结"}],html:'<p>这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。</p>\n<h1>项目构建</h1>\n<p>项目创建是使用vue-cli创建的，模版则是使用我自己维护的<a href="https://github.com/kitwon/vue-mpa">vue-mpa</a>多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。</p>\n<!-- more -->\n<h2>代码分割</h2>\n<p>SPA一个比较重要的点就是如何做代码分割了。代码分割涉及到几个方面：</p>\n<ol>\n<li><a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html">路由分割</a>官方已经有很好的解决方案了。除文档基本说明外，还使用了<a href="https://doc.webpack-china.org/api/module-methods/#import-"><code class="language-text">webpackChunkName</code></a>对组件进行模块合并，减少文件请求。</li>\n<li>一些比较大的库例如<code class="language-text">momentjs</code>、<code class="language-text">lodash</code>代码提取。虽然<code class="language-text">webpack</code>里面提供了<code class="language-text">commonChunkPlugin</code>，但是这个插件只对入口文件进行分析和代码提取，而组件里面的一些库则使用了<a href="https://github.com/asfktz/autodll-webpack-plugin">autodll-webpack-plugin</a>，对一些依赖库进行提取和合并操作，并配合<code class="language-text">html-webpack-plugin</code>配合自动注入，生成页面模板。</li>\n</ol>\n<p>另外，引入了<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">BundleAnalyzerPlugin</a>，对module进行图形化的分析。进行各种优化后，<code class="language-text">vendor</code>和入口文件维持在600k左右，gzip后在200k左右，其他模块gzip后基本在<strong>20-50kb</strong>左右。</p>\n<h2>代码风格及限制</h2>\n<p>由于项目使用webpack和node构建，所以可以使用<code class="language-text">eslint</code>等工具去做提交前代码规范检查，另外还使用了<code class="language-text">editorconfig</code>和<a href="https://github.com/prettier/prettier"><code class="language-text">prettier</code></a>去编辑器的设置和统一代码格式化。另外提一下，<a href="https://github.com/prettier/prettier"><code class="language-text">prettier</code></a>可以通过配置项统一多种代码的格式化，因为在node端运行，所以可以做提交前的代码格式化。\n在各种工具配合下，基本可以做到代码风格的统一。</p>\n<p>此外，css方面没有使用csslint，但是普及了一下<a href="http://getbem.com/"><strong><code class="language-text">BEM</code></strong></a>，样式方面的统一情况也收到不错的成效。</p>\n<h1>开发阶段</h1>\n<p>vue在开发时候的好处就体现出来了，没写过项目的同事基本都能把页面写出来，但是对于一些参数传递、父子组件相互调用会需要一点时间去熟悉。但是在开发流程中基本没有出现什么断链的情况。</p>\n<h2>组件化</h2>\n<p>在公司期间接触过几个项目，项目结构都比较凌乱，并没有把组件化的优势发挥出来，很多页面都是重新写几遍。所以这项目开始做之前，就普及了一下react生态圈里面的几个组件概念。</p>\n<ol>\n<li><strong>container component(接入型组件)</strong>。负责主要业务逻辑，组装数据，提供业务方法。</li>\n<li><strong>exhibition component(展示型组件)</strong>。负责数据展示工作，大部分是业务组件，数据进，页面出这样，没有复杂功能。</li>\n<li><strong>interactive component(交互型组件)</strong>。复用性比较强的组件，如<code class="language-text">dialog</code>、<code class="language-text">toast</code>等组件。</li>\n<li><strong>functional component(功能型组件)</strong>。这种组件一般都是作为一种扩展，抽象机制存在，没有渲染动作，例如vue中的<code class="language-text">router-view</code>，<code class="language-text">transition</code>等。</li>\n</ol>\n<p>了解大概组成后，一般都会把组件拆分得比较细，基本组件代码维持在<strong>300行代码</strong>左右，这样做得好处就是，业务变动时候需要改动的地方就比较少，但是组件对每个模块的影响相对的就变大了，但是这个可以通过<strong>测试</strong>去解决的。</p>\n<h2>动态接口地址</h2>\n<p>项目中接口跟静态资源会动态改变，所以需要取后台返回的值去拼接，页面静态资源可以自己写一个模板然后去拼接，接口可以取页面的变量，但是打包到项目的时候，发现路由分割的代码资源地址不对，由于代码是动态分割的，所以地址应该是取<code class="language-text">config</code>里面的资源地址，所以导致加载失败。\n通过webpack文档跟stackoverflow里面相似案例，可以在动态引入js之前加入一个<a href="https://webpack.js.org/api/module-variables/#__webpack_public_path__-webpack-specific-"><code class="language-text">__webpack_public_path__</code></a>配置项，动态获取异步模块的地址。具体代码如下：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">===</span> <span class="token string">\'production\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// variables就是动态的地址</span>\n  __webpack_public_path__ <span class="token operator">=</span> variables <span class="token operator">+</span> <span class="token string">\'/\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<h2>测试</h2>\n<p>由于前期比较急，单元测试到了中后期才加上，直接导致了单元测试的覆盖率不够，正常情况下应该一写完代码就马上加上测试。测试这些前期费点时间，后期获益良多的工作，项目、团队越大就越能体现测试的重要性了。\n现在是使用<a href="https://facebook.github.io/jest/">Jest</a> + <a href="https://eddyerburgh.gitbooks.io/avoriaz/content/">Avariaz</a>的组合去做测试工作，后期会切换为<code class="language-text">Jest</code> + 官方提供的<a href="https://vue-test-utils.vuejs.org/zh-cn/">vue-test-utils</a>，两个<code class="language-text">API</code>相似，切换代价不大。</p>\n<h1>SSR</h1>\n<p>项目没有这部分的需求，就自己在有空时间折腾了一下，照着官方的SSR文档搭了出来，不过用<a href="http://koajs.com/"><code class="language-text">koa</code></a>代替了express（await、async写起来更爽一点）。直出的速度果然是不一样啊，不过也存在几个暂时还没空看的问题。</p>\n<ol>\n<li>按需直出页面设置，比如我需要A页面直出，B页面不直出，这操作还没找到怎么配置。</li>\n<li><code class="language-text">Route</code>函数式的跳转无效，比如按钮需要动态去定义跳转方式的，绑定了函数，但是SSR处理后点击无效。</li>\n<li>服务器性能测试。由于node是单线程的，没做过对应的项目，不知道流量大的时候怎么处理，有机会要了解下。</li>\n</ol>\n<h1>总结</h1>\n<p>项目进行过程除了上面动态绑定接口地址，开发过程还是比较顺利的，不过还有几个需要改进的地方</p>\n<ol>\n<li>虽然有做code review，但是大部分都是自己改进，可以多留点问题和提出多点意见给对<code class="language-text">vue</code>或者项目其他模块还不是很熟悉的同事去学习，共同进步。</li>\n<li>项目启动前对业务的了解不够清楚，导致后期才介入<code class="language-text">vuex</code>去改进一些模块，做了无用功。</li>\n<li>项目启动前和设计沟通不够，导致后期图标没有使用到<code class="language-text">iconfont</code>。不过后面也配合用按<code class="language-text">BE(Block-Modify)</code>的方式命名图标，写了个脚本去自动生成less文件。</li>\n</ol>',
htmlExcerpt:'<p>这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。</p>\n<h1>项目构建</h1>\n<p>项目创建是使用vue-cli创建的，模版则是使用我自己维护的<a href="https://github.com/kitwon/vue-mpa">vue-mpa</a>多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。</p>\n'}},{node:{frontmatter:{title:"构建60fps-web-app",date:"2017-09-13",category:["前端"],tags:["chrome","develop tool","javascript"],path:"/post/60fps-web-app"},excerpt:"\n> 这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。\n\n----\n\n> 现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的[render performance](https://developers.google.com/web/fundamentals/performance/rendering/)对前端渲染优化有了一个新的认识。\n\n# 几个重要概念\n## 60fps与设备刷新率\n目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。\n\n其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\n\n",headings:[{depth:1,value:"几个重要概念"},{depth:2,value:"60fps与设备刷新率"},{depth:2,value:"pixel pipeline"},{depth:1,value:"关键渲染行为"},{depth:2,value:"触发layout、paint的关键操作"},{depth:1,value:"优化程序"},{depth:2,value:"performance panel"},{depth:2,value:"javascript"},{depth:2,value:"style & layout"},{depth:2,value:"paint & composite"},{depth:3,value:"怎么看到网页的分层"},{depth:3,value:"怎么生成层"}],html:'<blockquote>\n<p>这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的<a href="https://developers.google.com/web/fundamentals/performance/rendering/">render performance</a>对前端渲染优化有了一个新的认识。</p>\n</blockquote>\n<h1>几个重要概念</h1>\n<h2>60fps与设备刷新率</h2>\n<p>目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。</p>\n<p>其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。</p>\n<!-- more -->\n<h2>pixel pipeline</h2>\n<p>影响浏览器渲染有很多因素，但是下面这5个关键的地方是我们可以控制的，也是像素至屏幕管道中关键的地方。\n<img src="http://kiit-1253813979.cosgz.myqcloud.com/%25E6%259E%2584%25E5%25BB%25BA60fps-web-app/pixel-pipline.jpg" alt="pixel pipeline"></p>\n<ul>\n<li>Javascript。 js中的动画效果和一些dom操作。</li>\n<li>样式计算(style)。 css匹配器的计算过程。例如<code class="language-text">.nav__item &gt; .slot</code>。</li>\n<li>布局(layout)。dom元素应用了规则之后，浏览器就会对其进行大小及位置的计算，这时候就会触发布局，而布局由于改变dom大小及位置，所以对其他元素也会造成影响。</li>\n<li>绘制(paint)。绘制就是填充像素的过程。大部分像素相关如文字、图片、阴影等都会触发绘制。绘制一般在层(layer)上面完成。</li>\n<li>合成。层的概念一般都出现在设计上面，但是浏览器中也有层的概念，所以有时候我们一些错误的操作或者属性都会使层的渲染顺序出现错误。</li>\n</ul>\n<h1>关键渲染行为</h1>\n<p>从服务器返回一个html开始，可以分为以下几步(这里英文的过程分别对应开发工具中<strong>performance</strong>面板的表示</p>\n<ol>\n<li>解析html，生成dom树，这里显示为<strong>Parser Html</strong></li>\n<li>然后根据页面的样式，将dom和css进行结合，此过程为<strong>Recalculate Style</strong></li>\n<li>最后就生成渲染树，<code class="language-text">display: none</code>或<code class="language-text">:after</code>等伪元素都不会出现在渲染树上</li>\n<li>浏览器知道哪个css规则应用哪个dom元素后，就开始计算布局(计算元素占用多少空间，出现在什么位置)，此过程是<strong>layout</strong></li>\n<li>确定位置后浏览器就开始对dom的样式及内容进行渲染，称为<strong>paint</strong></li>\n<li>dom渲染的时候，可能还会有图片资源，浏览器这时候就会将这些内容解码成内存，称为<strong>Image Decode + Resize</strong></li>\n<li><strong>paint</strong>开始的操作都是在同一个层面中执行，但其实浏览器还会创建多个图层，并且对这些图层进行单独的绘制，这个过程称为<strong>Composite Layers</strong></li>\n<li>这些操作在CPU中进行，执行完后上传到GPU中，最后显示到屏幕上</li>\n</ol>\n<h2>触发layout、paint的关键操作</h2>\n<p>我们知道一帧中就包含了上面的操作，但并不是所有改变网页外观操作都会触发上面的行为。回到<strong>pipeline</strong>，看看什么操作会分别触发什么行为。(下面会用数字代表对应图片上的位置)\n<img src="http://kiit-1253813979.cosgz.myqcloud.com/%25E6%259E%2584%25E5%25BB%25BA60fps-web-app/pixel-pipline.jpg" alt="pixel pipeline"></p>\n<ul>\n<li>第一种，通过css或者js进行了外观的更改(1)，这时浏览器就要重新计算元素的样式(2)，如果还更改了布局属性，元素的大小改变，必定会影响其他元素的位置，这时就要重新布局(3)，然后受影响的区域就需要重新绘制(4)，最后将所有东西合成在一起(5)。</li>\n<li>第二种，仅改变绘制属性(1)，例如背景、文字颜色、阴影等(2)，由于这些操作没有改变布局，所以会跳过(3)，直接进行(4)(5)的操作。</li>\n<li>第三种，通过改变样式(1)(2)，但是样式并没有对(3)(4)进行改动，所以会直接执行(5)的操作，例如<code class="language-text">cursor: pointer</code>等属性。</li>\n</ul>\n<h1>优化程序</h1>\n<p>通过上面的介绍，我们知道影响帧数的主要是上面的几个渲染行为，但是要怎么知道是什么更改操作使帧数下降，就需要<strong>develop tool</strong>的帮助。</p>\n<h2>performance panel</h2>\n<p>性能分析面板是chrome中开发者工具自带的一个功能，我们能在上面看到录制实践中，<strong>pipeline</strong>的具体运行情况。\n<img src="http://kiit-1253813979.cosgz.myqcloud.com/%25E6%259E%2584%25E5%25BB%25BA60fps-web-app/performance.jpg" alt="performance panel"></p>\n<ol>\n<li>在(1)<strong>overview</strong>中，我们可以看到程序中大概的性能状况，fps、cpu、网络使用情况，还有对应的截图。一般情况，看到<strong>cpu</strong>部分一大片一大片的颜色就证明你的程序需要优化了。</li>\n<li>(2)中的<strong>main</strong>部分，可以看到主进程中的活动，所有时间点执行的操作及渲染行为都能在这个部分找到，主要的性能分析也是围绕这里展开，一半看到<strong>飙红</strong>的地方就证明那里是要下手的地方。</li>\n<li>(3)中则是对某个浏览器行为进行统计分析，能看到详细调用树和渲染层，找代码和<strong>layer tree</strong>都是(3)中。</li>\n</ol>\n<p>由于网上教程大部分的教程都用较低的版本，所以很多教程中的面板都找不到，比如<strong>painter</strong>就需要开启<strong>advance paint insturmentation</strong>，所以教程中找不到就需要google一下或者看下<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/">goole的官方教程</a>。具体的使用方法就不赘述，反正看见<strong>飙红就是要优化了</strong>。</p>\n<p>有工具之后，就可以针对具体的东西进行优化了，根据<strong>pipeline</strong>，我们其实可以知道优化点是哪几个了，javascript, style &#x26; layout, paint &#x26; composite。下面一个个分析下优化点。</p>\n<h2>javascript</h2>\n<p>由于javascript在<strong>pipeline</strong>中，所以在渲染过程中执行javascript代码必定会造成卡顿，俗称的帧丢失。在渲染过程中需要执行js代码的操作最常见的例子就是<strong>用js去操作动画</strong>，还有<strong>在浏览过程中做一些数据拉取及组装数据的操作</strong>。所以针对这些问题，我们需要使用一些新的api去改进我们的app。</p>\n<p><strong>1.使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame</a>代替setTimeout和setInterval去执行动画。</strong>\n一开始我们就说到帧数的概念，一个app想要不卡顿，必须达到60fps每秒的速度才能保证，减去浏览器自己的行为，每帧留给javascript执行的时间大概剩下10ms左右。或许不断调用setTimeout或者setIntervarl可以自定义函数执行时间，但是由于javascript是单线程，活着其他堆在栈中的代码会突然插入，导致函数执行中断。这时候raf就能解决这个问题了。具体使用方法可以自行查看<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">文档</a>。</p>\n<p><strong>2.使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">web worker</a>去进行一些多线程的操作。</strong>\n使用web worker后，浏览器会另起一个线程，所以就不会妨碍主线程中的pipeline了。我们可以在一些加载列表的场景中使用，比如用户在浏览，但是你想用这些时间去load一些数据回来，然后渲染页面，这时候worker会执行ajax，也不会妨碍到主线程执行。</p>\n<h2>style &#x26; layout</h2>\n<p>样式和布局也是帧里面的一部分，复杂的选择器或者某些js操作触发了强制布局，都会使性能下降，下面可以用这几个方法避免这些问题。\n<strong>1.操作数量多的dom时，减少选择器的复杂度。</strong>\n通常做项目的时候，我们一般都是操作少数的dom，但是某些特殊情况下可能要操作上千个dom(当然这不太现实)，这时候保持选择器的简洁就相当重要了，一个多级选择器计算时间足以超出10ms，所以，保持css中选择器的简洁是十分重要的。</p>\n<p><strong>2.避免布局反复FSL</strong>\n什么是布局反复，一帧的流程应该是按照<strong>pipeline</strong>的执行顺序去执行的，但是某些错误的javascript读写操作就很容易造成布局反复，如下代码</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> elms <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementByTagName</span><span class="token punctuation">(</span><span class="token string">\'p\'</span><span class="token punctuation">)</span>\n<span class="token keyword">var</span> block <span class="token operator">=</span> ducoment<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'block\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elms<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> height <span class="token operator">=</span> block<span class="token punctuation">.</span>offsetHeight\n  elms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> height\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>在这段代码中，由于属性的读取操作<code class="language-text">offsetHeight</code>会触发layout布局，然后下面设置高度的属性会触发style修改样式，两个在一个循环中就会造成布局反复，从而造成性能的损失。在<strong>performance panel</strong>中，缩小范围，如果看见layout中有红色的小三角，那么就是触发了FSL了，点进详情就能看到代码运行的地方在哪里了。</p>\n<h2>paint &#x26; composite</h2>\n<p>绘制和合成是一个相对比较复杂的流程，大多数样式更改都会触发这个过程，但是如果是大批量的元素或者一个复杂的动画绘制，在主线程中必定会造成性能问题。在这里就引入图层这个概念，由于浏览器的呈现器不在主线程中，所以图层会单独绘制，然后再和树进行合成。但如果层多的话，合成时间也会加长，所以使用层和限制层的数量也是需要注意的问题。</p>\n<h3>怎么看到网页的分层</h3>\n<p>具体看<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#paint-profiler">教程</a>\n进去搜<strong>View paint profiler</strong></p>\n<ol>\n<li>Enable advanced paint instrumentation.(这个选项在上图面板一，点击右上角的小齿轮)</li>\n<li>Select a Paint event in the Main section.(教程里面看图)</li>\n</ol>\n<h3>怎么生成层</h3>\n<ol>\n<li>社区中比较常见的<code class="language-text">transform: translate3d(0, 0, 0)</code>、<code class="language-text">transform: translateZ(0)</code>。虽然会有一些性能的浪费，但是好像是现在比较好的解决方法了。</li>\n<li>使用css新属性<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change"><code class="language-text">will-change: transform</code></a>，浏览器支持度一般般。</li>\n</ol>\n<p>能够看完整篇的同学估计耐性都不错。通过一些基本的介绍，基本可以了解怎么查看和修复app的渲染性能问题了，不过使用现代的开发框架如<strong>react</strong>、<strong>vue</strong>、<strong>angular</strong>都很少会出现<strong>FSL</strong>的问题了，因为很大部分的<strong>layout</strong>动作都直接被<code class="language-text">rerender</code>，但是一些比较旧的用dom操作些的APP或多或少都会出现上面的问题。大家可以看看自己的APP有没有达到要求。不说了，我去改代码了。</p>',htmlExcerpt:'<blockquote>\n<p>这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的<a href="https://developers.google.com/web/fundamentals/performance/rendering/">render performance</a>对前端渲染优化有了一个新的认识。</p>\n</blockquote>\n<h1>几个重要概念</h1>\n<h2>60fps与设备刷新率</h2>\n<p>目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。</p>\n<p>其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。</p>\n'}},{node:{frontmatter:{title:"在vue项目中使用jest进行单元测试",date:"2017-08-18",category:["前端工具"],tags:["unit test","vue","javascript"],path:"/post/vue-jest-test"},excerpt:"\n在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下[jest](http://facebook.github.io/jest/)，这是一个[Facebook OpenSource](https://code.facebook.com/projects/)的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持**快照测试**(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。\n\n# 配置\n首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析'.vue'文件的)。\n```bash\n$ npm install jest jest-vue-preprocessor --save-dev\n\n# or use yarn\n$ yarn add jest jest-vue-preprocessor --save\n```\n\n",headings:[{depth:1,value:"配置"},{depth:2,value:"package.json"},{depth:1,value:"跑个测试"},{depth:1,value:"last"}],html:'<p>在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下<a href="http://facebook.github.io/jest/">jest</a>，这是一个<a href="https://code.facebook.com/projects/">Facebook OpenSource</a>的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持<strong>快照测试</strong>(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。</p>\n<h1>配置</h1>\n<p>首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析\'.vue\'文件的)。</p>\n<div class="gatsby-highlight">\n      <pre class="language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> jest jest-vue-preprocessor --save-dev\n\n<span class="token comment"># or use yarn</span>\n$ yarn add jest jest-vue-preprocessor --save\n</code></pre>\n      </div>\n<!-- more -->\n<h2>package.json</h2>\n<p>下面的配置都在<strong>package.json</strong>文件中配置。</p>\n<p>在文件最底部添加下面代码</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token string">"jest"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 配置文件拓展名</span>\n    <span class="token string">"moduleFileExtensions"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token string">"js"</span><span class="token punctuation">,</span>\n      <span class="token string">"vue"</span>\n    <span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token comment">// 匹配webpack中配置的alias</span>\n    <span class="token string">"moduleNameMapper"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      <span class="token string">"^vue$"</span><span class="token punctuation">:</span> <span class="token string">"vue/dist/vue.common.js"</span><span class="token punctuation">,</span>\n      <span class="token string">"^@(.*)$"</span><span class="token punctuation">:</span> <span class="token string">"&lt;rootDir>/src$1"</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token comment">// 编译工具</span>\n    <span class="token string">"transform"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      <span class="token string">".*\\\\.(vue)$"</span><span class="token punctuation">:</span> <span class="token string">"&lt;rootDir>/node_modules/jest-vue-preprocessor"</span><span class="token punctuation">,</span>\n      <span class="token string">".*"</span><span class="token punctuation">:</span> <span class="token string">"babel-jest"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<!-- more -->\n<p>然后在上面<code class="language-text">script</code>中添加一条新的命令</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token string">"./node_modules/.bin/jest"</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>然后就配置好了，很快，很舒服。</p>\n<h1>跑个测试</h1>\n<p>首先，我有个vue组件cell，一个简单的列表item组件，代码如下</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code class="language-html"><span class="token comment">&lt;!-- vue template --></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ui-cell<span class="token punctuation">"</span></span> <span class="token attr-name">:href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>href<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ui-cell-wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>icon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>iconClass<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>iconClass<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ui-cell-title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ui-cell-text<span class="token punctuation">"</span></span> <span class="token attr-name">v-text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ui-cell-label<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>label<span class="token punctuation">"</span></span> <span class="token attr-name">v-text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>label<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ui-cell-value<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ <span class="token punctuation">\'</span>isLink<span class="token punctuation">\'</span>: isLink }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span>\n           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>icon-arrow-right<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isLink<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  name<span class="token punctuation">:</span> <span class="token string">\'ui-cell\'</span><span class="token punctuation">,</span>\n  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    to<span class="token punctuation">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">]</span><span class="token punctuation">,</span>\n    iconClass<span class="token punctuation">:</span> String<span class="token punctuation">,</span>\n    title<span class="token punctuation">:</span> String<span class="token punctuation">,</span>\n    label<span class="token punctuation">:</span> String<span class="token punctuation">,</span>\n    value<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">\'\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token function">href</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>to <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>added <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> resolve <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">)</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">.</span>matched<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          <span class="token keyword">this</span><span class="token punctuation">.</span>added <span class="token operator">=</span> <span class="token boolean">true</span>\n          <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">)</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token keyword">return</span> resolve<span class="token punctuation">.</span>path\n      <span class="token punctuation">}</span>\n\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">isLink</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>to\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token function">handleClick</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>href<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>然后编写测试文件</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token keyword">import</span> Cell <span class="token keyword">from</span> <span class="token string">\'@/components/cell\'</span>\n<span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">\'vue-router\'</span>\n\nVue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token punctuation">{</span>\n    path<span class="token punctuation">:</span> <span class="token string">\'/foo\'</span><span class="token punctuation">,</span>\n    component<span class="token punctuation">:</span> Cell\n  <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> mockFn <span class="token operator">=</span> jest<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nCell<span class="token punctuation">.</span>methods <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">handleClick</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    mockFn<span class="token punctuation">.</span><span class="token function">mockReturnValue</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> Constructor <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>Cell<span class="token punctuation">)</span>\n<span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Constructor</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  propsData<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    title<span class="token punctuation">:</span> <span class="token string">\'cell1\'</span><span class="token punctuation">,</span>\n    value<span class="token punctuation">:</span> <span class="token string">\'value1\'</span><span class="token punctuation">,</span>\n    label<span class="token punctuation">:</span> <span class="token string">\'label1\'</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> vm2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Constructor</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  router<span class="token punctuation">,</span>\n  propsData<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    title<span class="token punctuation">:</span> <span class="token string">\'cell2\'</span><span class="token punctuation">,</span>\n    value<span class="token punctuation">:</span> <span class="token string">\'value2\'</span><span class="token punctuation">,</span>\n    to<span class="token punctuation">:</span> <span class="token string">\'/foo\'</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> vm3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Constructor</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  propsData<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    title<span class="token punctuation">:</span> <span class="token string">\'cell3\'</span><span class="token punctuation">,</span>\n    value<span class="token punctuation">:</span> <span class="token string">\'value3\'</span><span class="token punctuation">,</span>\n    iconClass<span class="token punctuation">:</span> <span class="token string">\'icon-test\'</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">\'Cell component\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token function">test</span><span class="token punctuation">(</span><span class="token string">\'render currect dom\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">expect</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toMatchSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token function">expect</span><span class="token punctuation">(</span>vm2<span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toMatchSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token function">expect</span><span class="token punctuation">(</span>vm3<span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toMatchSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  <span class="token function">test</span><span class="token punctuation">(</span><span class="token string">\'router action currectly run\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    vm2<span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      vm2<span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token function">expect</span><span class="token punctuation">(</span>vm2<span class="token punctuation">.</span>href<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>vm2<span class="token punctuation">.</span>to<span class="token punctuation">)</span>\n      <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">mockFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>然后跑一下命令</p>\n<div class="gatsby-highlight">\n      <pre class="language-bash"><code class="language-bash">$ <span class="token function">npm</span> run <span class="token function">test</span>\n\n<span class="token operator">></span> jest-test@1.0.0 <span class="token function">test</span> /Users/kit/projects/jest-test\n<span class="token operator">></span> jest\n\n PASS  test/unit/Cell.spec.js\n  Cell component\n    ✓ render currect dom <span class="token punctuation">(</span>8ms<span class="token punctuation">)</span>\n    ✓ router action currectly run <span class="token punctuation">(</span>2ms<span class="token punctuation">)</span>\n\nSnapshot Summary\n › 3 snapshots written <span class="token keyword">in</span> 1 <span class="token function">test</span> suite.\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   3 added, 3 total\nTime:        2.295\n</code></pre>\n      </div>\n<h1>last</h1>\n<p>jest给我们提供了一个便捷的测试环境，简单的几个配置项，即可完成编译，不像mocha或jasmine需要其他<code class="language-text">node module</code>配合完成测试的工作。个人认为fb还是做到了他希望的，让测试变得简单，让开发者有更多的时间去开发。至于自动化测试的好处这里就不再赘述了，有兴趣的朋友可以自行baidu、google。</p>',
htmlExcerpt:'<p>在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下<a href="http://facebook.github.io/jest/">jest</a>，这是一个<a href="https://code.facebook.com/projects/">Facebook OpenSource</a>的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持<strong>快照测试</strong>(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。</p>\n<h1>配置</h1>\n<p>首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析\'.vue\'文件的)。</p>\n<pre><code class="language-bash">$ npm install jest jest-vue-preprocessor --save-dev\n\n# or use yarn\n$ yarn add jest jest-vue-preprocessor --save\n</code></pre>\n'}}],page:1,pages:4,total:16,limit:5,next:"/blog/2"}}}});
//# sourceMappingURL=path---blog-1-4e404d8595aee38062c8.js.map