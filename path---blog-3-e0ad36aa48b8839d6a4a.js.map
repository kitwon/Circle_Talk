{"version":3,"sources":["webpack:///path---blog-3-e0ad36aa48b8839d6a4a.js","webpack:///./.cache/json/blog-3.json"],"names":["webpackJsonp","287","module","exports","data","allMarkdownRemark","edges","node","excerpt","frontmatter","title","date","category","path","pathContext","edgesLen","tagsLen","categoryLen","nodes","tags","headings","depth","value","html","htmlExcerpt","page","pages","total","limit","prev","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,mBAAqBC,QAAUC,MAAQC,QAAA,sIAAAC,aAA+JC,MAAA,6BAAAC,KAAA,aAAAC,UAAA,SAAAC,KAAA,4BAAiHN,MAAQC,QAAA,+kBAAshBC,aAAkFC,MAAA,oBAAAC,KAAA,aAAAC,UAAA,cAAAC,KAAA,+BAAgHN,MAAQC,QAAA,wfAAAC,aAAihBC,MAAA,SAAAC,KAAA,aAAAC,UAAA,MAAAC,KAAA,wBAAsFN,MAAQC,QAAA,wjBAAAC,aAAilBC,MAAA,kBAAAC,KAAA,aAAAC,UAAA,MAAAC,KAAA,0BAAiGN,MAAQC,QAAA,gfAAAC,aAAygBC,MAAA,sBAAAC,KAAA,aAAAC,UAAA,QAAAC,KAAA,0BAAuGN,MAAQC,QAAA,qjBAAAC,aAA8kBC,MAAA,mBAAAC,KAAA,aAAAC,SAAA,KAAAC,KAAA,qBAA2FN,MAAQC,QAAA,goBAA+nBC,aAA0BC,MAAA,wBAAAC,KAAA,aAAAC,SAAA,KAAAC,KAAA,oBAA+FN,MAAQC,QAAA,o8BAA27BC,aAAkCC,MAAA,iBAAAC,KAAA,aAAAC,UAAA,QAAAC,KAAA,qBAA6FN,MAAQC,QAAA,0kBAA8jBC,aAAqCC,MAAA,oBAAAC,KAAA,aAAAC,SAAA,KAAAC,KAAA,wBAA+FN,MAAQC,QAAA,iUAAAC,aAA0VC,MAAA,iBAAAC,KAAA,aAAAC,SAAA,KAAAC,KAAA,2BAA+FN,MAAQC,QAAA,6wBAAAC,aAAsyBC,MAAA,sBAAAC,KAAA,aAAAC,SAAA,KAAAC,KAAA,qBAA8FN,MAAQC,QAAA,0NAA4LC,aAAuDC,MAAA,mBAAAC,KAAA,aAAAC,UAAA,cAAAC,KAAA,sBAAsGN,MAAQC,QAAA,6rBAA2rBC,aAA2BC,MAAA,eAAAC,KAAA,aAAAC,UAAA,MAAAC,KAAA,uBAA2FN,MAAQC,QAAA,odAAAC,aAA6eC,MAAA,iBAAAC,KAAA,aAAAC,UAAA,MAAAC,KAAA,sBAA4FN,MAAQC,QAAA,62BAAAC,aAAw4BC,MAAA,mBAAAC,KAAA,aAAAC,UAAA,MAAAC,KAAA,6BAAqGN,MAAQC,QAAA,kRAAAC,aAA2SC,MAAA,kBAAAC,KAAA,aAAAC,UAAA,gBAAAC,KAAA,yBAAyGC,aAAgBC,SAAA,GAAAC,QAAA,GAAAC,YAAA,EAAAC,QAAqDX,MAAQE,aAAeC,MAAA,sBAAAC,KAAA,aAAAC,SAAA,KAAAO,KAAA,KAAAN,KAAA,kBAAsGL,QAAA,6wBAAAY,WAAqyBC,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,WAA6BD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,UAA4BD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,iBAAmCD,MAAA,EAAAC,MAAA,OAAuBC,KAAA,i4NAAorNC,YAAA,k/BAA0vCjB,MAAQE,aAAeC,MAAA,mBAAAC,KAAA,aAAAC,UAAA,cAAAO,KAAA,KAAAN,KAAA,mBAA8GL,QAAA,0NAA6LY,WAAqDC,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,SAAyBC,KAAA,yoCAAyxBC,YAAA,iRAA8pBjB,MAAQE,aAAeC,MAAA,eAAAC,KAAA,aAAAC,UAAA,MAAAO,MAAA,cAAAN,KAAA,oBAA6GL,QAAA,6rBAA4rBY,WAAyBC,MAAA,EAAAC,MAAA,kBAAoCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,eAAiCD,MAAA,EAAAC,MAAA,OAAyBD,MAAA,EAAAC,MAAA,OAAuBC,KAAA,22PAA2uOC,YAAA,uxBAA86CjB,MAAQE,aAAeC,MAAA,iBAAAC,KAAA,aAAAC,UAAA,MAAAO,KAAA,KAAAN,KAAA,mBAAoGL,QAAA;AAAAY,WAA4eC,MAAA,EAAAC,MAAA,cAAgCD,MAAA,EAAAC,MAAA,eAAiCD,MAAA,EAAAC,MAAA,iBAAqCD,MAAA,EAAAC,MAAA,SAA2BD,MAAA,EAAAC,MAAA,OAAuBC,KAAA,+qFAAkoEC,YAAA,sgBAA0kCjB,MAAQE,aAAeC,MAAA,mBAAAC,KAAA,aAAAC,UAAA,MAAAO,MAAA,iBAAAN,KAAA,0BAA0HL,QAAA,62BAAAY,WAAu4BC,MAAA,EAAAC,MAAA,kBAAoCD,MAAA,EAAAC,MAAA,YAA8BD,MAAA,EAAAC,MAAA,YAA8BD,MAAA,EAAAC,MAAA,WAA6BD,MAAA,EAAAC,MAAA,cAA8BC,KAAA,ivUAAo0TC,YAAA,q/BAA2iDC,KAAA,EAAAC,MAAA,EAAAC,MAAA,GAAAC,MAAA,EAAAC,KAAA,UAAAC,KAAA","file":"path---blog-3-e0ad36aa48b8839d6a4a.js","sourcesContent":["webpackJsonp([173394108556902],{\n\n/***/ 287:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"excerpt\":\"作为一个程序员，想必每个都有自己的编码风格。有风格虽好，但这问题令很多项目管理者头疼，不一样的代码风格及缩进，必会降低代码可读性，从而间接降低效率。但是这个问题都难不到我们伟大的程序员，很多如eslint，prettier等库的出现帮我们去解决问题。很多cli…\",\"frontmatter\":{\"title\":\"使用pre-commit实现提交前验证或自动部署代码\",\"date\":\"2018-03-29\",\"category\":[\"tools\"],\"path\":\"/post/pre-commit-hook\"}}},{\"node\":{\"excerpt\":\"\\n> 原文译自[10 Tips for Javascript Debugging Like a PRO with Console](https://medium.com/appsflyer/10-tips-for-javascript-debugging-like-a-pro-with-console-7140027eb5f6) - Yotam Kadishay\\n\\n在日常开发里，我们经常需要使用`console`调试我们的代码，但是使用仅仅是用来打印参数数据。在这篇文章中，将会介绍如何一些`console`的高级用法去更好的做调试工作和定位问题。\\n\\n我们都知道`console`的几个常用的方法\\n\\n```javascript\\nconsole.log('hello world'); // 打印信息或者数据\\nconsole.info(‘Something happened…’); // 和console log一样\\nconsole.warn(‘Something strange happened…’); // 打印警告信息\\nconsole.error(‘Something horrible happened…’); // 打印错误信息\\n```\\n\\n除这些简单的使用外，下面几个`console`的用法希望能帮助你更好的调试你的应用。\\n\\n\",\"frontmatter\":{\"title\":\"10个console的高级使用方法\",\"date\":\"2018-03-19\",\"category\":[\"javascript\"],\"path\":\"/post/10tips-for-console\"}}},{\"node\":{\"excerpt\":\"\\n这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。\\n\\n# 项目构建\\n项目创建是使用vue-cli创建的，模版则是使用我自己维护的[vue-mpa](https://github.com/kitwon/vue-mpa)多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。\\n\\n\",\"frontmatter\":{\"title\":\"年底项目复盘\",\"date\":\"2018-01-23\",\"category\":[\"工作\"],\"path\":\"/post/2017-review\"}}},{\"node\":{\"excerpt\":\"\\n> 这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。\\n\\n----\\n\\n> 现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的[render performance](https://developers.google.com/web/fundamentals/performance/rendering/)对前端渲染优化有了一个新的认识。\\n\\n# 几个重要概念\\n## 60fps与设备刷新率\\n目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。\\n\\n其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\\n\\n\",\"frontmatter\":{\"title\":\"构建60fps-web-app\",\"date\":\"2017-09-13\",\"category\":[\"前端\"],\"path\":\"/post/60fps-web-app\"}}},{\"node\":{\"excerpt\":\"\\n在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下[jest](http://facebook.github.io/jest/)，这是一个[Facebook OpenSource](https://code.facebook.com/projects/)的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持**快照测试**(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。\\n\\n# 配置\\n首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析'.vue'文件的)。\\n```shell\\n$npm install jest jest-vue-preprocessor --save-dev\\n\\n$yarn add jest jest-vue-preprocessor --save\\n```\\n\\n\",\"frontmatter\":{\"title\":\"在vue项目中使用jest进行单元测试\",\"date\":\"2017-08-18\",\"category\":[\"前端工具\"],\"path\":\"/post/vue-jest-test\"}}},{\"node\":{\"excerpt\":\"\\n# 类理论\\n类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。\\n\\n类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。**汽车**可以被看作**交通工具中的一种**，所以在软件开发时可以定义一个`Vehicle`类，`Vehicle`中包含推进器（引擎）、载人能力等方法。定义`Car`时，只要声明它继承或者拓展`Vehicle`这个基础定义就行了，其他交通工具如船、飞机也可以继承`Vehicle`。**这就是类的实例化与继承**。\\n\\n类的另外一个核心概念是**多态**，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。\\n\\njavascript中也有类中的`new`和`instanceof`，还有ES6中的`class`关键字，但这些并不是说明js中有**类**的。javascript中只是为了满足类的设计需求而提供一些类似的语法。\\n\\n## js中实现类复制(混入)\\njavascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。\\n\\n\",\"frontmatter\":{\"title\":\"深入学习javascript-类\",\"date\":\"2017-07-20\",\"category\":null,\"path\":\"/post/js-class\"}}},{\"node\":{\"excerpt\":\"\\n# 关于this\\n\\n`this`应该是javascript中一个比较复杂的机制了，在日常工作中我们可能有意无意都会使用到这个机制，但是`this`的工作机制真正了解的可能只有皮毛，通过学习这一机制，能够提高对js代码的理解和阅读能力，还有对js程序设计模式有着更深的理解。\\n\\n# this的指向\\nthis是运行时进行绑定的，而不是编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\\n\\n通过分析调用位置，就能知道this到底引用的是什么。所以，寻找调用位置就能弄清上面的问题，通过一个例子，就能很好地理解这个问题：\\n```javascript\\nfunction baz() {\\n  // 当前调用栈是 baz\\n  // 当前调用位置是全局作用域\\n\\n  console.log('baz');\\n  bar(); // bar的调用位置\\n}\\n\\nfunction bar() {\\n  // 当前的调用栈是 baz -> bar\\n  // 当前的调用位置是baz\\n\\n  console.log('bar');\\n  foo();\\n}\\n\\nfunction foo() {\\n  // 当前的调用栈是 baz -> bar -> foo\\n  // 当前的调用位置是bar\\n\\n  console.log('foo');\\n}\\n\\nbaz();\\n```\\n\\n\",\"frontmatter\":{\"title\":\"深入学习javascript - this\",\"date\":\"2017-06-27\",\"category\":null,\"path\":\"/post/js-this\"}}},{\"node\":{\"excerpt\":\"\\nwebpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。\\n\\n# 从webpack1中迁移\\n官方已经给出了详细的[迁移指南](https://webpack.js.org/guides/migrating/)，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。\\n\\n## 配置文件\\n如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。\\n\\n### `module.loaders`变成`module.rules`\\n旧的`module.loader`被`module.rules`取代，后者允许配置`loader`更多选项，具体查看文档[module.rules](https://webpack.js.org/configuration/module/#module-rules)\\n\\n```javascript\\n// ...\\nmdoule: {\\n    rules: [\\n        {\\n            test: /\\\\.css$/,\\n            use: [\\n                { loader: 'style-loader' },\\n                {\\n                    loader: 'css-loader',\\n                    options: { module: true }\\n                }\\n            ]\\n        },\\n        {\\n            test: /\\\\.jsx$/,\\n            loader: 'babel-loader',\\n            options: {\\n                // ...\\n            }\\n        }\\n    ]\\n}\\n// ...\\n```\\n\\n\",\"frontmatter\":{\"title\":\"webpack2新特性&迁移\",\"date\":\"2017-06-24\",\"category\":[\"前端工具\"],\"path\":\"/post/webpack2\"}}},{\"node\":{\"excerpt\":\"\\n# 什么是闭包\\n记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。\\n\\n> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）\\n\\n然后看个例子\\n```javascript\\nfunction foo() {\\n\\tvar a = 2;\\n\\n\\tfuntion bar() {\\n\\t\\tconsole.log(a);\\n\\t}\\n\\n\\tbar();\\n}\\n\\nfoo();\\n```\\n如果按上面第一条的定义，这里一定是生成了闭包，但是**确切的说并不是**，这里最准确的说是`bar`对`a`的引用方式是词法作用域的查找规则，而这些只是**闭包**的一部分。然后再看清晰闭包的例子\\n\\n```javascript\\nfucntion foo() {\\n\\tvar a = 2;\\n\\n\\tfunction bar() {\\n\\t\\tconsole.log(a)\\n\\t}\\n\\n\\treturn bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n```\\n\\n\",\"frontmatter\":{\"title\":\"深入学习javascript-闭包\",\"date\":\"2017-06-14\",\"category\":null,\"path\":\"/post/js-closures\"}}},{\"node\":{\"excerpt\":\"\\n之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。\\n\\n# 主要需求\\n这个demo中爬虫有3个主要模块，**URL管理器**、**下载器**、**解析器**\\n* URL管理器主要处理爬取的URL的状态。\\n* 下载器会通过**URL管理器**传送过来有效URL进行下载。\\n* 解析器会将**下载器**下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给**URL管理器**进行重复操作。\\n\\n## 入口程序\\n`spider_main`文件为程序入口，处理整个爬虫的运行逻辑\\n\\n\",\"frontmatter\":{\"title\":\"用python写一个简单爬虫\",\"date\":\"2017-06-11\",\"category\":null,\"path\":\"/post/python-crawler\"}}},{\"node\":{\"excerpt\":\"\\n# 前言\\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\\n\\n# 作用域是什么\\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\\n\\n\\n\\n## 理解作用域执行过程\\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\\n\\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\\n\\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\\n\\n\",\"frontmatter\":{\"title\":\"深入学习javascript--作用域\",\"date\":\"2017-05-31\",\"category\":null,\"path\":\"/post/js-scope\"}}},{\"node\":{\"excerpt\":\"\\n# 题目\\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现\\n\\n```javascript\\nfunction add(x) {\\n\\tvar fn = function(y) {\\n\\t\\treturn add(x + y);\\n\\t}\\n\\n\\treturn fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n```\\n\\n\",\"frontmatter\":{\"title\":\"js实现add(1)(2)(3)\",\"date\":\"2017-05-28\",\"category\":[\"javascript\"],\"path\":\"/post/add-chain\"}}},{\"node\":{\"excerpt\":\"\\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\\n\\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\\n\\n\\n\\n# 初步构建一个Promise\\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\\n```javascript\\n// 例1\\nfunction getAsyncData() {\\n\\treturn new Promise(function(resolve, reject) {\\n\\t\\tsetTimeout(function() {\\n\\t\\t\\tresolve('promise done!')\\n\\t\\t}, 1000)\\n\\t})\\n}\\n\\ngetAsyncData().then(function(result) {\\n\\tconsole.log(result);\\n}).then(function() {\\n\\tconsole.log('done too!');\\n})\\n```\\n\\n\",\"frontmatter\":{\"title\":\"Promise的简单实现\",\"date\":\"2017-05-17\",\"category\":[\"前端\"],\"path\":\"/post/js-promise\"}}},{\"node\":{\"excerpt\":\"\\n# 什么是单元-测试?\\n- 单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。\\n- 而测试，就是测试啦。\\n\\n所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。\\n\\n# 为什么要写单元测试？\\n单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。\\n\\n\",\"frontmatter\":{\"title\":\"前端单元测试&Mocha指北\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"path\":\"/post/unit-test\"}}},{\"node\":{\"excerpt\":\"\\n> 原文译自[Smashing Magazine](https://www.smashingmagazine.com/) -- [[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)\\n\\n相信很多前端都听说过或者使用过[Gulp](http://www.gulpjs.com.cn/), [Angular CLI](https://cli.angular.io/), [Cordova](https://cordova.apache.org/), [Yeoman](http://yeoman.io/)或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用`ng new <project-name>`后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。\\n\\n在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用[SendGrid Api](https://github.com/sendgrid/sendgrid-nodejs)模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令\\n\\n\",\"frontmatter\":{\"title\":\"使用nodejs写一个命令行程序\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"path\":\"/post/node-command-app\"}}},{\"node\":{\"excerpt\":\"\\n好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。\\n\\n### 小科普\\n什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！\\n\\n\",\"frontmatter\":{\"title\":\"React-todo demo\",\"date\":\"2016-03-02\",\"category\":[\"js framework\"],\"path\":\"/post/react-todo\"}}}]}},\"pathContext\":{\"edgesLen\":16,\"tagsLen\":14,\"categoryLen\":6,\"nodes\":[{\"node\":{\"frontmatter\":{\"title\":\"深入学习javascript--作用域\",\"date\":\"2017-05-31\",\"category\":null,\"tags\":null,\"path\":\"/post/js-scope\"},\"excerpt\":\"\\n# 前言\\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\\n\\n# 作用域是什么\\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\\n\\n\\n\\n## 理解作用域执行过程\\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\\n\\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\\n\\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"前言\"},{\"depth\":1,\"value\":\"作用域是什么\"},{\"depth\":2,\"value\":\"理解作用域执行过程\"},{\"depth\":3,\"value\":\"LSH和RSH查询\"},{\"depth\":2,\"value\":\"提升\"},{\"depth\":3,\"value\":\"函数优先\"},{\"depth\":2,\"value\":\"作用域嵌套\"},{\"depth\":1,\"value\":\"函数作用域\"},{\"depth\":1,\"value\":\"块作用域\"},{\"depth\":2,\"value\":\"延长作用域链(块作用域)\"},{\"depth\":1,\"value\":\"总结\"}],\"html\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。</p>\\n<ol>\\n<li>遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。</li>\\n<li>接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</li>\\n</ol>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n<!-- more -->\\n<h3>LSH和RSH查询</h3>\\n<p>定义一个变量<code>var a = 2</code>，或者执行一个简单的函数<code>console.log(2)</code>中，会同时或者单独出现<strong>LSH</strong>或者<strong>RSH</strong>查询。其实在作用域执行过程中，第一步就是LSH查询，第二步就是RSH查询，简单点来说</p>\\n<ul>\\n<li>LSH查询就是找到变量的容器本身</li>\\n<li>RSH查询就是找到容器的原值</li>\\n</ul>\\n<pre><code class=\\\"language-javascript\\\">// var a就是LSH\\n// a = 2就是RSH\\nvar a = 2;\\n\\n// 这里的a其实就是做了一个RSH查询\\nconsole.log(a)\\n</code></pre>\\n<p>为什么需要理解这两个概念呢，因为在变量没有声明的情况下，这两种查询的行为是不一样的。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    console.log(a + b);\\n    b = a;\\n}\\n\\nfoo(2);\\n</code></pre>\\n<p>在第一次对b做RSH查询时候是无法找到该变量，所以引擎在这时候就会报出一个<code>ReferenceError</code>的错误。第二个b也还没有声明，但是引擎并没有报错，因为这里先做了LSH查询，所以可以知道，LSH查询如果未找到变量，会在全局中定义一个变量b（非严格模式下），再做RSH查询。引擎还有一个<code>TypeError</code>的错误，在试图对一个非函数类型的值执行函数调用，或者引用<code>null</code>, <code>undefined</code>类型值中的属性时候，就会报这个错误。</p>\\n<h2>提升</h2>\\n<p>很多时候都会认为javascript代码是由上到下一行一行执行的，但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p>\\n<pre><code class=\\\"language-javascript\\\">a = 2;\\n\\nvar a;\\n\\nconsole.log(a);  // 2\\n</code></pre>\\n<p>还有另外一段</p>\\n<pre><code class=\\\"language-javascript\\\">console.log(a); // undefined\\n\\nvar a = 2;\\n</code></pre>\\n<p>当js执行一个<code>var a = 2</code>的时候，这里并不是我们看到的一个声明，而是<code>var a</code>, <code>a = 2</code>两个声明，<code>var a</code>会在编译阶段执行，<code>a = 2</code>则会在执行阶段执行。所以第二段代码就很容易解释通了，代码执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var a;\\n\\nconsole.log(a);\\n\\na = 2;\\n</code></pre>\\n<p>而这个函数声明自动移动到顶部，就叫做<strong>提升</strong>。</p>\\n<p>提升操作会出现在<strong>每个作用域</strong>中，看以下代码</p>\\n<pre><code class=\\\"language-javascript\\\">foo();\\n\\nfunction foo() {\\n    console.log(a);\\n    var a = 2;\\n}\\n</code></pre>\\n<p>实际执行如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a;\\n    console.log(a);\\n    a = 2;\\n}\\n\\nfoo();\\n</code></pre>\\n<p>可以看到，函数声明会被提升到最顶部，但是函数表达式却不会被提升</p>\\n<pre><code>foo(); // TypeError\\nbar(); // ReferenceError\\n\\nvar foo = function bar() {\\n    ...\\n}\\n</code></pre>\\n<p>在这里要注意，把foo分配到具名函数下，但是具名函数下也无法在所在作用域中运行。上面函数的执行方式应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var foo;\\n\\nfoo(); // TypeError\\n\\nbar(); // ReferenceError\\n\\nfoo = function() {\\n    var bar = ... self ...\\n}\\n</code></pre>\\n<h3>函数优先</h3>\\n<p>从上面可以知道定义变量和声明函数都会触发提升，但是如果在重复声明的代码下，会出现什么情况呢</p>\\n<pre><code class=\\\"language-javascript\\\">foo(); // 1\\n\\nvar foo;\\n\\nfunction foo() {\\n    console.log(1);\\n}\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>这里会出现<strong>1</strong>而不是<strong>2</strong>！因为函数会首先被提升，再到变量，所以执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    console.log(1);\\n}\\n\\nfoo();\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>在一个普通的块( { ... } 的代码)，函数也会提升，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var a = true;\\n\\nif(a) {\\n    function foo() {\\n        ...\\n    }\\n}else {\\n    function bar() {\\n        ...\\n    }\\n}\\n</code></pre>\\n<p>这里的<code>foo</code>和<code>bar</code>都不会按判断来声明函数，所以在判断声明函数并不可靠。</p>\\n<h2>作用域嵌套</h2>\\n<p>当一个块或者函数嵌套在另一个块或者函数中，就称为作用域嵌套。在当前作用域没有找到某个变量时，<strong>引擎</strong>就会在外层的作用域继续查找，直到找到该变量，或者抵达最外层（全局）作用域为止。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    // b在函数中尚未定义，所以在上一个作用域中查找\\n    // 在全局中找到变量b，赋值\\n    console.log(a + b);\\n}\\n\\nvar b = 2;\\n\\nfoo(2); // 4\\n</code></pre>\\n<h1>函数作用域</h1>\\n<p>每个函数都有自己的执行环境，或者说函数有自己作用域。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而函数执行之后，栈将其环境弹出，把控制权返回之前的执行环境。函数作用域内的变量访问正是又这个执行机制控制着。而通过这一机制，能实现隐藏作用域中变量或者函数，规避同名标识符之间的冲突。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    function bar(a) {\\n        // i会从for块中找到变量容器，然后执行赋值\\n        i = 3;\\n        console.log(a + i);\\n    }\\n\\n    for(var i = 0; i &#x3C;= 10; i++) {\\n        // 执行bar后会给i重新赋值3，满足i&#x3C;=10，函数死循环\\n        bar(i * 2);\\n    }\\n}\\n</code></pre>\\n<p>这时候只需要在bar内部修改<code>i = 3</code>为<code>var i = 3</code>，将i变为<code>bar</code>中的本地变量即可。除了新建一个函数去隐藏变量，还能通过匿名函数的特性去实现隐藏变量，社区中也称为<strong>IIFE</strong>。</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function() {\\n    var a = 3;\\n    console.log(a); // 3\\n})()\\n\\nconsole.log(a); // 2\\n</code></pre>\\n<p>还能当作函数调用传参</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function(global) {\\n    var a = 3;\\n\\n    console.log(a); // 3\\n    console.log(global.a); // 2\\n})(window)\\n</code></pre>\\n<p>通过隐藏变量活着函数，能实现<strong>全局命名空间</strong>或者<strong>JS模块化</strong>(后面会讨论到)。</p>\\n<h1>块作用域</h1>\\n<p>在JS中块作用域并不常见，但是某些代码却经常会被误以为是块作用域，所以很容易造成理解上的错误，例如下面的常用代码</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nif(true) {\\n    var foo = 'bar';\\n}\\n\\nconsole.log(i, foo); // 10 bar\\n</code></pre>\\n<p>上面代码的<code>i</code>和<code>foo</code>其实都在外部作用域中定义的，而不是在代码块中定义的变量，所以平时在这些代码中定义变量应该是距离使用的地方越近越好。</p>\\n<h2>延长作用域链(块作用域)</h2>\\n<ul>\\n<li>\\n<p>with语句。with从对象中创建出来的对象只在with声明中有效。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\nvar qs = \\\"?bar=true\\\";\\n\\nwith(location) {\\n    // href实际是location.href，只能在with内部使用\\n    var url = href + qs;\\n}\\n\\nreturn url;\\n}\\n</code></pre>\\n</li>\\n<li>\\n<p>try/catch中的catch分句会创造一个块作用域，声明的错误对象变量仅在catch内部有效。</p>\\n<pre><code class=\\\"language-javascript\\\">try {\\nundefined(); // 强制执行一个错误操作\\n} catch(err) {\\nconsole.log(err);\\n}\\n</code></pre>\\n</li>\\n</ul>\\n<p>console.log(err); // ReferenceError</p>\\n<pre><code>## let/const\\n在ES6中，引入了let和const，提供了除var以外的另一种声明变量的方式。用let/const声明的变量会绑定在所在的所用域中（通常是{ ... }内部，换句话说，let/const能劫持所在作用域。\\n```javascript\\n// 修改下上面的循环例子\\nfor(let i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nconsole.log(i); // ReferenceError\\n</code></pre>\\n<p>const在使用方法上跟len是一样，只是创建的值是固定的（常量）。后面任何修改值的操作都会报错。<strong>(注：const实际保证的并不是常量不能改变，而是变量的内存地址不能改变，所以对于复杂的类型object，也只能保证对象的指针地址是固定的，但是对象内部的数据结构则不能固定)</strong></p>\\n<pre><code class=\\\"language-javascript\\\">const foo = {};\\n\\nfoo.bar = 'bar';\\nconsole.log(foo.bar); // bar\\n\\nfoo = {}; // TypeError\\n</code></pre>\\n<h1>总结</h1>\\n<p>通过学习js中的作用域运行方式，了解变量在执行环境的声明周期，以及哪部分代码能访问其中的变量。能为后面学习<strong>闭包</strong>还有实现模块化打下基础。以下是关于作用域的几点总结：</p>\\n<ul>\\n<li>函数局部环境不仅有访问函数作用域的变量的权限，而且还有权访问其包含(父)环境的变量。</li>\\n<li>除全局、函数作用域外，还有比较少用的块作用域。</li>\\n</ul>\",\"htmlExcerpt\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</p>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"js实现add(1)(2)(3)\",\"date\":\"2017-05-28\",\"category\":[\"javascript\"],\"tags\":null,\"path\":\"/post/add-chain\"},\"excerpt\":\"\\n# 题目\\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现\\n\\n```javascript\\nfunction add(x) {\\n\\tvar fn = function(y) {\\n\\t\\treturn add(x + y);\\n\\t}\\n\\n\\treturn fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"题目\"},{\"depth\":1,\"value\":\"实现方法\"}],\"html\":\"<h1>题目</h1>\\n<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    return fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n</code></pre>\\n<!-- more -->\\n<h1>实现方法</h1>\\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    fn.toString = function() {\\n        return x;\\n    }\\n\\n    return fn;\\n}\\n\\n\\n// chrome  function 6\\n// firefox function add/fn\\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\\nconsole.log(add(1)(2)(3))\\n\\nconsole.log(add(1)(2)(3).toString()) // 6\\n</code></pre>\\n<p>由此看出在不同客户端下返回的结果并不一样，并不是完美的结果，但是查阅了其他资料并没有其他十分好的解决办法，估计这道题的考查点是关于js深度的，比如原生对象里面的基本方法和<code>alert</code>, <code>console</code>会自动执行toString等方法。</p>\\n<p>另外，<code>valueOf</code>和<code>toString</code>方法其实是差不多的，返回的结果基本都是相同的，但是试了一下定义了两个不同的方法，发现总是会返回valueOf的值先，所以觉得toString应该是应用于valueOf的结果。</p>\",\"htmlExcerpt\":\"<h1>题目</h1>\\n<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    return fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"Promise的简单实现\",\"date\":\"2017-05-17\",\"category\":[\"前端\"],\"tags\":[\"javascript\"],\"path\":\"/post/js-promise\"},\"excerpt\":\"\\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\\n\\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\\n\\n\\n\\n# 初步构建一个Promise\\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\\n```javascript\\n// 例1\\nfunction getAsyncData() {\\n\\treturn new Promise(function(resolve, reject) {\\n\\t\\tsetTimeout(function() {\\n\\t\\t\\tresolve('promise done!')\\n\\t\\t}, 1000)\\n\\t})\\n}\\n\\ngetAsyncData().then(function(result) {\\n\\tconsole.log(result);\\n}).then(function() {\\n\\tconsole.log('done too!');\\n})\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"初步构建一个Promise\"},{\"depth\":1,\"value\":\"引入状态\"},{\"depth\":1,\"value\":\"串行promise\"},{\"depth\":1,\"value\":\"添加reject功能\"},{\"depth\":1,\"value\":\"总结\"},{\"depth\":2,\"value\":\"参考\"}],\"html\":\"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\\\"https://promisesaplus.com/\\\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\\n<h1>初步构建一个Promise</h1>\\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\\n<pre><code class=\\\"language-javascript\\\">// 例1\\nfunction getAsyncData() {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve('promise done!')\\n        }, 1000)\\n    })\\n}\\n\\ngetAsyncData().then(function(result) {\\n    console.log(result);\\n}).then(function() {\\n    console.log('done too!');\\n})\\n</code></pre>\\n<!-- more -->\\n<p><code>getAsyncData</code>函数中返回一个promise对象，然后通过<code>then</code>方法执行函数的回调，然后尝试实现一下这个基本的功能</p>\\n<pre><code class=\\\"language-javascript\\\">// promise.js\\nvar Primose = function(fn) {\\n    var callbacks = [];\\n\\n    this.done = function(onFulfilled) {\\n        this.callbacks.push(onFulfilled)\\n\\n        // 支持链式调用\\n        return this;\\n    }\\n\\n    function resolve(value) {\\n        // push到队列的最底端，保证链式代码执行完后再执行方法\\n        setTimeout(function() {\\n            while(callbacks[0]) {\\n                callbacks.shift()()\\n            }\\n        }, 0)\\n    }\\n\\n    fn(resolve)\\n}\\n</code></pre>\\n<p>到这里就完成了promise的基础功能，然后执行一下看下有没有达到预期情况:</p>\\n<pre><code class=\\\"language-bash\\\">$node promise\\npromise done!\\ndone too!\\n</code></pre>\\n<p>乍看一下，怎么有点像lazyman(js中比较有名的题目，可以自行百度一下) ，看来平时多读书还是有好处的（手动滑稽）v</p>\\n<h1>引入状态</h1>\\n<p>这里我们可以先看下<a href=\\\"https://promisesaplus.com/#requirements\\\">promise状态规范</a></p>\\n<p>promise必需在pending, fulfilled或者reject三个状态中的一个</p>\\n<ul>\\n<li>\\n<p>当promise在pending状态中</p>\\n<ul>\\n<li>可以变为fulfilled或者reject状态</li>\\n</ul>\\n</li>\\n<li>\\n<p>当promise在fulfilled中</p>\\n<ul>\\n<li>不能过渡为其他状态</li>\\n<li>必需返回一个值，并且不能改变</li>\\n</ul>\\n</li>\\n<li>\\n<p>当promise在reject中</p>\\n<ul>\\n<li>不能过渡为其他状态</li>\\n<li>必需返回一个失败原因，并且不能改变</li>\\n</ul>\\n</li>\\n</ul>\\n<p>从这里可以看出，我们需要添加一个<code>status</code>变量保存状态，并且随着代码执行更新状态。</p>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        value = null,\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled) {\\n        if(state === 'pending') {\\n            callbacks.push(onFulfilled);\\n            return this;\\n        }\\n\\n        onFulfilled(value);\\n        return this;\\n    }\\n\\n    function resolve(newValue) {\\n        state = 'fulfilled';\\n        value = newValue;\\n\\n        setTimeout(function() {\\n            while(callbacks[0]) {\\n                callbacks.shift()(value)\\n            }\\n        }, 0)\\n    }\\n\\n    fn(resolve)\\n}\\n</code></pre>\\n<h1>串行promise</h1>\\n<p>在执行promise的时候，经常会在<code>then</code>的方法里面执行另外一个promise，<em>串联执行promise应该是promise里面最有趣并且是最核心的功能了</em>。</p>\\n<p>串行promise指执行完一个异步函数达到fulfilled状态后，接着执行下一个promise，例如</p>\\n<pre><code class=\\\"language-javascript\\\">// 接着例1\\n\\ngetAsyncData()\\n    .then(getAsyncData2)\\n    .then(function(data) {\\n        console.log(data + 'done too!');\\n    })\\n\\nfunction getAsyncData2(result) {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve(result + 'next promise done!')\\n        }, 1000)\\n    })\\n}\\n</code></pre>\\n<p>要实现这个功能，首先，我们，之前的<code>then</code>方法是直接把<code>this</code>返回出去，所以实现链式调用，执行起来的时候也扛扛的，没毛病，但如果then中执行下一个promise，这时候按上面的代码，应该是直接就return一个promise出去的，走不了下一步，所以<code>then</code>方法应该需要处理一下，promise的执行方式应该要变为：</p>\\n<ol>\\n<li>执行代码，将所有方法push到<code>callbacks</code>数组里面</li>\\n<li>如果<code>then</code>中是一个promise，把剩下的<code>callbacks</code>提交到这个promise中执行</li>\\n<li>再循环第一步</li>\\n</ol>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        // value = null,\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled) {\\n        switch(state) {\\n            case 'pending':\\n                callbacks.push(onFulfilled)\\n                return this;\\n                break;\\n            case 'fulfilled':\\n                onFulfilled()\\n                return this;\\n                break;\\n        }\\n    }\\n\\n    function resolve(newValue) {\\n        var value = newValue;\\n        var temp = null;\\n\\n        setTimeout(function() {\\n            state = 'fulfilled';\\n            do {\\n                temp = callbacks.shift()(value)\\n                // 顺序执行数组，如果是resolve返回value\\n                // 如果是promise则把后面的then方法提交到下个promise中执行\\n                if(temp instanceof Promise) {\\n                    while(callbacks[0]) {\\n                        temp.then(callbacks.shift())\\n                    }\\n                    return;\\n                }else {\\n                    value = temp;\\n                }\\n            }while(callbacks[0])\\n        }, 0)\\n    }\\n    fn(resolve)\\n}\\n</code></pre>\\n<h1>添加reject功能</h1>\\n<p>因为不确定then方法中是否会添加reject的处理，所以选用了一个比较笨的方法，加一个<code>errDerrers</code>的数组，每次执行不管有没有方法<code>then</code>都<code>push</code>到数组里面，<code>resolve</code>一个方法就<code>shift</code>一个，跟成功的回调一样，当reject的时候，判断下当前的方法是不是一个可执行函数，如果是的话则执行。至于catch的方法按这个思路暂时没想到，后面想到再更新。修改的地方都有添加注释。</p>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        // value = null,\\n        error = null,\\n        errDeffers = [],\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled, rejected) {\\n        switch(state) {\\n            case 'pending':\\n                callbacks.push(onFulfilled);\\n                // 每次执行then都push一次\\n                errDeffers.push(rejected);\\n                return this;\\n                break;\\n            case 'fulfilled':\\n                onFulfilled()\\n                return this;\\n                break;\\n            // reject的话直接执行\\n            case 'rejected':\\n                rejected(error);\\n                return this;\\n                break;\\n        }\\n    }\\n\\n    this.catch = function(rejected) {\\n        if(errDeffer === null) {\\n            errDeffer = rejected;\\n            return;\\n        }\\n    }\\n\\n    function resolve(newValue) {\\n        var value = newValue;\\n        var temp = null;\\n\\n        setTimeout(function() {\\n            state = 'fulfilled';\\n            do {\\n                temp = callbacks.shift()(value);\\n                errDeffers.shift();\\n                // 顺序执行数组，如果是resolve返回value\\n                // 如果是promise则把后面的then方法提交到下个promise中执行\\n                if(temp instanceof Promise) {\\n\\n                    while(callbacks[0]) {\\n                        // 成功的时候也要更新一下errDeffers数组\\n                        temp.then(callbacks.shift(), errDeffers.shift())\\n                    }\\n\\n                    return;\\n                }else {\\n                    value = temp;\\n                }\\n            }while(callbacks[0])\\n        }, 0)\\n    }\\n\\n    // reject方法\\n    // 判断rejected是否一个函数，是的话执行，不是的话抛出一个错误\\n    // reject也要提交到栈的最底端执行\\n    function reject(err) {\\n        setTimeout(function() {\\n            state = 'rejected';\\n            error = err;\\n            var rejected = errDeffers.shift();\\n\\n            if(Object.prototype.toString.call(rejected) !== '[object Function]') {\\n                throw new Error('Uncaught promise error!');\\n                return;\\n            }\\n\\n            rejected(error);\\n        }, 0)\\n    }\\n\\n    fn(resolve, reject)\\n}\\n</code></pre>\\n<h1>总结</h1>\\n<p>找资料的时候看到<a href=\\\"http://tech.meituan.com/promise-insight.html\\\">美团技术团队博客的实现方式</a>采用了另外一种解决方式解决串行promise，后面接着研究下，有兴趣也可以自行看下。\\n实现promise应该有下面几个要点：</p>\\n<ol>\\n<li>函数的顺序执行</li>\\n<li>处理好状态（这部分感觉我的方法跟promiseA的状态要求有点偏差）</li>\\n<li>链式调用\\n这个例子只是根据promise的执行方式实现大概的功能，后面或许会根据promise规范去实现一个比较规范的demo。</li>\\n</ol>\\n<h2>参考</h2>\\n<ul>\\n<li><a href=\\\"https://promisesaplus.com/#requirements\\\">Promises/A+</a></li>\\n<li><a href=\\\"http://tech.meituan.com/promise-insight.html\\\">剖析 Promise 之基础篇</a></li>\\n<li><a href=\\\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\\\">Javascript异步编程的4种方法</a></li>\\n</ul>\",\"htmlExcerpt\":\"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\\\"https://promisesaplus.com/\\\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\\n<h1>初步构建一个Promise</h1>\\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\\n<pre><code class=\\\"language-javascript\\\">// 例1\\nfunction getAsyncData() {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve('promise done!')\\n        }, 1000)\\n    })\\n}\\n\\ngetAsyncData().then(function(result) {\\n    console.log(result);\\n}).then(function() {\\n    console.log('done too!');\\n})\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"前端单元测试&Mocha指北\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":null,\"path\":\"/post/unit-test\"},\"excerpt\":\"\\n# 什么是单元-测试?\\n- 单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。\\n- 而测试，就是测试啦。\\n\\n所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。\\n\\n# 为什么要写单元测试？\\n单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"什么是单元-测试?\"},{\"depth\":1,\"value\":\"为什么要写单元测试？\"},{\"depth\":1,\"value\":\"干了这杯 \\\"Mocha\\\"\"},{\"depth\":2,\"value\":\"举个例子\"},{\"depth\":1,\"value\":\"小结\"}],\"html\":\"<h1>什么是单元-测试?</h1>\\n<ul>\\n<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>\\n<li>而测试，就是测试啦。</li>\\n</ul>\\n<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>\\n<h1>为什么要写单元测试？</h1>\\n<p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>\\n<!-- more -->\\n<h1>干了这杯 \\\"Mocha\\\"</h1>\\n<p>mocha是一个js测试框架，除此外，类似的测试框架还有Jasmine、Karma、Tape等，至于为什么要介绍Mocha？因为我只懂这一个。\\n上代码前还要普及一下两个概念</p>\\n<ul>\\n<li><a href=\\\"https://zh.wikipedia.org/wiki/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91\\\">BDD（Behavior Driven Development）</a>\\nBDD意为行为驱动开发，是一种敏捷软件开发技术，具体内容大家可以参考wikipedia的解释。</li>\\n<li><a href=\\\"https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)\\\">Assertion 断言</a>\\n断言，就是判断代码的执行结果与预期是否一致，不一致就抛出错误，说得简单点就是判断程序的真假。</li>\\n</ul>\\n<h2>举个例子</h2>\\n<pre><code class=\\\"language-javascript\\\">// add.js\\nfunction add(a, b) {\\n    return a + b\\n}\\nmodule.exports = add\\n</code></pre>\\n<p>通常测试脚本要与测试源码同名，比如add.js的测试脚本就是add.test.js</p>\\n<pre><code class=\\\"language-javascript\\\">// add.test.js\\nconst add = require('./add.js')\\nconst expect = require('chai').expect\\n\\ndescribe('加法函数测试', function() {\\n    it('1 + 1 等于 2', function() {\\n        expect(add(1, 1)).to.be.equal(2)\\n    })\\n    it('返回值是Number', function() {\\n        expect(add(1, 1)).to.be.a('number')\\n    })\\n})\\n</code></pre>\\n<p>上面代码块就是测试脚本，可独立运行，测试脚本中应该包括一个或多个<code>describe</code>块，每个<code>describe</code>块应包括多个<code>it</code>块。\\n<code>describe</code>是测试套件，这个方法需要传两个参数，第一个为测试套件的名称<code>('加法函数测试')</code>，第二个是执行函数。\\n<code>it</code>块是测试用例，表示一个单独的测试，是测试的最小单位，第一个参数是测试用例的名称('1 + 1 等于 2')，第二个是执行函数。</p>\\n<p>然后在terminal下执行<code>mocha add.test.js</code></p>\\n<pre><code class=\\\"language-terminal\\\">$ mocha add.test.js\\n\\n   加法函数测试\\n     √ 1 + 1 等于 2\\n     √ 返回值是Number\\n   2 passing (12ms)\\n</code></pre>\\n<p>如果我们改变一下<code>add.js</code></p>\\n<pre><code class=\\\"language-javascript\\\">// add.js\\nfunction add(a, b) {\\n    return a * b\\n}\\nmodule.exports = add\\n</code></pre>\\n<p>然后再执行一下<code>mocha add.test.js</code></p>\\n<pre><code class=\\\"language-terminal\\\">$ mocha add.test.js\\n\\n   加法函数测试\\n     √ 1 + 1 等于 2\\n     1) 返回值是Number\\n   1 passing (8ms)\\n   1 failing\\n\\n   1) 加法函数测试 返回值是Number:\\n       AssertionError: expected 2 to equal 3\\n       + expected - actual\\n\\n       -2\\n       +3\\n\\n       at Context.it(add.test.js:6:27)\\n</code></pre>\\n<p>这里也可以很明显看出哪个测试用例报错、还有报错的位置，这样在开发的时候开发人员就能很容易定位错误。</p>\\n<h1>小结</h1>\\n<p>从上面一个简单的例子可以看出，利用mocha实现自动化测试是很简单的。虽然前期开发需要花一点时间去写单元测试，但是后面提供的便利性足以将其弥补。</p>\",\"htmlExcerpt\":\"<h1>什么是单元-测试?</h1>\\n<ul>\\n<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>\\n<li>而测试，就是测试啦。</li>\\n</ul>\\n<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>\\n<h1>为什么要写单元测试？</h1>\\n<p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"使用nodejs写一个命令行程序\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":[\"nodejs\",\"bash\"],\"path\":\"/post/node-command-app\"},\"excerpt\":\"\\n> 原文译自[Smashing Magazine](https://www.smashingmagazine.com/) -- [[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)\\n\\n相信很多前端都听说过或者使用过[Gulp](http://www.gulpjs.com.cn/), [Angular CLI](https://cli.angular.io/), [Cordova](https://cordova.apache.org/), [Yeoman](http://yeoman.io/)或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用`ng new <project-name>`后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。\\n\\n在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用[SendGrid Api](https://github.com/sendgrid/sendgrid-nodejs)模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令\\n\\n\",\"headings\":[{\"depth\":2,\"value\":\"“Hello World”\"},{\"depth\":2,\"value\":\"处理命令行参数\"},{\"depth\":2,\"value\":\"运行时输入参数\"},{\"depth\":2,\"value\":\"模拟发送邮件\"},{\"depth\":2,\"value\":\"变成shell命令\"}],\"html\":\"<blockquote>\\n<p>原文译自<a href=\\\"https://www.smashingmagazine.com/\\\">Smashing Magazine</a> -- <a href=\\\"https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/\\\">[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)</a></p>\\n</blockquote>\\n<p>相信很多前端都听说过或者使用过<a href=\\\"http://www.gulpjs.com.cn/\\\">Gulp</a>, <a href=\\\"https://cli.angular.io/\\\">Angular CLI</a>, <a href=\\\"https://cordova.apache.org/\\\">Cordova</a>, <a href=\\\"http://yeoman.io/\\\">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code>ng new &#x3C;project-name></code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>\\n<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href=\\\"https://github.com/sendgrid/sendgrid-nodejs\\\">SendGrid Api</a>模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令</p>\\n<!-- more -->\\n<hr>\\n<h2>“Hello World”</h2>\\n<p>开始前，首先你得有node，如果没有，请自行安装下。node中自带npm，使用<a href=\\\"https://www.npmjs.com/\\\">npm</a>能安装许多开源的node模块。首先，使用npm创建一个node项目</p>\\n<pre><code class=\\\"language-shell\\\">$ npm init\\nname: broadcast\\nversion: 0.0.1\\ndescription: CLI utility to broadcast email\\nentry point: broadcast.js\\n</code></pre>\\n<p>除这些参数外，npm还提供了其他如Git repository等参数，可根据自身需求设置输入。执行完<code>npm init</code>后，会发现在同目录下生成了一个<code>package.json</code>文件，文件里面包含了上面命令输入的信息。配置内容信息可以在<a href=\\\"https://docs.npmjs.com/files/package.json\\\">package.json文档</a>中找到。</p>\\n<p>然后，还是从最简单的Hello World入手。首先在同目录下建一个<code>broadcast.js</code>文件</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\nconsole.log('Hello World!')\\n</code></pre>\\n<p>然后在terminal中执行</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast\\nHello World!\\n</code></pre>\\n<p>well done, 根据<a href=\\\"https://docs.npmjs.com/files/package.json\\\">package.json文档</a>，我们可以找到一个<code>dependencies</code>参数，在这参数中你可以找到所有这项目需要用到的第三方模块和它们的版本号，上面也有提及到，我们需要用到模块去开发这个工具。最后开发完成，<code>package.json</code>应该如下</p>\\n<pre><code class=\\\"language-json\\\">{\\n    \\\"name\\\": \\\"broadcast\\\",\\n    \\\"version\\\": \\\"0.0.1\\\",\\n    \\\"description\\\": \\\"CLI utility to broadcast emails\\\",\\n    \\\"main\\\": \\\"broadcast.js\\\",\\n    \\\"license\\\": \\\"MIT\\\",\\n    \\\"dependencies\\\": {\\n        \\\"chalk\\\": \\\"^1.1.3\\\",\\n        \\\"commander\\\": \\\"^2.9.0\\\",\\n        \\\"csv\\\": \\\"^1.1.0\\\",\\n        \\\"inquirer\\\": \\\"^2.0.0\\\"\\n    }\\n}\\n</code></pre>\\n<p>这几个模块 <a href=\\\"https://github.com/chalk/chalk\\\">Chalk</a>, <a href=\\\"https://github.com/tj/commander.js\\\">Commander</a>, <a href=\\\"https://github.com/sboudrias/Inquirer.js\\\">Inquirer</a>, <a href=\\\"http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/\\\">CSV</a>的具体用处跟其他参数，可以自行查看。</p>\\n<h2>处理命令行参数</h2>\\n<p>node原生也有读取命令行的函数<a href=\\\"https://nodejs.org/docs/latest/api/process.html\\\"><code>process.argv</code></a>，但是解析参数是个繁琐的工作，所以我们会使用<a href=\\\"https://github.com/tj/commander.js\\\">Commander</a>去替代这些工作。Commande的另外一个好处就是不用额外的去写一个<code>--help</code>函数，只要定义了其他参数，<code>--help</code>函数就会自动生成。首先安装一下Commander和其他package</p>\\n<pre><code class=\\\"language-shell\\\">$ npm install commander chalk csv inquirer --save\\n</code></pre>\\n<p>然后修改<code>broadcast.js</code></p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast\\nconst program = require('commander')\\n\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'list of customers in CSV file')\\n    .parse(process.argv)\\n\\nconsole.log(program.list)\\n</code></pre>\\n<p>从上面可以看出，处理一个参数是十分简单的。我们定义了一个<code>--list</code>的参数，现在我们就能通过<code>--list</code>参数获取到命令行传过来的值。在这程序中，list应该是接收一个csv的地址参数，然后打印在console中。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --list ./test.csv\\n./test.csv\\n</code></pre>\\n<p>从js中可以看到还有一个<code>version</code>参数，所以我们可以使用<code>--version</code>读取版本号。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --version\\n0.0.1\\n</code></pre>\\n<p>又或者能使用<code>--help</code>获取app能接收的参数</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --help\\n\\n  Usage: broadcast [options]\\n\\n  Options:\\n\\n    -h, --help                 output usage information\\n    -V, --version              output the version number\\n    -l, --list &#x3C;list>          list of customers in CSV file\\n</code></pre>\\n<p>现在我们已经能够接收到命令行传递过来的参数了，下面我们会利用接收到的CSV文件地址，并使用<a href=\\\"http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/\\\">CSV</a>模块处理CSV文件的内容。\\n我们会使用下面的比哦啊哥内容作为CSV文件的内容。使用CSV模块，会读取内容，并显示各列的内容。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>First name</th>\\n<th>Last name</th>\\n<th>Email</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Dwight</td>\\n<td>Schrute</td>\\n<td>dwight.schrute@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Jim</td>\\n<td>Halpert</td>\\n<td>jim.halpert@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Pam</td>\\n<td>Beesly</td>\\n<td>pam.beesly@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Ryan</td>\\n<td>Howard</td>\\n<td>ryan.howard@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Stanley</td>\\n<td>Hudson</td>\\n<td>stanley.hudson@dundermifflin.com</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>现在，更新下<code>broadcast.js</code>，使用CSV读取内容并打印在console</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\nconst program = require('commander')\\nconst csv = require('csv')\\nconst fs = require('fs')\\n\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'List of customers in CSV')\\n    .parse(process.argv)\\n\\nconst stream = fs.createReadStream(program.list)\\nstream\\n    .pipe(csv.parse({ delimiter : \\\",\\\" }))\\n    .on('data', function(data) {\\n         const firstname = data[0]\\n         const lastname = data[1]\\n         const email = data[2]\\n\\n         console.log(firstname, lastname, email)\\n    })\\n</code></pre>\\n<p>除csv模块外，还使用了node的<a href=\\\"https://nodejs.org/dist/latest-v7.x/docs/api/fs.html\\\">File System</a>模块读取文件内容，csv的<code>parse</code>方法把列数据解析为数组，然后在terminal中运行一下命令</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast.js --list ./test.csv\\nDwight Schrute dwight.schrute@dundermifflin.com\\nJim Halpert jim.halpert@dundermifflin.com\\nPam Beesly pam.beesly@dundermifflin.com\\nRyan Howard ryan.howard@dundermifflin.com\\nStanley Hudson stanley.hudson@dundermifflin.com\\n</code></pre>\\n<h2>运行时输入参数</h2>\\n<p>上面已经实现了获取命令行参数，但如果想在运行时候接收参数值的话我们就需要另外一个模块<a href=\\\"https://github.com/sboudrias/Inquirer.js\\\">inquirer.js</a>，通过这个模块，用户可以自定义多种参数类型，如文本，密码，单选或者多选列表等。</p>\\n<p>下面的demo会通过inquirer接收邮件发送人的名字，email还有邮件主题。</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\n...\\nconst inquirer = require('inquirer')\\nconst questions = [\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"sender.email\\\",\\n    message : \\\"Sender's email address - \\\"\\n  },\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"sender.name\\\",\\n    message : \\\"Sender's name - \\\"\\n  },\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"subject\\\",\\n    message : \\\"Subject - \\\"\\n  }\\n]\\n\\nprogram\\n  .version('0.0.1')\\n  .option('-l, --list [list]', 'List of customers in CSV')\\n  .parse(process.argv)\\n\\n// 储存CSV数据\\nconst contactList = []\\nconst stream = fs.createReadStream(program.list)\\n    .pipe(csv.parse({ delimiter : \\\",\\\" }))\\n\\nstream\\n  .on('error', function (err) {\\n    return console.error(err.message)\\n  })\\n  .on('data', function (data) {\\n    let name = data[0] + \\\" \\\" + data[1]\\n    let email = data[2]\\n    contactList.push({ name : name, email : email })\\n  })\\n  .on('end', function () {\\n    inquirer.prompt(questions).then(function (answers) {\\n      console.log(answers)\\n    })\\n  })\\n</code></pre>\\n<p>Inquire.js的<code>prompt</code>方法接受一个数组参数，数组里可以自定义运行时需要接受的问题参数，在这demo里面，我们想知道发送者的名字还要email还有邮件主题，所以定义了一个<code>questions</code>的数组来储存问题，从对象里面可以看到有一个<code>input</code>的参数，除此外还可以接受<code>password</code>等其他类型，具体可以查询一下<a href=\\\"https://github.com/SBoudrias/Inquirer.js/\\\">inquirer的文档</a>。此外，参数<code>name</code>保存input的key值。<code>prompt</code>方法会返还一个promise对象，promise中会返回一个<code>answer</code>变量，里面带有刚才输入的值。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast -l input/employees.csv\\n? Sender's email address -  kitssang_demo@163.com\\n? Sender's name -  kit\\n? Subject - Hello World\\n{ sender:\\n   { email: '  kitssang_demo@163.com',\\n     name: 'kit' },\\n  subject: 'Hello World' }\\n</code></pre>\\n<h2>模拟发送邮件</h2>\\n<p>由于原文使用的<code>sendgrid</code>没有跑通，所以只组装了一下数据模拟了发送邮件。原本的第五部分也在这里一起用上了。</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\n...\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'list of customers in CSV file')\\n    .parse(process.argv)\\n\\nconst sendEmail = function(to, from, subject) {\\n    const sender = chalk.green(`${from.name}(${from.email})`)\\n    const receiver = chalk.green(`${to.name}(${to.email})`)\\n    const theme = chalk.blue(subject)\\n\\n    console.log(`${sender} send a mail to ${receiver} and the subject of the email is ${theme}`)\\n}\\n\\n// 储存CSV数据\\nlet concatList = []\\nconst stream = fs.createReadStream(program.list)\\n  .pipe(csv.parse({\\n    delimiter: ','\\n  }))\\n  .on('data', function(data) {\\n    const name = data[0] + ' ' + data[1]\\n    const email = data[2]\\n\\n    concatList.push({\\n      name: name,\\n      email: email\\n    })\\n  })\\n  .on('end', function() {\\n    inquirer.prompt(questions).then((ans) => {\\n      for (let i = 0; i &#x3C; concatList.length; i++) {\\n        sendEmail(concatList[i], ans.sender, ans.subject)\\n      }\\n    }).catch((err) => {\\n      console.log(err)\\n    })\\n  })\\n</code></pre>\\n<p>由于没有异步请求，<code>async</code>模块没有用上，另外使用了<code>chalk</code>模块改变了console打印结果的颜色。</p>\\n<h2>变成shell命令</h2>\\n<p>至此，整个工具已经基本完成，但是如果想像一个普通的shell命令(不加<code>$ node xx</code>)执行，还需要做以下操作。首先，添加<a href=\\\"https://zh.wikipedia.org/wiki/Shebang\\\">shebang</a>在js的头部，让shell知道如何执行这个文件。</p>\\n<pre><code class=\\\"language-javascript\\\">#!/usr/bin/env node\\n\\n// broadcast.js\\nconst program = require(\\\"commander\\\")\\nconst inquirer = require(\\\"inquirer\\\")\\n...\\n</code></pre>\\n<p>然后再配置一下<code>package.json</code>使代码可运行</p>\\n<pre><code class=\\\"language-json\\\">…\\n  \\\"description\\\": \\\"CLI utility to broadcast emails\\\",\\n  \\\"main\\\": \\\"broadcast.js\\\",\\n  \\\"bin\\\" : {\\n    \\\"broadcast\\\" : \\\"./broadcast.js\\\"\\n  }\\n…\\n</code></pre>\\n<p>从代码可以看到加了一个<a href=\\\"https://docs.npmjs.com/files/package.json#bin\\\"><code>bin</code></a>的参数，这个参数可以使broadcast命令与broadcast.js建立连接。</p>\\n<p>最后一步，在全局安装一下依赖包。在项目目录运行一下下面的命令。</p>\\n<pre><code class=\\\"language-shell\\\">$ npm install -g\\n</code></pre>\\n<p>然后测试一下命令</p>\\n<pre><code class=\\\"language-shell\\\">$ broadcast --help\\n</code></pre>\\n<p>需要注意的是，在开发时候如果使用<code>commaner</code>默认给出的命令执行<code>broadcast</code>则在代码中所做的任何更改都是看不见的。假如输入<code>which broadcast</code>，你会发现地址不是你当前目录，所以这时应该要用<code>npm link</code>去查看命令的目录映射。</p>\",\"htmlExcerpt\":\"<blockquote>\\n<p>原文译自<a href=\\\"https://www.smashingmagazine.com/\\\">Smashing Magazine</a> -- <a href=\\\"https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/\\\">[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)</a></p>\\n</blockquote>\\n<p>相信很多前端都听说过或者使用过<a href=\\\"http://www.gulpjs.com.cn/\\\">Gulp</a>, <a href=\\\"https://cli.angular.io/\\\">Angular CLI</a>, <a href=\\\"https://cordova.apache.org/\\\">Cordova</a>, <a href=\\\"http://yeoman.io/\\\">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code>ng new &#x3C;project-name></code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>\\n<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href=\\\"https://github.com/sendgrid/sendgrid-nodejs\\\">SendGrid Api</a>模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令</p>\\n\"}}],\"page\":3,\"pages\":4,\"total\":16,\"limit\":5,\"prev\":\"/blog/2\",\"next\":\"/blog/4\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-3-e0ad36aa48b8839d6a4a.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"excerpt\":\"作为一个程序员，想必每个都有自己的编码风格。有风格虽好，但这问题令很多项目管理者头疼，不一样的代码风格及缩进，必会降低代码可读性，从而间接降低效率。但是这个问题都难不到我们伟大的程序员，很多如eslint，prettier等库的出现帮我们去解决问题。很多cli…\",\"frontmatter\":{\"title\":\"使用pre-commit实现提交前验证或自动部署代码\",\"date\":\"2018-03-29\",\"category\":[\"tools\"],\"path\":\"/post/pre-commit-hook\"}}},{\"node\":{\"excerpt\":\"\\n> 原文译自[10 Tips for Javascript Debugging Like a PRO with Console](https://medium.com/appsflyer/10-tips-for-javascript-debugging-like-a-pro-with-console-7140027eb5f6) - Yotam Kadishay\\n\\n在日常开发里，我们经常需要使用`console`调试我们的代码，但是使用仅仅是用来打印参数数据。在这篇文章中，将会介绍如何一些`console`的高级用法去更好的做调试工作和定位问题。\\n\\n我们都知道`console`的几个常用的方法\\n\\n```javascript\\nconsole.log('hello world'); // 打印信息或者数据\\nconsole.info(‘Something happened…’); // 和console log一样\\nconsole.warn(‘Something strange happened…’); // 打印警告信息\\nconsole.error(‘Something horrible happened…’); // 打印错误信息\\n```\\n\\n除这些简单的使用外，下面几个`console`的用法希望能帮助你更好的调试你的应用。\\n\\n\",\"frontmatter\":{\"title\":\"10个console的高级使用方法\",\"date\":\"2018-03-19\",\"category\":[\"javascript\"],\"path\":\"/post/10tips-for-console\"}}},{\"node\":{\"excerpt\":\"\\n这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。\\n\\n# 项目构建\\n项目创建是使用vue-cli创建的，模版则是使用我自己维护的[vue-mpa](https://github.com/kitwon/vue-mpa)多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。\\n\\n\",\"frontmatter\":{\"title\":\"年底项目复盘\",\"date\":\"2018-01-23\",\"category\":[\"工作\"],\"path\":\"/post/2017-review\"}}},{\"node\":{\"excerpt\":\"\\n> 这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。\\n\\n----\\n\\n> 现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的[render performance](https://developers.google.com/web/fundamentals/performance/rendering/)对前端渲染优化有了一个新的认识。\\n\\n# 几个重要概念\\n## 60fps与设备刷新率\\n目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。\\n\\n其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\\n\\n\",\"frontmatter\":{\"title\":\"构建60fps-web-app\",\"date\":\"2017-09-13\",\"category\":[\"前端\"],\"path\":\"/post/60fps-web-app\"}}},{\"node\":{\"excerpt\":\"\\n在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下[jest](http://facebook.github.io/jest/)，这是一个[Facebook OpenSource](https://code.facebook.com/projects/)的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持**快照测试**(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。\\n\\n# 配置\\n首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析'.vue'文件的)。\\n```shell\\n$npm install jest jest-vue-preprocessor --save-dev\\n\\n$yarn add jest jest-vue-preprocessor --save\\n```\\n\\n\",\"frontmatter\":{\"title\":\"在vue项目中使用jest进行单元测试\",\"date\":\"2017-08-18\",\"category\":[\"前端工具\"],\"path\":\"/post/vue-jest-test\"}}},{\"node\":{\"excerpt\":\"\\n# 类理论\\n类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。\\n\\n类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。**汽车**可以被看作**交通工具中的一种**，所以在软件开发时可以定义一个`Vehicle`类，`Vehicle`中包含推进器（引擎）、载人能力等方法。定义`Car`时，只要声明它继承或者拓展`Vehicle`这个基础定义就行了，其他交通工具如船、飞机也可以继承`Vehicle`。**这就是类的实例化与继承**。\\n\\n类的另外一个核心概念是**多态**，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。\\n\\njavascript中也有类中的`new`和`instanceof`，还有ES6中的`class`关键字，但这些并不是说明js中有**类**的。javascript中只是为了满足类的设计需求而提供一些类似的语法。\\n\\n## js中实现类复制(混入)\\njavascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。\\n\\n\",\"frontmatter\":{\"title\":\"深入学习javascript-类\",\"date\":\"2017-07-20\",\"category\":null,\"path\":\"/post/js-class\"}}},{\"node\":{\"excerpt\":\"\\n# 关于this\\n\\n`this`应该是javascript中一个比较复杂的机制了，在日常工作中我们可能有意无意都会使用到这个机制，但是`this`的工作机制真正了解的可能只有皮毛，通过学习这一机制，能够提高对js代码的理解和阅读能力，还有对js程序设计模式有着更深的理解。\\n\\n# this的指向\\nthis是运行时进行绑定的，而不是编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\\n\\n通过分析调用位置，就能知道this到底引用的是什么。所以，寻找调用位置就能弄清上面的问题，通过一个例子，就能很好地理解这个问题：\\n```javascript\\nfunction baz() {\\n  // 当前调用栈是 baz\\n  // 当前调用位置是全局作用域\\n\\n  console.log('baz');\\n  bar(); // bar的调用位置\\n}\\n\\nfunction bar() {\\n  // 当前的调用栈是 baz -> bar\\n  // 当前的调用位置是baz\\n\\n  console.log('bar');\\n  foo();\\n}\\n\\nfunction foo() {\\n  // 当前的调用栈是 baz -> bar -> foo\\n  // 当前的调用位置是bar\\n\\n  console.log('foo');\\n}\\n\\nbaz();\\n```\\n\\n\",\"frontmatter\":{\"title\":\"深入学习javascript - this\",\"date\":\"2017-06-27\",\"category\":null,\"path\":\"/post/js-this\"}}},{\"node\":{\"excerpt\":\"\\nwebpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。\\n\\n# 从webpack1中迁移\\n官方已经给出了详细的[迁移指南](https://webpack.js.org/guides/migrating/)，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。\\n\\n## 配置文件\\n如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。\\n\\n### `module.loaders`变成`module.rules`\\n旧的`module.loader`被`module.rules`取代，后者允许配置`loader`更多选项，具体查看文档[module.rules](https://webpack.js.org/configuration/module/#module-rules)\\n\\n```javascript\\n// ...\\nmdoule: {\\n    rules: [\\n        {\\n            test: /\\\\.css$/,\\n            use: [\\n                { loader: 'style-loader' },\\n                {\\n                    loader: 'css-loader',\\n                    options: { module: true }\\n                }\\n            ]\\n        },\\n        {\\n            test: /\\\\.jsx$/,\\n            loader: 'babel-loader',\\n            options: {\\n                // ...\\n            }\\n        }\\n    ]\\n}\\n// ...\\n```\\n\\n\",\"frontmatter\":{\"title\":\"webpack2新特性&迁移\",\"date\":\"2017-06-24\",\"category\":[\"前端工具\"],\"path\":\"/post/webpack2\"}}},{\"node\":{\"excerpt\":\"\\n# 什么是闭包\\n记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。\\n\\n> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\\n--- 你不知道的javascript（上卷）\\n\\n然后看个例子\\n```javascript\\nfunction foo() {\\n\\tvar a = 2;\\n\\n\\tfuntion bar() {\\n\\t\\tconsole.log(a);\\n\\t}\\n\\n\\tbar();\\n}\\n\\nfoo();\\n```\\n如果按上面第一条的定义，这里一定是生成了闭包，但是**确切的说并不是**，这里最准确的说是`bar`对`a`的引用方式是词法作用域的查找规则，而这些只是**闭包**的一部分。然后再看清晰闭包的例子\\n\\n```javascript\\nfucntion foo() {\\n\\tvar a = 2;\\n\\n\\tfunction bar() {\\n\\t\\tconsole.log(a)\\n\\t}\\n\\n\\treturn bar;\\n}\\n\\nvar baz = foo()；\\n\\nbaz(); // 这就是闭包效果\\n```\\n\\n\",\"frontmatter\":{\"title\":\"深入学习javascript-闭包\",\"date\":\"2017-06-14\",\"category\":null,\"path\":\"/post/js-closures\"}}},{\"node\":{\"excerpt\":\"\\n之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。\\n\\n# 主要需求\\n这个demo中爬虫有3个主要模块，**URL管理器**、**下载器**、**解析器**\\n* URL管理器主要处理爬取的URL的状态。\\n* 下载器会通过**URL管理器**传送过来有效URL进行下载。\\n* 解析器会将**下载器**下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给**URL管理器**进行重复操作。\\n\\n## 入口程序\\n`spider_main`文件为程序入口，处理整个爬虫的运行逻辑\\n\\n\",\"frontmatter\":{\"title\":\"用python写一个简单爬虫\",\"date\":\"2017-06-11\",\"category\":null,\"path\":\"/post/python-crawler\"}}},{\"node\":{\"excerpt\":\"\\n# 前言\\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\\n\\n# 作用域是什么\\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\\n\\n\\n\\n## 理解作用域执行过程\\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\\n\\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\\n\\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\\n\\n\",\"frontmatter\":{\"title\":\"深入学习javascript--作用域\",\"date\":\"2017-05-31\",\"category\":null,\"path\":\"/post/js-scope\"}}},{\"node\":{\"excerpt\":\"\\n# 题目\\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现\\n\\n```javascript\\nfunction add(x) {\\n\\tvar fn = function(y) {\\n\\t\\treturn add(x + y);\\n\\t}\\n\\n\\treturn fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n```\\n\\n\",\"frontmatter\":{\"title\":\"js实现add(1)(2)(3)\",\"date\":\"2017-05-28\",\"category\":[\"javascript\"],\"path\":\"/post/add-chain\"}}},{\"node\":{\"excerpt\":\"\\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\\n\\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\\n\\n\\n\\n# 初步构建一个Promise\\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\\n```javascript\\n// 例1\\nfunction getAsyncData() {\\n\\treturn new Promise(function(resolve, reject) {\\n\\t\\tsetTimeout(function() {\\n\\t\\t\\tresolve('promise done!')\\n\\t\\t}, 1000)\\n\\t})\\n}\\n\\ngetAsyncData().then(function(result) {\\n\\tconsole.log(result);\\n}).then(function() {\\n\\tconsole.log('done too!');\\n})\\n```\\n\\n\",\"frontmatter\":{\"title\":\"Promise的简单实现\",\"date\":\"2017-05-17\",\"category\":[\"前端\"],\"path\":\"/post/js-promise\"}}},{\"node\":{\"excerpt\":\"\\n# 什么是单元-测试?\\n- 单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。\\n- 而测试，就是测试啦。\\n\\n所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。\\n\\n# 为什么要写单元测试？\\n单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。\\n\\n\",\"frontmatter\":{\"title\":\"前端单元测试&Mocha指北\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"path\":\"/post/unit-test\"}}},{\"node\":{\"excerpt\":\"\\n> 原文译自[Smashing Magazine](https://www.smashingmagazine.com/) -- [[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)\\n\\n相信很多前端都听说过或者使用过[Gulp](http://www.gulpjs.com.cn/), [Angular CLI](https://cli.angular.io/), [Cordova](https://cordova.apache.org/), [Yeoman](http://yeoman.io/)或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用`ng new <project-name>`后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。\\n\\n在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用[SendGrid Api](https://github.com/sendgrid/sendgrid-nodejs)模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令\\n\\n\",\"frontmatter\":{\"title\":\"使用nodejs写一个命令行程序\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"path\":\"/post/node-command-app\"}}},{\"node\":{\"excerpt\":\"\\n好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。\\n\\n### 小科普\\n什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！\\n\\n\",\"frontmatter\":{\"title\":\"React-todo demo\",\"date\":\"2016-03-02\",\"category\":[\"js framework\"],\"path\":\"/post/react-todo\"}}}]}},\"pathContext\":{\"edgesLen\":16,\"tagsLen\":14,\"categoryLen\":6,\"nodes\":[{\"node\":{\"frontmatter\":{\"title\":\"深入学习javascript--作用域\",\"date\":\"2017-05-31\",\"category\":null,\"tags\":null,\"path\":\"/post/js-scope\"},\"excerpt\":\"\\n# 前言\\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\\n\\n# 作用域是什么\\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\\n\\n\\n\\n## 理解作用域执行过程\\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\\n\\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\\n\\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"前言\"},{\"depth\":1,\"value\":\"作用域是什么\"},{\"depth\":2,\"value\":\"理解作用域执行过程\"},{\"depth\":3,\"value\":\"LSH和RSH查询\"},{\"depth\":2,\"value\":\"提升\"},{\"depth\":3,\"value\":\"函数优先\"},{\"depth\":2,\"value\":\"作用域嵌套\"},{\"depth\":1,\"value\":\"函数作用域\"},{\"depth\":1,\"value\":\"块作用域\"},{\"depth\":2,\"value\":\"延长作用域链(块作用域)\"},{\"depth\":1,\"value\":\"总结\"}],\"html\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。</p>\\n<ol>\\n<li>遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。</li>\\n<li>接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</li>\\n</ol>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n<!-- more -->\\n<h3>LSH和RSH查询</h3>\\n<p>定义一个变量<code>var a = 2</code>，或者执行一个简单的函数<code>console.log(2)</code>中，会同时或者单独出现<strong>LSH</strong>或者<strong>RSH</strong>查询。其实在作用域执行过程中，第一步就是LSH查询，第二步就是RSH查询，简单点来说</p>\\n<ul>\\n<li>LSH查询就是找到变量的容器本身</li>\\n<li>RSH查询就是找到容器的原值</li>\\n</ul>\\n<pre><code class=\\\"language-javascript\\\">// var a就是LSH\\n// a = 2就是RSH\\nvar a = 2;\\n\\n// 这里的a其实就是做了一个RSH查询\\nconsole.log(a)\\n</code></pre>\\n<p>为什么需要理解这两个概念呢，因为在变量没有声明的情况下，这两种查询的行为是不一样的。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    console.log(a + b);\\n    b = a;\\n}\\n\\nfoo(2);\\n</code></pre>\\n<p>在第一次对b做RSH查询时候是无法找到该变量，所以引擎在这时候就会报出一个<code>ReferenceError</code>的错误。第二个b也还没有声明，但是引擎并没有报错，因为这里先做了LSH查询，所以可以知道，LSH查询如果未找到变量，会在全局中定义一个变量b（非严格模式下），再做RSH查询。引擎还有一个<code>TypeError</code>的错误，在试图对一个非函数类型的值执行函数调用，或者引用<code>null</code>, <code>undefined</code>类型值中的属性时候，就会报这个错误。</p>\\n<h2>提升</h2>\\n<p>很多时候都会认为javascript代码是由上到下一行一行执行的，但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p>\\n<pre><code class=\\\"language-javascript\\\">a = 2;\\n\\nvar a;\\n\\nconsole.log(a);  // 2\\n</code></pre>\\n<p>还有另外一段</p>\\n<pre><code class=\\\"language-javascript\\\">console.log(a); // undefined\\n\\nvar a = 2;\\n</code></pre>\\n<p>当js执行一个<code>var a = 2</code>的时候，这里并不是我们看到的一个声明，而是<code>var a</code>, <code>a = 2</code>两个声明，<code>var a</code>会在编译阶段执行，<code>a = 2</code>则会在执行阶段执行。所以第二段代码就很容易解释通了，代码执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var a;\\n\\nconsole.log(a);\\n\\na = 2;\\n</code></pre>\\n<p>而这个函数声明自动移动到顶部，就叫做<strong>提升</strong>。</p>\\n<p>提升操作会出现在<strong>每个作用域</strong>中，看以下代码</p>\\n<pre><code class=\\\"language-javascript\\\">foo();\\n\\nfunction foo() {\\n    console.log(a);\\n    var a = 2;\\n}\\n</code></pre>\\n<p>实际执行如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    var a;\\n    console.log(a);\\n    a = 2;\\n}\\n\\nfoo();\\n</code></pre>\\n<p>可以看到，函数声明会被提升到最顶部，但是函数表达式却不会被提升</p>\\n<pre><code>foo(); // TypeError\\nbar(); // ReferenceError\\n\\nvar foo = function bar() {\\n    ...\\n}\\n</code></pre>\\n<p>在这里要注意，把foo分配到具名函数下，但是具名函数下也无法在所在作用域中运行。上面函数的执行方式应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">var foo;\\n\\nfoo(); // TypeError\\n\\nbar(); // ReferenceError\\n\\nfoo = function() {\\n    var bar = ... self ...\\n}\\n</code></pre>\\n<h3>函数优先</h3>\\n<p>从上面可以知道定义变量和声明函数都会触发提升，但是如果在重复声明的代码下，会出现什么情况呢</p>\\n<pre><code class=\\\"language-javascript\\\">foo(); // 1\\n\\nvar foo;\\n\\nfunction foo() {\\n    console.log(1);\\n}\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>这里会出现<strong>1</strong>而不是<strong>2</strong>！因为函数会首先被提升，再到变量，所以执行顺序应该如下</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    console.log(1);\\n}\\n\\nfoo();\\n\\nfoo = function() {\\n    console.log(2);\\n}\\n</code></pre>\\n<p>在一个普通的块( { ... } 的代码)，函数也会提升，如下代码</p>\\n<pre><code class=\\\"language-javascript\\\">var a = true;\\n\\nif(a) {\\n    function foo() {\\n        ...\\n    }\\n}else {\\n    function bar() {\\n        ...\\n    }\\n}\\n</code></pre>\\n<p>这里的<code>foo</code>和<code>bar</code>都不会按判断来声明函数，所以在判断声明函数并不可靠。</p>\\n<h2>作用域嵌套</h2>\\n<p>当一个块或者函数嵌套在另一个块或者函数中，就称为作用域嵌套。在当前作用域没有找到某个变量时，<strong>引擎</strong>就会在外层的作用域继续查找，直到找到该变量，或者抵达最外层（全局）作用域为止。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo(a) {\\n    // b在函数中尚未定义，所以在上一个作用域中查找\\n    // 在全局中找到变量b，赋值\\n    console.log(a + b);\\n}\\n\\nvar b = 2;\\n\\nfoo(2); // 4\\n</code></pre>\\n<h1>函数作用域</h1>\\n<p>每个函数都有自己的执行环境，或者说函数有自己作用域。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而函数执行之后，栈将其环境弹出，把控制权返回之前的执行环境。函数作用域内的变量访问正是又这个执行机制控制着。而通过这一机制，能实现隐藏作用域中变量或者函数，规避同名标识符之间的冲突。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\n    function bar(a) {\\n        // i会从for块中找到变量容器，然后执行赋值\\n        i = 3;\\n        console.log(a + i);\\n    }\\n\\n    for(var i = 0; i &#x3C;= 10; i++) {\\n        // 执行bar后会给i重新赋值3，满足i&#x3C;=10，函数死循环\\n        bar(i * 2);\\n    }\\n}\\n</code></pre>\\n<p>这时候只需要在bar内部修改<code>i = 3</code>为<code>var i = 3</code>，将i变为<code>bar</code>中的本地变量即可。除了新建一个函数去隐藏变量，还能通过匿名函数的特性去实现隐藏变量，社区中也称为<strong>IIFE</strong>。</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function() {\\n    var a = 3;\\n    console.log(a); // 3\\n})()\\n\\nconsole.log(a); // 2\\n</code></pre>\\n<p>还能当作函数调用传参</p>\\n<pre><code class=\\\"language-javascript\\\">var a = 2;\\n\\n(function(global) {\\n    var a = 3;\\n\\n    console.log(a); // 3\\n    console.log(global.a); // 2\\n})(window)\\n</code></pre>\\n<p>通过隐藏变量活着函数，能实现<strong>全局命名空间</strong>或者<strong>JS模块化</strong>(后面会讨论到)。</p>\\n<h1>块作用域</h1>\\n<p>在JS中块作用域并不常见，但是某些代码却经常会被误以为是块作用域，所以很容易造成理解上的错误，例如下面的常用代码</p>\\n<pre><code class=\\\"language-javascript\\\">for(var i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nif(true) {\\n    var foo = 'bar';\\n}\\n\\nconsole.log(i, foo); // 10 bar\\n</code></pre>\\n<p>上面代码的<code>i</code>和<code>foo</code>其实都在外部作用域中定义的，而不是在代码块中定义的变量，所以平时在这些代码中定义变量应该是距离使用的地方越近越好。</p>\\n<h2>延长作用域链(块作用域)</h2>\\n<ul>\\n<li>\\n<p>with语句。with从对象中创建出来的对象只在with声明中有效。</p>\\n<pre><code class=\\\"language-javascript\\\">function foo() {\\nvar qs = \\\"?bar=true\\\";\\n\\nwith(location) {\\n    // href实际是location.href，只能在with内部使用\\n    var url = href + qs;\\n}\\n\\nreturn url;\\n}\\n</code></pre>\\n</li>\\n<li>\\n<p>try/catch中的catch分句会创造一个块作用域，声明的错误对象变量仅在catch内部有效。</p>\\n<pre><code class=\\\"language-javascript\\\">try {\\nundefined(); // 强制执行一个错误操作\\n} catch(err) {\\nconsole.log(err);\\n}\\n</code></pre>\\n</li>\\n</ul>\\n<p>console.log(err); // ReferenceError</p>\\n<pre><code>## let/const\\n在ES6中，引入了let和const，提供了除var以外的另一种声明变量的方式。用let/const声明的变量会绑定在所在的所用域中（通常是{ ... }内部，换句话说，let/const能劫持所在作用域。\\n```javascript\\n// 修改下上面的循环例子\\nfor(let i = 0; i &#x3C; 10; i++) {\\n    console.log(i);\\n}\\n\\nconsole.log(i); // ReferenceError\\n</code></pre>\\n<p>const在使用方法上跟len是一样，只是创建的值是固定的（常量）。后面任何修改值的操作都会报错。<strong>(注：const实际保证的并不是常量不能改变，而是变量的内存地址不能改变，所以对于复杂的类型object，也只能保证对象的指针地址是固定的，但是对象内部的数据结构则不能固定)</strong></p>\\n<pre><code class=\\\"language-javascript\\\">const foo = {};\\n\\nfoo.bar = 'bar';\\nconsole.log(foo.bar); // bar\\n\\nfoo = {}; // TypeError\\n</code></pre>\\n<h1>总结</h1>\\n<p>通过学习js中的作用域运行方式，了解变量在执行环境的声明周期，以及哪部分代码能访问其中的变量。能为后面学习<strong>闭包</strong>还有实现模块化打下基础。以下是关于作用域的几点总结：</p>\\n<ul>\\n<li>函数局部环境不仅有访问函数作用域的变量的权限，而且还有权访问其包含(父)环境的变量。</li>\\n<li>除全局、函数作用域外，还有比较少用的块作用域。</li>\\n</ul>\",\"htmlExcerpt\":\"<h1>前言</h1>\\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\\n<h1>作用域是什么</h1>\\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\\n<h2>理解作用域执行过程</h2>\\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\\n1. 遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\\n2. 接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</p>\\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"js实现add(1)(2)(3)\",\"date\":\"2017-05-28\",\"category\":[\"javascript\"],\"tags\":null,\"path\":\"/post/add-chain\"},\"excerpt\":\"\\n# 题目\\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现\\n\\n```javascript\\nfunction add(x) {\\n\\tvar fn = function(y) {\\n\\t\\treturn add(x + y);\\n\\t}\\n\\n\\treturn fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"题目\"},{\"depth\":1,\"value\":\"实现方法\"}],\"html\":\"<h1>题目</h1>\\n<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    return fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n</code></pre>\\n<!-- more -->\\n<h1>实现方法</h1>\\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    fn.toString = function() {\\n        return x;\\n    }\\n\\n    return fn;\\n}\\n\\n\\n// chrome  function 6\\n// firefox function add/fn\\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\\nconsole.log(add(1)(2)(3))\\n\\nconsole.log(add(1)(2)(3).toString()) // 6\\n</code></pre>\\n<p>由此看出在不同客户端下返回的结果并不一样，并不是完美的结果，但是查阅了其他资料并没有其他十分好的解决办法，估计这道题的考查点是关于js深度的，比如原生对象里面的基本方法和<code>alert</code>, <code>console</code>会自动执行toString等方法。</p>\\n<p>另外，<code>valueOf</code>和<code>toString</code>方法其实是差不多的，返回的结果基本都是相同的，但是试了一下定义了两个不同的方法，发现总是会返回valueOf的值先，所以觉得toString应该是应用于valueOf的结果。</p>\",\"htmlExcerpt\":\"<h1>题目</h1>\\n<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\\n当时第一反应就是用递归实现</p>\\n<pre><code class=\\\"language-javascript\\\">function add(x) {\\n    var fn = function(y) {\\n        return add(x + y);\\n    }\\n\\n    return fn;\\n}\\n\\nconsole.log(add(1)(2)(3))\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"Promise的简单实现\",\"date\":\"2017-05-17\",\"category\":[\"前端\"],\"tags\":[\"javascript\"],\"path\":\"/post/js-promise\"},\"excerpt\":\"\\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\\n\\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\\n\\n\\n\\n# 初步构建一个Promise\\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\\n```javascript\\n// 例1\\nfunction getAsyncData() {\\n\\treturn new Promise(function(resolve, reject) {\\n\\t\\tsetTimeout(function() {\\n\\t\\t\\tresolve('promise done!')\\n\\t\\t}, 1000)\\n\\t})\\n}\\n\\ngetAsyncData().then(function(result) {\\n\\tconsole.log(result);\\n}).then(function() {\\n\\tconsole.log('done too!');\\n})\\n```\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"初步构建一个Promise\"},{\"depth\":1,\"value\":\"引入状态\"},{\"depth\":1,\"value\":\"串行promise\"},{\"depth\":1,\"value\":\"添加reject功能\"},{\"depth\":1,\"value\":\"总结\"},{\"depth\":2,\"value\":\"参考\"}],\"html\":\"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\\\"https://promisesaplus.com/\\\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\\n<h1>初步构建一个Promise</h1>\\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\\n<pre><code class=\\\"language-javascript\\\">// 例1\\nfunction getAsyncData() {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve('promise done!')\\n        }, 1000)\\n    })\\n}\\n\\ngetAsyncData().then(function(result) {\\n    console.log(result);\\n}).then(function() {\\n    console.log('done too!');\\n})\\n</code></pre>\\n<!-- more -->\\n<p><code>getAsyncData</code>函数中返回一个promise对象，然后通过<code>then</code>方法执行函数的回调，然后尝试实现一下这个基本的功能</p>\\n<pre><code class=\\\"language-javascript\\\">// promise.js\\nvar Primose = function(fn) {\\n    var callbacks = [];\\n\\n    this.done = function(onFulfilled) {\\n        this.callbacks.push(onFulfilled)\\n\\n        // 支持链式调用\\n        return this;\\n    }\\n\\n    function resolve(value) {\\n        // push到队列的最底端，保证链式代码执行完后再执行方法\\n        setTimeout(function() {\\n            while(callbacks[0]) {\\n                callbacks.shift()()\\n            }\\n        }, 0)\\n    }\\n\\n    fn(resolve)\\n}\\n</code></pre>\\n<p>到这里就完成了promise的基础功能，然后执行一下看下有没有达到预期情况:</p>\\n<pre><code class=\\\"language-bash\\\">$node promise\\npromise done!\\ndone too!\\n</code></pre>\\n<p>乍看一下，怎么有点像lazyman(js中比较有名的题目，可以自行百度一下) ，看来平时多读书还是有好处的（手动滑稽）v</p>\\n<h1>引入状态</h1>\\n<p>这里我们可以先看下<a href=\\\"https://promisesaplus.com/#requirements\\\">promise状态规范</a></p>\\n<p>promise必需在pending, fulfilled或者reject三个状态中的一个</p>\\n<ul>\\n<li>\\n<p>当promise在pending状态中</p>\\n<ul>\\n<li>可以变为fulfilled或者reject状态</li>\\n</ul>\\n</li>\\n<li>\\n<p>当promise在fulfilled中</p>\\n<ul>\\n<li>不能过渡为其他状态</li>\\n<li>必需返回一个值，并且不能改变</li>\\n</ul>\\n</li>\\n<li>\\n<p>当promise在reject中</p>\\n<ul>\\n<li>不能过渡为其他状态</li>\\n<li>必需返回一个失败原因，并且不能改变</li>\\n</ul>\\n</li>\\n</ul>\\n<p>从这里可以看出，我们需要添加一个<code>status</code>变量保存状态，并且随着代码执行更新状态。</p>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        value = null,\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled) {\\n        if(state === 'pending') {\\n            callbacks.push(onFulfilled);\\n            return this;\\n        }\\n\\n        onFulfilled(value);\\n        return this;\\n    }\\n\\n    function resolve(newValue) {\\n        state = 'fulfilled';\\n        value = newValue;\\n\\n        setTimeout(function() {\\n            while(callbacks[0]) {\\n                callbacks.shift()(value)\\n            }\\n        }, 0)\\n    }\\n\\n    fn(resolve)\\n}\\n</code></pre>\\n<h1>串行promise</h1>\\n<p>在执行promise的时候，经常会在<code>then</code>的方法里面执行另外一个promise，<em>串联执行promise应该是promise里面最有趣并且是最核心的功能了</em>。</p>\\n<p>串行promise指执行完一个异步函数达到fulfilled状态后，接着执行下一个promise，例如</p>\\n<pre><code class=\\\"language-javascript\\\">// 接着例1\\n\\ngetAsyncData()\\n    .then(getAsyncData2)\\n    .then(function(data) {\\n        console.log(data + 'done too!');\\n    })\\n\\nfunction getAsyncData2(result) {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve(result + 'next promise done!')\\n        }, 1000)\\n    })\\n}\\n</code></pre>\\n<p>要实现这个功能，首先，我们，之前的<code>then</code>方法是直接把<code>this</code>返回出去，所以实现链式调用，执行起来的时候也扛扛的，没毛病，但如果then中执行下一个promise，这时候按上面的代码，应该是直接就return一个promise出去的，走不了下一步，所以<code>then</code>方法应该需要处理一下，promise的执行方式应该要变为：</p>\\n<ol>\\n<li>执行代码，将所有方法push到<code>callbacks</code>数组里面</li>\\n<li>如果<code>then</code>中是一个promise，把剩下的<code>callbacks</code>提交到这个promise中执行</li>\\n<li>再循环第一步</li>\\n</ol>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        // value = null,\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled) {\\n        switch(state) {\\n            case 'pending':\\n                callbacks.push(onFulfilled)\\n                return this;\\n                break;\\n            case 'fulfilled':\\n                onFulfilled()\\n                return this;\\n                break;\\n        }\\n    }\\n\\n    function resolve(newValue) {\\n        var value = newValue;\\n        var temp = null;\\n\\n        setTimeout(function() {\\n            state = 'fulfilled';\\n            do {\\n                temp = callbacks.shift()(value)\\n                // 顺序执行数组，如果是resolve返回value\\n                // 如果是promise则把后面的then方法提交到下个promise中执行\\n                if(temp instanceof Promise) {\\n                    while(callbacks[0]) {\\n                        temp.then(callbacks.shift())\\n                    }\\n                    return;\\n                }else {\\n                    value = temp;\\n                }\\n            }while(callbacks[0])\\n        }, 0)\\n    }\\n    fn(resolve)\\n}\\n</code></pre>\\n<h1>添加reject功能</h1>\\n<p>因为不确定then方法中是否会添加reject的处理，所以选用了一个比较笨的方法，加一个<code>errDerrers</code>的数组，每次执行不管有没有方法<code>then</code>都<code>push</code>到数组里面，<code>resolve</code>一个方法就<code>shift</code>一个，跟成功的回调一样，当reject的时候，判断下当前的方法是不是一个可执行函数，如果是的话则执行。至于catch的方法按这个思路暂时没想到，后面想到再更新。修改的地方都有添加注释。</p>\\n<pre><code class=\\\"language-javascript\\\">var Promise = function(fn) {\\n    var state = 'pending',\\n        // value = null,\\n        error = null,\\n        errDeffers = [],\\n        callbacks = [];\\n\\n    this.then = function(onFulfilled, rejected) {\\n        switch(state) {\\n            case 'pending':\\n                callbacks.push(onFulfilled);\\n                // 每次执行then都push一次\\n                errDeffers.push(rejected);\\n                return this;\\n                break;\\n            case 'fulfilled':\\n                onFulfilled()\\n                return this;\\n                break;\\n            // reject的话直接执行\\n            case 'rejected':\\n                rejected(error);\\n                return this;\\n                break;\\n        }\\n    }\\n\\n    this.catch = function(rejected) {\\n        if(errDeffer === null) {\\n            errDeffer = rejected;\\n            return;\\n        }\\n    }\\n\\n    function resolve(newValue) {\\n        var value = newValue;\\n        var temp = null;\\n\\n        setTimeout(function() {\\n            state = 'fulfilled';\\n            do {\\n                temp = callbacks.shift()(value);\\n                errDeffers.shift();\\n                // 顺序执行数组，如果是resolve返回value\\n                // 如果是promise则把后面的then方法提交到下个promise中执行\\n                if(temp instanceof Promise) {\\n\\n                    while(callbacks[0]) {\\n                        // 成功的时候也要更新一下errDeffers数组\\n                        temp.then(callbacks.shift(), errDeffers.shift())\\n                    }\\n\\n                    return;\\n                }else {\\n                    value = temp;\\n                }\\n            }while(callbacks[0])\\n        }, 0)\\n    }\\n\\n    // reject方法\\n    // 判断rejected是否一个函数，是的话执行，不是的话抛出一个错误\\n    // reject也要提交到栈的最底端执行\\n    function reject(err) {\\n        setTimeout(function() {\\n            state = 'rejected';\\n            error = err;\\n            var rejected = errDeffers.shift();\\n\\n            if(Object.prototype.toString.call(rejected) !== '[object Function]') {\\n                throw new Error('Uncaught promise error!');\\n                return;\\n            }\\n\\n            rejected(error);\\n        }, 0)\\n    }\\n\\n    fn(resolve, reject)\\n}\\n</code></pre>\\n<h1>总结</h1>\\n<p>找资料的时候看到<a href=\\\"http://tech.meituan.com/promise-insight.html\\\">美团技术团队博客的实现方式</a>采用了另外一种解决方式解决串行promise，后面接着研究下，有兴趣也可以自行看下。\\n实现promise应该有下面几个要点：</p>\\n<ol>\\n<li>函数的顺序执行</li>\\n<li>处理好状态（这部分感觉我的方法跟promiseA的状态要求有点偏差）</li>\\n<li>链式调用\\n这个例子只是根据promise的执行方式实现大概的功能，后面或许会根据promise规范去实现一个比较规范的demo。</li>\\n</ol>\\n<h2>参考</h2>\\n<ul>\\n<li><a href=\\\"https://promisesaplus.com/#requirements\\\">Promises/A+</a></li>\\n<li><a href=\\\"http://tech.meituan.com/promise-insight.html\\\">剖析 Promise 之基础篇</a></li>\\n<li><a href=\\\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\\\">Javascript异步编程的4种方法</a></li>\\n</ul>\",\"htmlExcerpt\":\"<p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href=\\\"https://promisesaplus.com/\\\">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>\\n<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>\\n<h1>初步构建一个Promise</h1>\\n<p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>\\n<pre><code class=\\\"language-javascript\\\">// 例1\\nfunction getAsyncData() {\\n    return new Promise(function(resolve, reject) {\\n        setTimeout(function() {\\n            resolve('promise done!')\\n        }, 1000)\\n    })\\n}\\n\\ngetAsyncData().then(function(result) {\\n    console.log(result);\\n}).then(function() {\\n    console.log('done too!');\\n})\\n</code></pre>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"前端单元测试&Mocha指北\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":null,\"path\":\"/post/unit-test\"},\"excerpt\":\"\\n# 什么是单元-测试?\\n- 单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。\\n- 而测试，就是测试啦。\\n\\n所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。\\n\\n# 为什么要写单元测试？\\n单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。\\n\\n\",\"headings\":[{\"depth\":1,\"value\":\"什么是单元-测试?\"},{\"depth\":1,\"value\":\"为什么要写单元测试？\"},{\"depth\":1,\"value\":\"干了这杯 \\\"Mocha\\\"\"},{\"depth\":2,\"value\":\"举个例子\"},{\"depth\":1,\"value\":\"小结\"}],\"html\":\"<h1>什么是单元-测试?</h1>\\n<ul>\\n<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>\\n<li>而测试，就是测试啦。</li>\\n</ul>\\n<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>\\n<h1>为什么要写单元测试？</h1>\\n<p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>\\n<!-- more -->\\n<h1>干了这杯 \\\"Mocha\\\"</h1>\\n<p>mocha是一个js测试框架，除此外，类似的测试框架还有Jasmine、Karma、Tape等，至于为什么要介绍Mocha？因为我只懂这一个。\\n上代码前还要普及一下两个概念</p>\\n<ul>\\n<li><a href=\\\"https://zh.wikipedia.org/wiki/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91\\\">BDD（Behavior Driven Development）</a>\\nBDD意为行为驱动开发，是一种敏捷软件开发技术，具体内容大家可以参考wikipedia的解释。</li>\\n<li><a href=\\\"https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)\\\">Assertion 断言</a>\\n断言，就是判断代码的执行结果与预期是否一致，不一致就抛出错误，说得简单点就是判断程序的真假。</li>\\n</ul>\\n<h2>举个例子</h2>\\n<pre><code class=\\\"language-javascript\\\">// add.js\\nfunction add(a, b) {\\n    return a + b\\n}\\nmodule.exports = add\\n</code></pre>\\n<p>通常测试脚本要与测试源码同名，比如add.js的测试脚本就是add.test.js</p>\\n<pre><code class=\\\"language-javascript\\\">// add.test.js\\nconst add = require('./add.js')\\nconst expect = require('chai').expect\\n\\ndescribe('加法函数测试', function() {\\n    it('1 + 1 等于 2', function() {\\n        expect(add(1, 1)).to.be.equal(2)\\n    })\\n    it('返回值是Number', function() {\\n        expect(add(1, 1)).to.be.a('number')\\n    })\\n})\\n</code></pre>\\n<p>上面代码块就是测试脚本，可独立运行，测试脚本中应该包括一个或多个<code>describe</code>块，每个<code>describe</code>块应包括多个<code>it</code>块。\\n<code>describe</code>是测试套件，这个方法需要传两个参数，第一个为测试套件的名称<code>('加法函数测试')</code>，第二个是执行函数。\\n<code>it</code>块是测试用例，表示一个单独的测试，是测试的最小单位，第一个参数是测试用例的名称('1 + 1 等于 2')，第二个是执行函数。</p>\\n<p>然后在terminal下执行<code>mocha add.test.js</code></p>\\n<pre><code class=\\\"language-terminal\\\">$ mocha add.test.js\\n\\n   加法函数测试\\n     √ 1 + 1 等于 2\\n     √ 返回值是Number\\n   2 passing (12ms)\\n</code></pre>\\n<p>如果我们改变一下<code>add.js</code></p>\\n<pre><code class=\\\"language-javascript\\\">// add.js\\nfunction add(a, b) {\\n    return a * b\\n}\\nmodule.exports = add\\n</code></pre>\\n<p>然后再执行一下<code>mocha add.test.js</code></p>\\n<pre><code class=\\\"language-terminal\\\">$ mocha add.test.js\\n\\n   加法函数测试\\n     √ 1 + 1 等于 2\\n     1) 返回值是Number\\n   1 passing (8ms)\\n   1 failing\\n\\n   1) 加法函数测试 返回值是Number:\\n       AssertionError: expected 2 to equal 3\\n       + expected - actual\\n\\n       -2\\n       +3\\n\\n       at Context.it(add.test.js:6:27)\\n</code></pre>\\n<p>这里也可以很明显看出哪个测试用例报错、还有报错的位置，这样在开发的时候开发人员就能很容易定位错误。</p>\\n<h1>小结</h1>\\n<p>从上面一个简单的例子可以看出，利用mocha实现自动化测试是很简单的。虽然前期开发需要花一点时间去写单元测试，但是后面提供的便利性足以将其弥补。</p>\",\"htmlExcerpt\":\"<h1>什么是单元-测试?</h1>\\n<ul>\\n<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>\\n<li>而测试，就是测试啦。</li>\\n</ul>\\n<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>\\n<h1>为什么要写单元测试？</h1>\\n<p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p>\\n\"}},{\"node\":{\"frontmatter\":{\"title\":\"使用nodejs写一个命令行程序\",\"date\":\"2017-05-16\",\"category\":[\"前端\"],\"tags\":[\"nodejs\",\"bash\"],\"path\":\"/post/node-command-app\"},\"excerpt\":\"\\n> 原文译自[Smashing Magazine](https://www.smashingmagazine.com/) -- [[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)\\n\\n相信很多前端都听说过或者使用过[Gulp](http://www.gulpjs.com.cn/), [Angular CLI](https://cli.angular.io/), [Cordova](https://cordova.apache.org/), [Yeoman](http://yeoman.io/)或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用`ng new <project-name>`后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。\\n\\n在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用[SendGrid Api](https://github.com/sendgrid/sendgrid-nodejs)模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令\\n\\n\",\"headings\":[{\"depth\":2,\"value\":\"“Hello World”\"},{\"depth\":2,\"value\":\"处理命令行参数\"},{\"depth\":2,\"value\":\"运行时输入参数\"},{\"depth\":2,\"value\":\"模拟发送邮件\"},{\"depth\":2,\"value\":\"变成shell命令\"}],\"html\":\"<blockquote>\\n<p>原文译自<a href=\\\"https://www.smashingmagazine.com/\\\">Smashing Magazine</a> -- <a href=\\\"https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/\\\">[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)</a></p>\\n</blockquote>\\n<p>相信很多前端都听说过或者使用过<a href=\\\"http://www.gulpjs.com.cn/\\\">Gulp</a>, <a href=\\\"https://cli.angular.io/\\\">Angular CLI</a>, <a href=\\\"https://cordova.apache.org/\\\">Cordova</a>, <a href=\\\"http://yeoman.io/\\\">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code>ng new &#x3C;project-name></code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>\\n<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href=\\\"https://github.com/sendgrid/sendgrid-nodejs\\\">SendGrid Api</a>模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令</p>\\n<!-- more -->\\n<hr>\\n<h2>“Hello World”</h2>\\n<p>开始前，首先你得有node，如果没有，请自行安装下。node中自带npm，使用<a href=\\\"https://www.npmjs.com/\\\">npm</a>能安装许多开源的node模块。首先，使用npm创建一个node项目</p>\\n<pre><code class=\\\"language-shell\\\">$ npm init\\nname: broadcast\\nversion: 0.0.1\\ndescription: CLI utility to broadcast email\\nentry point: broadcast.js\\n</code></pre>\\n<p>除这些参数外，npm还提供了其他如Git repository等参数，可根据自身需求设置输入。执行完<code>npm init</code>后，会发现在同目录下生成了一个<code>package.json</code>文件，文件里面包含了上面命令输入的信息。配置内容信息可以在<a href=\\\"https://docs.npmjs.com/files/package.json\\\">package.json文档</a>中找到。</p>\\n<p>然后，还是从最简单的Hello World入手。首先在同目录下建一个<code>broadcast.js</code>文件</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\nconsole.log('Hello World!')\\n</code></pre>\\n<p>然后在terminal中执行</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast\\nHello World!\\n</code></pre>\\n<p>well done, 根据<a href=\\\"https://docs.npmjs.com/files/package.json\\\">package.json文档</a>，我们可以找到一个<code>dependencies</code>参数，在这参数中你可以找到所有这项目需要用到的第三方模块和它们的版本号，上面也有提及到，我们需要用到模块去开发这个工具。最后开发完成，<code>package.json</code>应该如下</p>\\n<pre><code class=\\\"language-json\\\">{\\n    \\\"name\\\": \\\"broadcast\\\",\\n    \\\"version\\\": \\\"0.0.1\\\",\\n    \\\"description\\\": \\\"CLI utility to broadcast emails\\\",\\n    \\\"main\\\": \\\"broadcast.js\\\",\\n    \\\"license\\\": \\\"MIT\\\",\\n    \\\"dependencies\\\": {\\n        \\\"chalk\\\": \\\"^1.1.3\\\",\\n        \\\"commander\\\": \\\"^2.9.0\\\",\\n        \\\"csv\\\": \\\"^1.1.0\\\",\\n        \\\"inquirer\\\": \\\"^2.0.0\\\"\\n    }\\n}\\n</code></pre>\\n<p>这几个模块 <a href=\\\"https://github.com/chalk/chalk\\\">Chalk</a>, <a href=\\\"https://github.com/tj/commander.js\\\">Commander</a>, <a href=\\\"https://github.com/sboudrias/Inquirer.js\\\">Inquirer</a>, <a href=\\\"http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/\\\">CSV</a>的具体用处跟其他参数，可以自行查看。</p>\\n<h2>处理命令行参数</h2>\\n<p>node原生也有读取命令行的函数<a href=\\\"https://nodejs.org/docs/latest/api/process.html\\\"><code>process.argv</code></a>，但是解析参数是个繁琐的工作，所以我们会使用<a href=\\\"https://github.com/tj/commander.js\\\">Commander</a>去替代这些工作。Commande的另外一个好处就是不用额外的去写一个<code>--help</code>函数，只要定义了其他参数，<code>--help</code>函数就会自动生成。首先安装一下Commander和其他package</p>\\n<pre><code class=\\\"language-shell\\\">$ npm install commander chalk csv inquirer --save\\n</code></pre>\\n<p>然后修改<code>broadcast.js</code></p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast\\nconst program = require('commander')\\n\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'list of customers in CSV file')\\n    .parse(process.argv)\\n\\nconsole.log(program.list)\\n</code></pre>\\n<p>从上面可以看出，处理一个参数是十分简单的。我们定义了一个<code>--list</code>的参数，现在我们就能通过<code>--list</code>参数获取到命令行传过来的值。在这程序中，list应该是接收一个csv的地址参数，然后打印在console中。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --list ./test.csv\\n./test.csv\\n</code></pre>\\n<p>从js中可以看到还有一个<code>version</code>参数，所以我们可以使用<code>--version</code>读取版本号。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --version\\n0.0.1\\n</code></pre>\\n<p>又或者能使用<code>--help</code>获取app能接收的参数</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast --help\\n\\n  Usage: broadcast [options]\\n\\n  Options:\\n\\n    -h, --help                 output usage information\\n    -V, --version              output the version number\\n    -l, --list &#x3C;list>          list of customers in CSV file\\n</code></pre>\\n<p>现在我们已经能够接收到命令行传递过来的参数了，下面我们会利用接收到的CSV文件地址，并使用<a href=\\\"http://www.adaltas.com/en/2012/08/21/node-csv-stable-version-0-1-0/\\\">CSV</a>模块处理CSV文件的内容。\\n我们会使用下面的比哦啊哥内容作为CSV文件的内容。使用CSV模块，会读取内容，并显示各列的内容。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>First name</th>\\n<th>Last name</th>\\n<th>Email</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Dwight</td>\\n<td>Schrute</td>\\n<td>dwight.schrute@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Jim</td>\\n<td>Halpert</td>\\n<td>jim.halpert@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Pam</td>\\n<td>Beesly</td>\\n<td>pam.beesly@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Ryan</td>\\n<td>Howard</td>\\n<td>ryan.howard@dundermifflin.com</td>\\n</tr>\\n<tr>\\n<td>Stanley</td>\\n<td>Hudson</td>\\n<td>stanley.hudson@dundermifflin.com</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>现在，更新下<code>broadcast.js</code>，使用CSV读取内容并打印在console</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\nconst program = require('commander')\\nconst csv = require('csv')\\nconst fs = require('fs')\\n\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'List of customers in CSV')\\n    .parse(process.argv)\\n\\nconst stream = fs.createReadStream(program.list)\\nstream\\n    .pipe(csv.parse({ delimiter : \\\",\\\" }))\\n    .on('data', function(data) {\\n         const firstname = data[0]\\n         const lastname = data[1]\\n         const email = data[2]\\n\\n         console.log(firstname, lastname, email)\\n    })\\n</code></pre>\\n<p>除csv模块外，还使用了node的<a href=\\\"https://nodejs.org/dist/latest-v7.x/docs/api/fs.html\\\">File System</a>模块读取文件内容，csv的<code>parse</code>方法把列数据解析为数组，然后在terminal中运行一下命令</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast.js --list ./test.csv\\nDwight Schrute dwight.schrute@dundermifflin.com\\nJim Halpert jim.halpert@dundermifflin.com\\nPam Beesly pam.beesly@dundermifflin.com\\nRyan Howard ryan.howard@dundermifflin.com\\nStanley Hudson stanley.hudson@dundermifflin.com\\n</code></pre>\\n<h2>运行时输入参数</h2>\\n<p>上面已经实现了获取命令行参数，但如果想在运行时候接收参数值的话我们就需要另外一个模块<a href=\\\"https://github.com/sboudrias/Inquirer.js\\\">inquirer.js</a>，通过这个模块，用户可以自定义多种参数类型，如文本，密码，单选或者多选列表等。</p>\\n<p>下面的demo会通过inquirer接收邮件发送人的名字，email还有邮件主题。</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\n...\\nconst inquirer = require('inquirer')\\nconst questions = [\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"sender.email\\\",\\n    message : \\\"Sender's email address - \\\"\\n  },\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"sender.name\\\",\\n    message : \\\"Sender's name - \\\"\\n  },\\n  {\\n    type : \\\"input\\\",\\n    name : \\\"subject\\\",\\n    message : \\\"Subject - \\\"\\n  }\\n]\\n\\nprogram\\n  .version('0.0.1')\\n  .option('-l, --list [list]', 'List of customers in CSV')\\n  .parse(process.argv)\\n\\n// 储存CSV数据\\nconst contactList = []\\nconst stream = fs.createReadStream(program.list)\\n    .pipe(csv.parse({ delimiter : \\\",\\\" }))\\n\\nstream\\n  .on('error', function (err) {\\n    return console.error(err.message)\\n  })\\n  .on('data', function (data) {\\n    let name = data[0] + \\\" \\\" + data[1]\\n    let email = data[2]\\n    contactList.push({ name : name, email : email })\\n  })\\n  .on('end', function () {\\n    inquirer.prompt(questions).then(function (answers) {\\n      console.log(answers)\\n    })\\n  })\\n</code></pre>\\n<p>Inquire.js的<code>prompt</code>方法接受一个数组参数，数组里可以自定义运行时需要接受的问题参数，在这demo里面，我们想知道发送者的名字还要email还有邮件主题，所以定义了一个<code>questions</code>的数组来储存问题，从对象里面可以看到有一个<code>input</code>的参数，除此外还可以接受<code>password</code>等其他类型，具体可以查询一下<a href=\\\"https://github.com/SBoudrias/Inquirer.js/\\\">inquirer的文档</a>。此外，参数<code>name</code>保存input的key值。<code>prompt</code>方法会返还一个promise对象，promise中会返回一个<code>answer</code>变量，里面带有刚才输入的值。</p>\\n<pre><code class=\\\"language-shell\\\">$ node broadcast -l input/employees.csv\\n? Sender's email address -  kitssang_demo@163.com\\n? Sender's name -  kit\\n? Subject - Hello World\\n{ sender:\\n   { email: '  kitssang_demo@163.com',\\n     name: 'kit' },\\n  subject: 'Hello World' }\\n</code></pre>\\n<h2>模拟发送邮件</h2>\\n<p>由于原文使用的<code>sendgrid</code>没有跑通，所以只组装了一下数据模拟了发送邮件。原本的第五部分也在这里一起用上了。</p>\\n<pre><code class=\\\"language-javascript\\\">// broadcast.js\\n...\\nprogram\\n    .version('0.0.1')\\n    .option('-l, --list [list]', 'list of customers in CSV file')\\n    .parse(process.argv)\\n\\nconst sendEmail = function(to, from, subject) {\\n    const sender = chalk.green(`${from.name}(${from.email})`)\\n    const receiver = chalk.green(`${to.name}(${to.email})`)\\n    const theme = chalk.blue(subject)\\n\\n    console.log(`${sender} send a mail to ${receiver} and the subject of the email is ${theme}`)\\n}\\n\\n// 储存CSV数据\\nlet concatList = []\\nconst stream = fs.createReadStream(program.list)\\n  .pipe(csv.parse({\\n    delimiter: ','\\n  }))\\n  .on('data', function(data) {\\n    const name = data[0] + ' ' + data[1]\\n    const email = data[2]\\n\\n    concatList.push({\\n      name: name,\\n      email: email\\n    })\\n  })\\n  .on('end', function() {\\n    inquirer.prompt(questions).then((ans) => {\\n      for (let i = 0; i &#x3C; concatList.length; i++) {\\n        sendEmail(concatList[i], ans.sender, ans.subject)\\n      }\\n    }).catch((err) => {\\n      console.log(err)\\n    })\\n  })\\n</code></pre>\\n<p>由于没有异步请求，<code>async</code>模块没有用上，另外使用了<code>chalk</code>模块改变了console打印结果的颜色。</p>\\n<h2>变成shell命令</h2>\\n<p>至此，整个工具已经基本完成，但是如果想像一个普通的shell命令(不加<code>$ node xx</code>)执行，还需要做以下操作。首先，添加<a href=\\\"https://zh.wikipedia.org/wiki/Shebang\\\">shebang</a>在js的头部，让shell知道如何执行这个文件。</p>\\n<pre><code class=\\\"language-javascript\\\">#!/usr/bin/env node\\n\\n// broadcast.js\\nconst program = require(\\\"commander\\\")\\nconst inquirer = require(\\\"inquirer\\\")\\n...\\n</code></pre>\\n<p>然后再配置一下<code>package.json</code>使代码可运行</p>\\n<pre><code class=\\\"language-json\\\">…\\n  \\\"description\\\": \\\"CLI utility to broadcast emails\\\",\\n  \\\"main\\\": \\\"broadcast.js\\\",\\n  \\\"bin\\\" : {\\n    \\\"broadcast\\\" : \\\"./broadcast.js\\\"\\n  }\\n…\\n</code></pre>\\n<p>从代码可以看到加了一个<a href=\\\"https://docs.npmjs.com/files/package.json#bin\\\"><code>bin</code></a>的参数，这个参数可以使broadcast命令与broadcast.js建立连接。</p>\\n<p>最后一步，在全局安装一下依赖包。在项目目录运行一下下面的命令。</p>\\n<pre><code class=\\\"language-shell\\\">$ npm install -g\\n</code></pre>\\n<p>然后测试一下命令</p>\\n<pre><code class=\\\"language-shell\\\">$ broadcast --help\\n</code></pre>\\n<p>需要注意的是，在开发时候如果使用<code>commaner</code>默认给出的命令执行<code>broadcast</code>则在代码中所做的任何更改都是看不见的。假如输入<code>which broadcast</code>，你会发现地址不是你当前目录，所以这时应该要用<code>npm link</code>去查看命令的目录映射。</p>\",\"htmlExcerpt\":\"<blockquote>\\n<p>原文译自<a href=\\\"https://www.smashingmagazine.com/\\\">Smashing Magazine</a> -- <a href=\\\"https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/\\\">[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)</a></p>\\n</blockquote>\\n<p>相信很多前端都听说过或者使用过<a href=\\\"http://www.gulpjs.com.cn/\\\">Gulp</a>, <a href=\\\"https://cli.angular.io/\\\">Angular CLI</a>, <a href=\\\"https://cordova.apache.org/\\\">Cordova</a>, <a href=\\\"http://yeoman.io/\\\">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code>ng new &#x3C;project-name></code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>\\n<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href=\\\"https://github.com/sendgrid/sendgrid-nodejs\\\">SendGrid Api</a>模拟发送）\\n文章目录：\\n1.\\\"Hello World\\\"\\n2.处理命令行参数\\n3.运行时输入参数\\n4.模拟发送邮件\\n5.改变输出内容样式\\n6.变成shell命令</p>\\n\"}}],\"page\":3,\"pages\":4,\"total\":16,\"limit\":5,\"prev\":\"/blog/2\",\"next\":\"/blog/4\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-3.json\n// module id = 287\n// module chunks = 173394108556902"],"sourceRoot":""}