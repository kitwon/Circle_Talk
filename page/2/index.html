<!DOCTYPE html><html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0,  user-scalable=0" name="viewport"><title>KIT</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/index.min.css"></head><body><nav class="nav-button-list"><div class="btn menu show-canvas"><span class="icon-bar"></span></div><div class="btn top btn-go-top"><i class="ion-arrow-up-c"></i><span class="scroll-percentage">0%</span></div></nav><div class="container-fluid page-header"><div class="header"><p class="first">hi Babe</p><p class="second">look at this kingdom. i conquered for thee.</p><span class="third">kit's note</span></div><div class="background"></div></div><div class="main-wrap"><div class="container"><div class="row"><div class="col-lg-3 side-bar-left"><div class="sidebar-content"><div class="main-side-bar"><div class="header"><p>这里好像会有个搜索</p></div><nav class="side-bar-nav"><a href="/" class="item"><span>首页</span></a><a href="/archives" class="item m"><span>归档</span></a><a href="/tags" class="item last unopen"><span>标签</span></a></nav></div><div class="card user-card"><div class="user-image"><img src="/img/head.jpeg" class="img-fluid"></div><div class="user-info"><div class="user-name">kitwang chan</div><div class="user-other">frontend/UI designer</div></div><div class="overview"><span><i>12</i><br/> 日志</span><span class="m"><i>6</i><br/> 分类</span><span><i>9</i><br/> 标签</span></div></div></div></div><div class="col-lg-9 main-content"><div class="post-wrap content-wrap index-post-wrap"><article class="post post-list"><header class="header"><a href="/2017/05/31/深入学习javascript-作用域/">深入学习javascript--作用域</a></header><section class="info"><div class="item"><i class="ion-android-calendar"></i><span>发表于 2017年5月31日</span></div><div class="item"><i class="ion-android-folder-open"></i><span>分类于 <a href="/categories/javascript/">javascript</a></span></div></section><section class="excerpt"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>
<h1 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h1><p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>
<h2 id="理解作用域执行过程"><a href="#理解作用域执行过程" class="headerlink" title="理解作用域执行过程"></a>理解作用域执行过程</h2><p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>
<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。</p>
<ol>
<li>遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。</li>
<li>接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</li>
</ol>
<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p></section><a href="/2017/05/31/深入学习javascript-作用域/" class="readmore">read more</a></article><article class="post post-list"><header class="header"><a href="/2017/05/28/js实现add(1)(2)(3)/">js实现add(1)(2)(3)</a></header><section class="info"><div class="item"><i class="ion-android-calendar"></i><span>发表于 2017年5月28日</span></div><div class="item"><i class="ion-android-folder-open"></i><span>分类于 <a href="/categories/javascript/">javascript</a></span></div></section><section class="excerpt"><p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。<br>当时第一反应就是用递归实现</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function add(x) {
    var fn = function(y) {
        return add(x + y);
    }

    return fn;
}

console.log(add(1)(2)(3))
</code></pre>
<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">function add(x) {
    var fn = function(y) {
        return add(x + y);
    }

    fn.toString = function() {
        return x;
    }

    return fn;
}


// chrome  function 6
// firefox function add/fn
// node    { [Number: 6] toString: [Function], valueOf: [Function] }
console.log(add(1)(2)(3))

console.log(add(1)(2)(3).toString()) // 6
</code></pre></section><a href="/2017/05/28/js实现add(1)(2)(3)/" class="readmore">read more</a></article><article class="post post-list"><header class="header"><a href="/2017/05/17/Promise的简单实现/">Promise的简单实现</a></header><section class="info"><div class="item"><i class="ion-android-calendar"></i><span>发表于 2017年5月17日</span></div><div class="item"><i class="ion-android-folder-open"></i><span>分类于 <a href="/categories/前端/">前端</a></span></div></section><section class="excerpt"><p>老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，<a href="https://promisesaplus.com/" target="_blank" rel="external">promise</a>（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。</p>
<p>下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。</p>
<h1 id="初步构建一个Promise"><a href="#初步构建一个Promise" class="headerlink" title="初步构建一个Promise"></a>初步构建一个Promise</h1><p>我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现</p>
<p></p><p class="code-caption" data-lang="javascript" data-line_number="backend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="javascript">// 例1
function getAsyncData() {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve(&#39;promise done!&#39;)
        }, 1000)
    })
}

getAsyncData().then(function(result) {
    console.log(result);
}).then(function() {
    console.log(&#39;done too!&#39;);
})
</code></pre></section><a href="/2017/05/17/Promise的简单实现/" class="readmore">read more</a></article><article class="post post-list"><header class="header"><a href="/2017/05/16/前端单元测试-Mocha指北/">前端单元测试&Mocha指北</a></header><section class="info"><div class="item"><i class="ion-android-calendar"></i><span>发表于 2017年5月16日</span></div><div class="item"><i class="ion-android-folder-open"></i><span>分类于 <a href="/categories/前端/">前端</a></span></div></section><section class="excerpt"><h1 id="什么是单元-测试"><a href="#什么是单元-测试" class="headerlink" title="什么是单元-测试?"></a>什么是单元-测试?</h1><ul>
<li>单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。</li>
<li>而测试，就是测试啦。</li>
</ul>
<p>所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。</p>
<h1 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h1><p>单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。<br>又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。</p></section><a href="/2017/05/16/前端单元测试-Mocha指北/" class="readmore">read more</a></article><article class="post post-list"><header class="header"><a href="/2017/05/16/使用nodejs写一个命令行程序/">使用nodejs写一个命令行程序</a></header><section class="info"><div class="item"><i class="ion-android-calendar"></i><span>发表于 2017年5月16日</span></div><div class="item"><i class="ion-android-folder-open"></i><span>分类于 <a href="/categories/前端/">前端</a></span></div></section><section class="excerpt"><blockquote>
<p>原文译自<a href="https://www.smashingmagazine.com/" target="_blank" rel="external">Smashing Magazine</a> – <a href="https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/" target="_blank" rel="external"><a href="https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/" target="_blank" rel="external">How To Develop An Interactive Command Line Application Using Node.js</a></a></p>
</blockquote>
<p>相信很多前端都听说过或者使用过<a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">Gulp</a>, <a href="https://cli.angular.io/" target="_blank" rel="external">Angular CLI</a>, <a href="https://cordova.apache.org/" target="_blank" rel="external">Cordova</a>, <a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a>或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用<code>ng new &lt;project-name&gt;</code>后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。</p>
<p>在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用<a href="https://github.com/sendgrid/sendgrid-nodejs" target="_blank" rel="external">SendGrid Api</a>模拟发送）<br>文章目录：<br>1.”Hello World”<br>2.处理命令行参数<br>3.运行时输入参数<br>4.模拟发送邮件<br>5.改变输出内容样式<br>6.变成shell命令</p></section><a href="/2017/05/16/使用nodejs写一个命令行程序/" class="readmore">read more</a></article><nav class="pagination index-pagination"><a href="/" class="item"><i class="ion-ios-arrow-left"></i></a><a href="/" class="item">1</a><a href="/page/2" class="item active">2</a><a href="/page/3" class="item">3</a><a href="/page/3/" class="item"><i class="ion-ios-arrow-right"></i></a></nav></div></div></div></div><div class="container-fluid copyright"><div> <span>©   2015 - 2016</span><i class="icon ion-ios-nutrition"></i><span>Kit</span></div><div><span>power by </span><span><a href="//hexo.io">hexo.</a></span><span>Design By Kit.</span></div></div></div><script src="/js/vendor.min.js"></script><script src="/js/index.min.js"></script></body></html>